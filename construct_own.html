
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="evolutionary.html">
      
      
        <link rel="next" href="add_data.html">
      
      
      <link rel="icon" href="assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.17">
    
    
      
        <title>8. Construct Own Optimizations - COBRA-k</title>
      
    
    
      <link rel="stylesheet" href="assets/stylesheets/main.7e37652d.min.css">
      
        
        <link rel="stylesheet" href="assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
        <script src="assets/external/unpkg.com/iframe-worker/shim.js"></script>
      
    
    
      
    
    
      <link rel="stylesheet" href="assets/_mkdocstrings.css">
    
      <link rel="stylesheet" href="javascript/katex/katex.min.css">
    
      <link rel="stylesheet" href="css-extra.css">
    
    <script>__md_scope=new URL(".",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#construct-own-milps-or-nlps" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="index.html" title="COBRA-k" class="md-header__button md-logo" aria-label="COBRA-k" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            COBRA-k
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              8. Construct Own Optimizations
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme)" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m14.3 16-.7-2h-3.2l-.7 2H7.8L11 7h2l3.2 9zM20 8.69V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12zm-9.15 3.96h2.3L12 9z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_2" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to system preference"  type="radio" name="__palette" id="__palette_2">
    
      <label class="md-header__button md-icon" title="Switch to system preference" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="index.html" title="COBRA-k" class="md-nav__button md-logo" aria-label="COBRA-k" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    COBRA-k
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="index.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Start
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="installation.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    1. Installation
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="model_from_scratch.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2. Create model from scratch
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="model_io.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    3. Load/Save models
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="lps.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    4. Linear Programs & Pretty-Print
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="milps.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    5. Mixed-Integer Linear Programs
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="nlps.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    6. Nonlinear COBRA-k Programs
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="evolutionary.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    7. Evolutionary Optimization
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    8. Construct Own Optimizations
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="construct_own.html" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    8. Construct Own Optimizations
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#introduction" class="md-nav__link">
    <span class="md-ellipsis">
      Introduction
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#example-1-construct-own-milps" class="md-nav__link">
    <span class="md-ellipsis">
      Example 1: Construct own (MI)LPs
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#example-2-construct-own-nlps" class="md-nav__link">
    <span class="md-ellipsis">
      Example 2: Construct own NLPs
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="add_data.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    9. Automatic data collection
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="parameter_corrections.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    10. Parameter corrections
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="utilities.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    11. More utilities
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="paper_reproduction.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    12. Paper result reproduction
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="api.html" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    API Reference
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#introduction" class="md-nav__link">
    <span class="md-ellipsis">
      Introduction
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#example-1-construct-own-milps" class="md-nav__link">
    <span class="md-ellipsis">
      Example 1: Construct own (MI)LPs
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#example-2-construct-own-nlps" class="md-nav__link">
    <span class="md-ellipsis">
      Example 2: Construct own NLPs
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="construct-own-milps-or-nlps">Construct Own (MI)LPs or NLPs</h1>
<details class="abstract">
<summary>Quickstart code</summary>
<div class="highlight"><pre><span></span><code><span class="c1">#%% Construct own MILP</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">cobrak.example_models</span><span class="w"> </span><span class="kn">import</span> <span class="n">toy_model</span>
<span class="c1"># Get the functionality that returns a basic (Mixed-Integer) Linear Program,</span>
<span class="c1"># i.e. with steady-state constraint and variables for all reactions, and</span>
<span class="c1"># if such constraints are chosen, also enzymes and metabolites.</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">cobrak.lps</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_lp_from_cobrak_model</span>
<span class="c1"># Using COBRA-k&#39;s pyomo_functionality submodule, get the functions for setting</span>
<span class="c1"># a custom objective and getting a pyomo solver</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">cobrak.pyomo_functionality</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_solver</span>
<span class="c1"># Get a needed constants from COBRA-k</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">cobrak.constants</span><span class="w"> </span><span class="kn">import</span> <span class="n">BIG_M</span>
<span class="c1"># Get the function that converts pyomo solution states into a COBRA-k dictionary</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">cobrak.utilities</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_pyomo_solution_as_dict</span>
<span class="c1"># Also get a pretty-printing function</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">cobrak.printing</span><span class="w"> </span><span class="kn">import</span> <span class="n">print_dict</span>
<span class="c1"># Get the needed classes from pyomo</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pyomo.environ</span><span class="w"> </span><span class="kn">import</span> <span class="n">Constraint</span><span class="p">,</span> <span class="n">Binary</span><span class="p">,</span> <span class="n">Var</span>

<span class="c1"># Get the basic steady-state Linear Program, here with enzyme and thermodynamic</span>
<span class="c1"># constraints.</span>
<span class="c1"># This function has many more options that you can read in the</span>
<span class="c1"># API reference.</span>
<span class="c1"># The returned lp is a *pyomo* ConcreteModel object on which all operations</span>
<span class="c1"># for pyomo models can be performed.</span>
<span class="n">lp</span> <span class="o">=</span> <span class="n">get_lp_from_cobrak_model</span><span class="p">(</span>
    <span class="n">cobrak_model</span><span class="o">=</span><span class="n">toy_model</span><span class="p">,</span>
    <span class="n">with_enzyme_constraints</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">with_thermodynamic_constraints</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">with_loop_constraints</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># Get all reaction IDs that start with &quot;EX_&quot;</span>
<span class="n">ex_reac_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">reac_id</span> <span class="k">for</span> <span class="n">reac_id</span> <span class="ow">in</span> <span class="n">toy_model</span><span class="o">.</span><span class="n">reactions</span> <span class="k">if</span> <span class="n">reac_id</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;EX_&quot;</span><span class="p">)]</span>

<span class="c1"># Now, add the EX_ reaction constraints in pyomo-style, i.e. using</span>
<span class="c1"># Python&#39;s general getattr and setattr functions.</span>
<span class="k">for</span> <span class="n">ex_reac_id</span> <span class="ow">in</span> <span class="n">ex_reac_ids</span><span class="p">:</span>
    <span class="c1"># Get the *pyomo* LP flux variable</span>
    <span class="n">flux_var</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">ex_reac_id</span><span class="p">)</span>

    <span class="c1"># Now let&#39;s add a new binary variable for this EX_ reaction</span>
    <span class="c1"># just as we would do it in pyomo</span>
    <span class="n">new_binary_var_id</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;new_binary_</span><span class="si">{</span><span class="n">ex_reac_id</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">new_binary_var_id</span><span class="p">,</span> <span class="n">Var</span><span class="p">(</span><span class="n">within</span><span class="o">=</span><span class="n">Binary</span><span class="p">))</span>

    <span class="c1"># Finally, let&#39;s add an associated constraints through</span>
    <span class="c1"># which the reaction can only run if the new binary variable &gt; 0</span>
    <span class="c1"># We formulate it in Big-M style (i.e. if the binary variable</span>
    <span class="c1"># = 1, the reaction flux can be &lt;= Big-M, whereby Big-M is just</span>
    <span class="c1"># a large value)</span>
    <span class="nb">setattr</span><span class="p">(</span>
        <span class="n">lp</span><span class="p">,</span>
        <span class="sa">f</span><span class="s2">&quot;new_constraint_</span><span class="si">{</span><span class="n">ex_reac_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="n">Constraint</span><span class="p">(</span><span class="n">expr</span><span class="o">=</span><span class="n">flux_var</span> <span class="o">&lt;=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">new_binary_var_id</span><span class="p">)</span> <span class="o">*</span> <span class="n">BIG_M</span><span class="p">)</span>
    <span class="p">)</span>

<span class="c1"># Now that we&#39;ve added the constraints and variables, we can run the minimization :D</span>
<span class="c1"># First, we manually choose a pyomo solver for this (here, the pre-packaged free solver SCIP)</span>
<span class="c1"># (alternatively, we could also construct a Solver dataclass instance first and</span>
<span class="c1"># send its data to get_solver).</span>
<span class="n">pyomo_lp_solver</span> <span class="o">=</span> <span class="n">get_solver</span><span class="p">(</span>
    <span class="n">solver_name</span><span class="o">=</span><span class="s2">&quot;scip&quot;</span><span class="p">,</span>
    <span class="n">solver_options</span><span class="o">=</span><span class="p">{},</span>
    <span class="n">solver_attrs</span><span class="o">=</span><span class="p">{},</span>
<span class="p">)</span>

<span class="c1"># With this solver, we can now solve the optimization :D</span>
<span class="c1"># (here, in verbose style)</span>
<span class="n">pyomo_lp_solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">tee</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># We then retrieve the solution as a dictionary in the form of dict[str, float]</span>
<span class="n">lp_result_dict</span> <span class="o">=</span> <span class="n">get_pyomo_solution_as_dict</span><span class="p">(</span><span class="n">lp</span><span class="p">)</span>

<span class="c1"># Finally, print the (unspecatular) result</span>
<span class="n">print_dict</span><span class="p">(</span><span class="n">lp_result_dict</span><span class="p">)</span>


<span class="c1">#%% Construct own NLP</span>
<span class="c1"># (See previous example for more comments)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">cobrak.example_models</span><span class="w"> </span><span class="kn">import</span> <span class="n">toy_model</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">cobrak.nlps</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_nlp_from_cobrak_model</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">cobrak.pyomo_functionality</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_solver</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">cobrak.utilities</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_pyomo_solution_as_dict</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">cobrak.printing</span><span class="w"> </span><span class="kn">import</span> <span class="n">print_dict</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">cobrak.constants</span><span class="w"> </span><span class="kn">import</span> <span class="n">LNCONC_VAR_PREFIX</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pyomo.environ</span><span class="w"> </span><span class="kn">import</span> <span class="n">Constraint</span><span class="p">,</span> <span class="n">Reals</span><span class="p">,</span> <span class="n">Var</span>

<span class="c1"># Get the basic steady-state Non-Linear Program, here with enzyme and thermodynamic</span>
<span class="c1"># constraints.</span>
<span class="c1"># This function has many more options that you can read in the</span>
<span class="c1"># API reference.</span>
<span class="c1"># Again, the returned nlp is a *pyomo* ConcreteModel object on which all operations</span>
<span class="c1"># for pyomo models can be performed.</span>
<span class="n">nlp</span> <span class="o">=</span> <span class="n">get_nlp_from_cobrak_model</span><span class="p">(</span>
    <span class="n">cobrak_model</span><span class="o">=</span><span class="n">toy_model</span><span class="p">,</span>
    <span class="n">ignored_reacs</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">with_kappa</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">with_gamma</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># Get all logarithmic metabolite IDs</span>
<span class="n">log_met_conc_ids</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">LNCONC_VAR_PREFIX</span><span class="si">}{</span><span class="n">met_id</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">met_id</span> <span class="ow">in</span> <span class="n">toy_model</span><span class="o">.</span><span class="n">metabolites</span><span class="p">]</span>

<span class="c1"># Now, create a sum that represents the squared sum</span>
<span class="c1"># of logarithmic concentrations</span>
<span class="n">squared_log_metconc_sum</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="k">for</span> <span class="n">log_met_conc_id</span> <span class="ow">in</span> <span class="n">log_met_conc_ids</span><span class="p">:</span>
    <span class="c1"># Get the *pyomo* NLP metabolite concentration variable</span>
    <span class="c1"># and add its squared sum</span>
    <span class="n">squared_log_metconc_sum</span> <span class="o">+=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">nlp</span><span class="p">,</span> <span class="n">log_met_conc_id</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>

<span class="c1"># Now let&#39;s add a new real variable for the squared sum that</span>
<span class="c1"># is always equal to it (i.e. it represents this sum, making</span>
<span class="c1"># it later possible to minimize it :-)</span>
<span class="c1"># Also, set it to values &gt;=0</span>
<span class="n">squared_met_logconc_sum_var_id</span> <span class="o">=</span> <span class="s2">&quot;squared_met_logconc_sum&quot;</span>
<span class="nb">setattr</span><span class="p">(</span><span class="n">nlp</span><span class="p">,</span> <span class="n">squared_met_logconc_sum_var_id</span><span class="p">,</span> <span class="n">Var</span><span class="p">(</span><span class="n">within</span><span class="o">=</span><span class="n">Reals</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1e6</span><span class="p">)))</span>
<span class="c1"># Now fix this variable to the pyomo sum expression we created</span>
<span class="nb">setattr</span><span class="p">(</span>
    <span class="n">nlp</span><span class="p">,</span>
    <span class="s2">&quot;squared_met_logconc_sum_constraint&quot;</span><span class="p">,</span>
    <span class="n">Constraint</span><span class="p">(</span><span class="n">expr</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">nlp</span><span class="p">,</span> <span class="n">squared_met_logconc_sum_var_id</span><span class="p">)</span> <span class="o">==</span> <span class="n">squared_log_metconc_sum</span><span class="p">)</span>
<span class="p">)</span>

<span class="c1"># Now we get the NLP solver</span>
<span class="n">pyomo_nlp_solver</span> <span class="o">=</span> <span class="n">get_solver</span><span class="p">(</span>
    <span class="n">solver_name</span><span class="o">=</span><span class="s2">&quot;ipopt&quot;</span><span class="p">,</span>
    <span class="n">solver_options</span><span class="o">=</span><span class="p">{},</span>
    <span class="n">solver_attrs</span><span class="o">=</span><span class="p">{},</span>
<span class="p">)</span>

<span class="c1"># With this solver, we can now solve the optimization :D</span>
<span class="c1"># (here, in verbose style)</span>
<span class="n">pyomo_nlp_solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">nlp</span><span class="p">,</span> <span class="n">tee</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># We then retrieve the solution as a dictionary in the form of dict[str, float]</span>
<span class="n">nlp_result_dict</span> <span class="o">=</span> <span class="n">get_pyomo_solution_as_dict</span><span class="p">(</span><span class="n">nlp</span><span class="p">)</span>

<span class="c1"># Finally, print the (unspecatular) result</span>
<span class="n">print_dict</span><span class="p">(</span><span class="n">nlp_result_dict</span><span class="p">)</span>
</code></pre></div>
</details>
<h2 id="introduction">Introduction</h2>
<p>Up to now, we looked at the range of predefined (mixed-integer) linear programs (e.g. ecTFVA, bottleneck analyses, ...; see LP and MILP chapters) and non-linear programs (see NLP chapter) provided by COBRA-k, whereby...</p>
<ul>
<li>...the general optimization functions (such as <code>perform_lp_optimization</code>and <code>perform_nlp_optimization</code>) allow one to optimize any objective function in the model</li>
<li>...and the special optimziation functions (such as <code>perform_lp_thermodynamic_bottleneck_analysis</code>) provide expanded programs with additional constraints and variables.</li>
</ul>
<p>But sometimes, for advanced optimizations, you need to add your own extra constraints and/or variables. Luckily, this is possible in COBRA-k thanks to its internal usage of pyomo <a href="">Website</a><a href="">GitHub</a>, as explained in the following subchapters :-)</p>
<div class="admonition note">
<p class="admonition-title">Alternative for simple cases: Extra (non-)linear watches and constraints</p>
<p>If you just want to restrict a (non-)linear weighted sum of any kind of model variables, you can always use the <code>extra_linear_watches</code>, <code>extra_nonlinear_watches</code>, <code>extra_linear_constraints</code> and <code>extra_nonlinear_constraints</code> member variable as explained in the LP and NLP chapters and the API documentation.</p>
</div>
<h2 id="example-1-construct-own-milps">Example 1: Construct own (MI)LPs</h2>
<p>Let's say that we want to minimize the number of used exchange reactions (i.e. reactions where a metabolite is consumed or produced "out of nothing"; commonly, their ID starts with "EX_"). As they do not have an associated ΔᵣG'° (see MILP chapter), we do not have binary variables for them which control whether they are active or not. So let's introduce these binary variables and performing the subsequent minimization as follows for our toy model:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Get our toy model</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">cobrak.example_models</span><span class="w"> </span><span class="kn">import</span> <span class="n">toy_model</span>
<span class="c1"># Get the functionality that returns a basic (Mixed-Integer) Linear Program,</span>
<span class="c1"># i.e. with steady-state constraint and variables for all reactions, and</span>
<span class="c1"># if such constraints are chosen, also enzymes and metabolites.</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">cobrak.lps</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_lp_from_cobrak_model</span>
<span class="c1"># Using COBRA-k&#39;s pyomo_functionality submodule, get the functions for setting</span>
<span class="c1"># a custom objective and getting a pyomo solver</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">cobrak.pyomo_functionality</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_solver</span>
<span class="c1"># Get a needed constants from COBRA-k</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">cobrak.constants</span><span class="w"> </span><span class="kn">import</span> <span class="n">BIG_M</span>
<span class="c1"># Get the function that converts pyomo solution states into a COBRA-k dictionary</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">cobrak.utilities</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_pyomo_solution_as_dict</span>
<span class="c1"># Also get a pretty-printing function</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">cobrak.printing</span><span class="w"> </span><span class="kn">import</span> <span class="n">print_dict</span>
<span class="c1"># Get the needed classes from pyomo</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pyomo.environ</span><span class="w"> </span><span class="kn">import</span> <span class="n">Constraint</span><span class="p">,</span> <span class="n">Binary</span><span class="p">,</span> <span class="n">Var</span>

<span class="c1"># Get the basic steady-state Linear Program, here with enzyme and thermodynamic</span>
<span class="c1"># constraints.</span>
<span class="c1"># This function has many more options that you can read in the</span>
<span class="c1"># API reference.</span>
<span class="c1"># The returned lp is a *pyomo* ConcreteModel object on which all operations</span>
<span class="c1"># for pyomo models can be performed.</span>
<span class="n">lp</span> <span class="o">=</span> <span class="n">get_lp_from_cobrak_model</span><span class="p">(</span>
    <span class="n">cobrak_model</span><span class="o">=</span><span class="n">toy_model</span><span class="p">,</span>
    <span class="n">with_enzyme_constraints</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">with_thermodynamic_constraints</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">with_loop_constraints</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># Get all reaction IDs that start with &quot;EX_&quot;</span>
<span class="n">ex_reac_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">reac_id</span> <span class="k">for</span> <span class="n">reac_id</span> <span class="ow">in</span> <span class="n">toy_model</span><span class="o">.</span><span class="n">reactions</span> <span class="k">if</span> <span class="n">reac_id</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;EX_&quot;</span><span class="p">)]</span>

<span class="c1"># Now, add the EX_ reaction constraints in pyomo-style, i.e. using</span>
<span class="c1"># Python&#39;s general getattr and setattr functions.</span>
<span class="k">for</span> <span class="n">ex_reac_id</span> <span class="ow">in</span> <span class="n">ex_reac_ids</span><span class="p">:</span>
    <span class="c1"># Get the *pyomo* LP flux variable</span>
    <span class="n">flux_var</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">ex_reac_id</span><span class="p">)</span>

    <span class="c1"># Now let&#39;s add a new binary variable for this EX_ reaction</span>
    <span class="c1"># just as we would do it in pyomo</span>
    <span class="n">new_binary_var_id</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;new_binary_</span><span class="si">{</span><span class="n">ex_reac_id</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">new_binary_var_id</span><span class="p">,</span> <span class="n">Var</span><span class="p">(</span><span class="n">within</span><span class="o">=</span><span class="n">Binary</span><span class="p">))</span>

    <span class="c1"># Finally, let&#39;s add an associated constraints through</span>
    <span class="c1"># which the reaction can only run if the new binary variable &gt; 0</span>
    <span class="c1"># We formulate it in Big-M style (i.e. if the binary variable</span>
    <span class="c1"># = 1, the reaction flux can be &lt;= Big-M, whereby Big-M is just</span>
    <span class="c1"># a large value)</span>
    <span class="nb">setattr</span><span class="p">(</span>
        <span class="n">lp</span><span class="p">,</span>
        <span class="sa">f</span><span class="s2">&quot;new_constraint_</span><span class="si">{</span><span class="n">ex_reac_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="n">Constraint</span><span class="p">(</span><span class="n">expr</span><span class="o">=</span><span class="n">flux_var</span> <span class="o">&lt;=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">new_binary_var_id</span><span class="p">)</span> <span class="o">*</span> <span class="n">BIG_M</span><span class="p">)</span>
    <span class="p">)</span>

<span class="c1"># Now that we&#39;ve added the constraints and variables, we can run the minimization :D</span>
<span class="c1"># First, we manually choose a pyomo solver for this (here, the pre-packaged free solver SCIP)</span>
<span class="c1"># (alternatively, we could also construct a Solver dataclass instance first and</span>
<span class="c1"># send its data to get_solver).</span>
<span class="n">pyomo_lp_solver</span> <span class="o">=</span> <span class="n">get_solver</span><span class="p">(</span>
    <span class="n">solver_name</span><span class="o">=</span><span class="s2">&quot;scip&quot;</span><span class="p">,</span>
    <span class="n">solver_options</span><span class="o">=</span><span class="p">{},</span>
    <span class="n">solver_attrs</span><span class="o">=</span><span class="p">{},</span>
<span class="p">)</span>

<span class="c1"># With this solver, we can now solve the optimization :D</span>
<span class="c1"># (here, in verbose style)</span>
<span class="n">pyomo_lp_solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">tee</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># We then retrieve the solution as a dictionary in the form of dict[str, float]</span>
<span class="n">lp_result_dict</span> <span class="o">=</span> <span class="n">get_pyomo_solution_as_dict</span><span class="p">(</span><span class="n">lp</span><span class="p">)</span>

<span class="c1"># Finally, print the (unspecatular) result</span>
<span class="n">print_dict</span><span class="p">(</span><span class="n">lp_result_dict</span><span class="p">)</span>
</code></pre></div>
<h2 id="example-2-construct-own-nlps">Example 2: Construct own NLPs</h2>
<p>Of course, we can also construct our own NLPs. Here's an example where we (for whatever reason xD) we try to minimize the
<em>squared</em> logarithmic metabolite concentrations in our model:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># (See previous example for more comments)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">cobrak.example_models</span><span class="w"> </span><span class="kn">import</span> <span class="n">toy_model</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">cobrak.nlps</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_nlp_from_cobrak_model</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">cobrak.pyomo_functionality</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_solver</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">cobrak.utilities</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_pyomo_solution_as_dict</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">cobrak.printing</span><span class="w"> </span><span class="kn">import</span> <span class="n">print_dict</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">cobrak.constants</span><span class="w"> </span><span class="kn">import</span> <span class="n">LNCONC_VAR_PREFIX</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pyomo.environ</span><span class="w"> </span><span class="kn">import</span> <span class="n">Constraint</span><span class="p">,</span> <span class="n">Reals</span><span class="p">,</span> <span class="n">Var</span>

<span class="c1"># Get the basic steady-state Non-Linear Program, here with enzyme and thermodynamic</span>
<span class="c1"># constraints.</span>
<span class="c1"># This function has many more options that you can read in the</span>
<span class="c1"># API reference.</span>
<span class="c1"># Again, the returned nlp is a *pyomo* ConcreteModel object on which all operations</span>
<span class="c1"># for pyomo models can be performed.</span>
<span class="n">nlp</span> <span class="o">=</span> <span class="n">get_nlp_from_cobrak_model</span><span class="p">(</span>
    <span class="n">cobrak_model</span><span class="o">=</span><span class="n">toy_model</span><span class="p">,</span>
    <span class="n">ignored_reacs</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">with_kappa</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">with_gamma</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># Get all logarithmic metabolite IDs</span>
<span class="n">log_met_conc_ids</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">LNCONC_VAR_PREFIX</span><span class="si">}{</span><span class="n">met_id</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">met_id</span> <span class="ow">in</span> <span class="n">toy_model</span><span class="o">.</span><span class="n">metabolites</span><span class="p">]</span>

<span class="c1"># Now, create a sum that represents the squared sum</span>
<span class="c1"># of logarithmic concentrations</span>
<span class="n">squared_log_metconc_sum</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="k">for</span> <span class="n">log_met_conc_id</span> <span class="ow">in</span> <span class="n">log_met_conc_ids</span><span class="p">:</span>
    <span class="c1"># Get the *pyomo* NLP metabolite concentration variable</span>
    <span class="c1"># and add its squared sum</span>
    <span class="n">squared_log_metconc_sum</span> <span class="o">+=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">nlp</span><span class="p">,</span> <span class="n">log_met_conc_id</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>

<span class="c1"># Now let&#39;s add a new real variable for the squared sum that</span>
<span class="c1"># is always equal to it (i.e. it represents this sum, making</span>
<span class="c1"># it later possible to minimize it :-)</span>
<span class="c1"># Also, set it to values &gt;=0</span>
<span class="n">squared_met_logconc_sum_var_id</span> <span class="o">=</span> <span class="s2">&quot;squared_met_logconc_sum&quot;</span>
<span class="nb">setattr</span><span class="p">(</span><span class="n">nlp</span><span class="p">,</span> <span class="n">squared_met_logconc_sum_var_id</span><span class="p">,</span> <span class="n">Var</span><span class="p">(</span><span class="n">within</span><span class="o">=</span><span class="n">Reals</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1e6</span><span class="p">)))</span>
<span class="c1"># Now fix this variable to the pyomo sum expression we created</span>
<span class="nb">setattr</span><span class="p">(</span>
    <span class="n">nlp</span><span class="p">,</span>
    <span class="s2">&quot;squared_met_logconc_sum_constraint&quot;</span><span class="p">,</span>
    <span class="n">Constraint</span><span class="p">(</span><span class="n">expr</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">nlp</span><span class="p">,</span> <span class="n">squared_met_logconc_sum_var_id</span><span class="p">)</span> <span class="o">==</span> <span class="n">squared_log_metconc_sum</span><span class="p">)</span>
<span class="p">)</span>

<span class="c1"># Now we get the NLP solver</span>
<span class="n">pyomo_nlp_solver</span> <span class="o">=</span> <span class="n">get_solver</span><span class="p">(</span>
    <span class="n">solver_name</span><span class="o">=</span><span class="s2">&quot;ipopt&quot;</span><span class="p">,</span>
    <span class="n">solver_options</span><span class="o">=</span><span class="p">{},</span>
    <span class="n">solver_attrs</span><span class="o">=</span><span class="p">{},</span>
<span class="p">)</span>

<span class="c1"># With this solver, we can now solve the optimization :D</span>
<span class="c1"># (here, in verbose style)</span>
<span class="n">pyomo_nlp_solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">nlp</span><span class="p">,</span> <span class="n">tee</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># We then retrieve the solution as a dictionary in the form of dict[str, float]</span>
<span class="n">nlp_result_dict</span> <span class="o">=</span> <span class="n">get_pyomo_solution_as_dict</span><span class="p">(</span><span class="n">nlp</span><span class="p">)</span>

<span class="c1"># Finally, print the (unspecatular) result</span>
<span class="n">print_dict</span><span class="p">(</span><span class="n">nlp_result_dict</span><span class="p">)</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": ".", "features": ["content.code.copy"], "search": "assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="assets/javascripts/bundle.92b07e13.min.js"></script>
      
        <script src="javascript/katex/katex.min.js"></script>
      
        <script src="javascript/katex/contrib/auto-render.min.js"></script>
      
        <script src="javascript/init_katex.js"></script>
      
        <script src="assets/external/unpkg.com/mermaid@11/dist/mermaid.min.js"></script>
      
    
  </body>
</html>