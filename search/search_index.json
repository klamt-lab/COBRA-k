{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Welcome to COBRA-k's documentation \ud83d\ude3a","text":"<p>This documentation explains how to use the COBRA-k Python package, which is the reference implementation of COBRA-k (COnstraint-Based Reconstruction and Analysis with kinetics). To learn all about COBRA-k's main features, follow the numbered chapters on the left :-)</p> <p>Info</p> <p>At the start of many chapters, you may find a quickstart variant section, where a condensed down version of the chapter's code is presented.</p> <p>Also note that, in this documentation's formulas, bold capital letters represent matrices (e.g. \\(\\mathbf{X}\\)), bold small letters vectors (e.g. \\(\\mathbf{x}\\)) and italic letters single numeric values (e.g. \\(x\\)).</p> <p>For more about COBRA-k's features, code and license, visit its GitHub repository.</p> <p>If you use COBRA-k in your academic work, please cite its publication:</p> <p>[1] Bekiaris PS &amp; Klamt S (2025). COBRA-k: a powerful framework bridging constraint-based and kinetic metabolic modeling. Submitted.</p>"},{"location":"add_data.html","title":"Automatically add kinetic and thermodynamic data","text":"<p>If you want to perform COBRA-k's thermodynamic and/or enzyme kinetic (\"thermokinetic\") analyses, you need appropriate data. When loading an existing model (see previous chapter) or create a new Model instance from scratch (see second to last chapter), such data is often missing or at least not directly included in the model instance. To collect such data, COBRA-k provides two major ways, a fully automated one and one where you can add data manually thanks to its <code>model_instantiation</code> submodule:</p>"},{"location":"add_data.html#automatic-way","title":"Automatic way","text":"<p>The automatic way of adding thermokinetic data to a newly loaded SBML file uses the function <code>get_cobrak_model_with_kinetic_data_from_sbml_model_alone</code>. Regarding the SBML model, it needs the following identifier usage for reections and metabolites:</p> <ul> <li>for the reactions: An EC number annotation using the annotation key \"ec-code\"</li> <li>for the metabolites: BiGG IDs as identifiers</li> </ul> <p>Furthermore, some extra non-optional settings have to be provided, whereby the latino-greek organism name is very important.</p> <p>In addition, the following databases have to be downloaded manually beforehand:</p> <ul> <li>The BRENDA .json.tar.gz from https://www.brenda-enzymes.org/download.php</li> <li>The BiGG metabolites txt from http://bigg.ucsd.edu/data_access</li> <li>taxdmp.zip from https://ftp.ncbi.nih.gov/pub/taxonomy/</li> </ul> <p>SABIO-RK and UniProt data are downloaded automatically into a file in the given folder of the function (see below). Keep in mind that this download may take several dozens of minutes! Once the database is downloaded, it is cached, and no new download is triggered.</p> <p>Using all this information the automatic procedure collects the following information and adds it to the Model:</p> <ul> <li>\\(k_{cat}\\), \\(K_M\\) and \\(K_I\\) data: From SABIO-RK and BRENDA</li> <li>Hill coefficients: From SABIO-RK</li> <li>Molecular enzyme weights: From UniProt</li> <li>Taxonomic distances (used to collect taxonomically nearer enzyme kinetic data): From NCBI TAXONOMY</li> <li>\\(\u0394_r G^{'\u00b0}\\): Using the eQuilibrator API</li> </ul> <p>Here's a usage example:</p> <pre><code>from cobrak.model_instantiation import get_cobrak_model_with_kinetic_data_from_sbml_model_alone\nfrom cobrak.dataclasses import ParameterRange\n\ncobrak_model = get_cobrak_model_with_kinetic_data_from_sbml_model_alone(\n    sbml_model_path=\"/path/to/sbml.xml\",\n    path_to_external_resources=\"/path/where/the/manually/downloaded/datafiles/are\",\n    folder_of_sabio_database: \"/path/where/the/sabiork/database/shall/be/downloaded\",\n    brenda_version=\"$CURRENT_BRENDA_VERSION\", # E.g. 2023_1\n    prefer_brenda=True, # Whether or not BRENDA k_cat or k_M, ... values shall be used if SABIO-RK data is available\n    base_species=\"$MODEL_SPECIES\", # E.g. Escherichia coli\n    max_prot_pool=0.5,\n    conc_ranges={\n        # E.g., for all metabolites without a given identifier,\n        # we can use the key \"DEFAULT\":\n        \"DEFAULT\": ParameterRange(1e-6, 0.02),\n        # (...)\n    },\n    inner_to_outer_compartments=[\"INNERMOST_COMPARTMENT\", \"NEXT_TO_INNERMOST_\", ], # E.g., [\"c\", \"p\", \"e\"], used for dG0 calculation\n    phs={\"c\": 7.0, } # dict[str, float], shows ph of each compartment in the model, used for dG0 calculation\n    pmgs={\"c\": 2.5, } # dict[str, float], shows pMg of each compartment in the model, used for dG0 calculation\n    ionic_strenghts={\"c\": 250, }, # dict[str, float], shows ionic strength in mM of each compartment in the model, used for dG0 calculation\n    potential_differences={(\"c\", \"p\"): 0.15, }, # dict[tuple[str, str], float], shows potential difference from first to second given compartment in mV, used for dG0 calculation\n    kinetic_ignored_enzymes=[\"IDS\", \"OF\", \"IGNORED\", \"ENZYMES\", ], # Enzymes for which no kinetic shall be found\n    custom_kms_and_kcats={}, # Can be dict[str, EnzymeReactionData | None] if you want to overwrite some kms or kcats\n    kinetic_ignored_metabolites=[\"IDS\", \"OF\", \"IGNORED\", \"METABOLITES\",], # IDs of metabolites for which no enzyme kinetic value (e.g., K_M) shall be found\n    do_model_fullsplit = True, # Explained below\n    do_delete_enzymatically_suboptimal_reactions = True, # Explained below\n    ignore_dG0_uncertainty=True, # Whether or not eQuilibrator-calculated dG0 uncertainties shall be simply set to 0\n    enzyme_conc_ranges={}, # Is dict[str, ParameterRange | None]\n    dG0_exclusion_prefixes=[], # Prefixes (first parts of IDs) for which no dG0 shall be set, a common one would be \"EX_\"; is list[str]\n    dG0_exclusion_inner_parts=[], # Infixes (inner parts of IDs) for which no dG0 shall be set, is list[str]\n    extra_flux_constraints=[], # list[ExtraFluxConstraint]\n    extra_conc_ratios=[], # Is list[ExtraConcRatios]\n    data_cache_folder=\"/path/to/folder/for/uniprot/cache\",\n    R=$GAS_CONSTANT, # Default is STANDARD_R\n    T=$TEMPERATURE, # Default is STANDARD_T\n    add_hill_coefficients=True,  # Default is True, if False, no Hill coefficeints are loaded\n)\n</code></pre> <p>Two of the arguments have the following non-obvious meanings:</p> <ul> <li><code>do_model_fullsplit</code>: This means that each reaction is going to be split i) for forward &amp; reverse directions and ii) for each enzyme (complex) catalyzing it. E.g., a reversible reaction <code>R1: A \u2192 B</code> catalyzed by the enzyme \\(E_1\\) and the enzyme complex \\(E_{2,sub1} \\space and \\space E_{2,sub2}\\) is going to be split into the four reactions <code>R1_ENZ_E1_FWD: A \u2192 B$,  $R1_ENZ_E2SUB1_AND_E2SUB2_FWD: A \u2192 B</code> and <code>R1_ENZ_E1_REV: B \u2192 A</code>,  <code>R1_ENZ_E2SUB1_AND_E2SUB2_REV: B \u2192 A</code>. This fullsplit is neccessary in order to perform thermodynamic and enzymatic calculations later on.</li> <li><code>do_delete_enzymatically_suboptimal_reactions</code>: Akin to the enzyme constraint method sMOMENT [!], all (fullsplit) variants of a reaction which do not have the lowest \\(k_{cat}/MW\\) ratio (i.e., which have higher enzyme costs \u00e0 flux) are deleted. Keep in mind that, while this can drastically reduce a model's size, this also means that any \\(K_M\\), \\(K_I\\) etc. variants of reactions are not considered.</li> </ul>"},{"location":"add_data.html#manual-and-semi-automatic-way","title":"Manual and semi-automatic way","text":"<p>If you want to automatically create only a select amount of data, look up COBRA-k's submodules <code>equilibrator_functionality</code> (for \\(\u0394_r G^{'\u00b0}\\)), <code>uniprot_functionality</code> (for molecular enzyme weights), <code>sabio_rk_functionality</code> (for enzyme kinetic data from SABIO-RK), <code>brenda_functionality</code> (for enzyme kinetic data from BRENDA) and <code>ncbi_taxonomy_functionality</code> (for taxonomy distance data). Their functions are also described in this documentation's API reference.</p> <p>Finally, if you already have some data and want to add it to an SBML file Model generation, you can use <code>get_cobrak_model_from_sbml_and_thermokinetic_data</code> as follows:</p> <pre><code>from cobrak.model_instantiation import get_cobrak_model_from_sbml_and_thermokinetic_data\nfrom cobrak.dataclasses import EnzymeReactionData, ParameterRange\n\ncobrak_model = get_cobrak_model_from_sbml_and_thermokinetic_data(\n    sbml_path=\"path/to/sbml.xml\",\n    extra_flux_constraints: list[ExtraFluxConstraint],\n    dG0s={ # Is dict[str, float], unit is kJ/mol\n        \"$REAC_ID\": dG0_of_reaction,\n        # (...)\n    },\n    dG0_uncertainties={ # Is dict[str, float], unit is kJ/mol\n        \"$REAC_ID\": dG0_of_reaction,\n        # (...)\n    },\n    conc_ranges={ # Is dict[str, ParameterRange], these are the concentrations in M\n        \"$MET_ID\": ParameterRange(minimum=min_conc_of_met, maximum=max_conc_of_met),\n        # (...)\n    },\n    extra_conc_ratios=[], # Is a list[ExtraConcRatios]\n    enzyme_molecular_weights={ # Is dict[str, float], MW in g/mmol\n        \"$ENZYME_ID\": molecular_weight,\n        # (...)\n    },\n    enzyme_reaction_data: dict[str, EnzymeReactionData | None],  # Contains k_cats, k_ms, k_is, k_as and Hill coefficients\n    max_prot_pool=0.5, # In g/gDW\n    kinetic_ignored_metabolites=[\"h2_c\", \"h2_p\",], # Is list[str]\n    enzyme_conc_ranges = { # Is dict[str, ParameterRange | None]\n        \"$ENZYME_ID\": ParameterRange(minimum=min_enzyme_conc, maximum=max_enzyme_conc),\n        # (...)\n    },\n    do_model_fullsplit: bool = False, # Explained below\n    do_delete_enzymatically_suboptimal_reactions: bool = True, # Explained below\n    R: float = STANDARD_R, # Standard gas constant\n    T: float = STANDARD_T, # Standard temperature\n)\n</code></pre> <p>Note</p> <p>For a real-life example of a semi-automated way of collecting enzymatic data, look into the file \"examples/iCH360/B_prepare_external_data_for_cobrak.py\" in COBRA-k's \"examples/iCH360\" repository subfolder. It also contains separate calls to the BRENDA and SABIO-RK functionalities.</p>"},{"location":"api.html","title":"COBRA-k API reference","text":"<p>COBRAk is a general COBRA/COBRA-k suite written as Python package. For more about it, visit its repository: https://github.com/klamt-lab/COBRAk</p> <p>The init file of COBRAk initializes the rich text output &amp; tracebacks as well as its logger. Furthermore, graceful shutdown of user-induced shutdowns is enabled.</p>"},{"location":"api.html#cobrak.exit_signal_handler","title":"<code>exit_signal_handler(sig, frame)</code>","text":"<p>Handles the exit signal by printing a shutdown message and exiting the program.</p> <p>Parameters:</p> Name Type Description Default <code>sig</code> <code>int</code> <p>The signal number.</p> required <code>frame</code> <code>Optional[FrameType]</code> <p>The current frame.</p> required Source code in <code>cobrak/__init__.py</code> <pre><code>def exit_signal_handler(\n    sig: int,  # noqa: ARG001\n    frame: FrameType | None,  # noqa: ARG001\n) -&gt; None:  # pragma: no cover\n    \"\"\"Handles the exit signal by printing a shutdown message and exiting the program.\n\n    Args:\n        sig (int): The signal number.\n        frame (Optional[FrameType]): The current frame.\n    \"\"\"\n    print(\n        \"COBRAk received user signal to terminate (this message may appear multiple times in parallelized contexts). Shutting down...\"\n    )\n    sys.exit(0)\n</code></pre>"},{"location":"api.html#cobrak.set_logging_handler","title":"<code>set_logging_handler(show_path=False, show_time=False, show_level=True, keywords=['info', 'warning', 'error', 'critical'], **args)</code>","text":"<p>Sets up the logging handler with the given options.</p> <p>Parameters:</p> Name Type Description Default <code>show_path</code> <code>bool</code> <p>Whether to show the path. Defaults to False.</p> <code>False</code> <code>show_time</code> <code>bool</code> <p>Whether to show the time. Defaults to False.</p> <code>False</code> <code>show_level</code> <code>bool</code> <p>Whether to show the level. Defaults to True.</p> <code>True</code> <code>keywords</code> <code>Dict[str, str]</code> <p>The keywords to highlight. Defaults to [\"info\", \"warning\", \"error\", \"critical\"]</p> <code>['info', 'warning', 'error', 'critical']</code> <code>**args</code> <code>Any</code> <p>Additional Rich handler arguments.</p> <code>{}</code> Source code in <code>cobrak/__init__.py</code> <pre><code>def set_logging_handler(\n    show_path: bool = False,\n    show_time: bool = False,\n    show_level: bool = True,\n    keywords: list[str] = [\n        \"info\",\n        \"warning\",\n        \"error\",\n        \"critical\",\n    ],\n    **args: Any,  # noqa: ANN401\n) -&gt; RichHandler:\n    \"\"\"\n    Sets up the logging handler with the given options.\n\n    Args:\n        show_path (bool, optional): Whether to show the path. Defaults to False.\n        show_time (bool, optional): Whether to show the time. Defaults to False.\n        show_level (bool, optional): Whether to show the level. Defaults to True.\n        keywords (Dict[str, str], optional): The keywords to highlight. Defaults to [\"info\", \"warning\", \"error\", \"critical\"]\n        **args (Any, optional): Additional Rich handler arguments.\n    \"\"\"\n    return RichHandler(\n        show_path=show_path,\n        show_time=show_time,\n        show_level=show_level,\n        keywords=keywords,\n        **args,\n    )\n</code></pre>"},{"location":"api.html#cobrak.set_logging_level","title":"<code>set_logging_level(level)</code>","text":"<p>Sets the logging level.</p> <p>E.g. INFO, ERROR, WARNING and CRITICAL from Python's logging module.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>The logging level.</p> required Source code in <code>cobrak/__init__.py</code> <pre><code>def set_logging_level(level: int) -&gt; None:\n    \"\"\"Sets the logging level.\n\n    E.g. INFO, ERROR, WARNING and CRITICAL from Python's logging module.\n\n    Args:\n        level (int): The logging level.\n    \"\"\"\n    logger.setLevel(level)\n</code></pre>"},{"location":"api.html#cobrak.setup_rich_tracebacks","title":"<code>setup_rich_tracebacks(show_locals)</code>","text":"<p>Sets up rich tracebacks with the given options.</p> <p>Parameters:</p> Name Type Description Default <code>show_locals</code> <code>bool</code> <p>Whether to show local variables in the traceback.</p> required Source code in <code>cobrak/__init__.py</code> <pre><code>def setup_rich_tracebacks(show_locals: bool) -&gt; None:\n    \"\"\"Sets up rich tracebacks with the given options.\n\n    Args:\n        show_locals (bool): Whether to show local variables in the traceback.\n    \"\"\"\n    install(show_locals=show_locals)\n</code></pre>"},{"location":"api.html#cobrak.bigg_metabolites_functionality","title":"<code>bigg_metabolites_functionality</code>","text":"<p>bigg_parse_metabolites_file.py</p> <p>This module contains a function which transforms a BIGG metabolites .txt list into an machine-readable JSON.</p>"},{"location":"api.html#cobrak.bigg_metabolites_functionality.bigg_parse_metabolites_file","title":"<code>bigg_parse_metabolites_file(bigg_metabolites_txt_path, bigg_metabolites_json_path)</code>","text":"<p>Parses a BIGG metabolites text file and returns a dictionary for this file.</p> <p>As of Sep 14 2024, a BIGG metabolites list of all BIGG-included metabolites is retrievable under http://bigg.ucsd.edu/data_access</p>"},{"location":"api.html#cobrak.bigg_metabolites_functionality.bigg_parse_metabolites_file--arguments","title":"Arguments","text":"<ul> <li>bigg_metabolites_file_path: str ~ The file path to the BIGG metabolites file.   The usual file name (which has to be included too in this argument) is   bigg_models_metabolites.txt</li> <li>output_folder: str ~ The folder in which the JSON including the parsed BIGG   metabolites file data is stored with the name 'bigg_id_name_mapping.json'</li> </ul>"},{"location":"api.html#cobrak.bigg_metabolites_functionality.bigg_parse_metabolites_file--output","title":"Output","text":"<ul> <li>A JSON file with the name 'bigg_id_name_mapping.json' in the given output folder,   with the following structure:</li> </ul> <pre>\n {\n     \"$BIGG_ID\": \"$CHEMICAL_OR_USUAL_NAME\",\n     (...),\n     \"$BIGG_ID\": \"$BIGG_ID\",\n     (...),\n }\n</pre> <p>The BIGG ID &lt;-&gt; BIGG ID mapping is done for models which already use the BIGG IDs.</p> Source code in <code>cobrak/bigg_metabolites_functionality.py</code> <pre><code>@validate_call\ndef bigg_parse_metabolites_file(\n    bigg_metabolites_txt_path: str,\n    bigg_metabolites_json_path: str,\n) -&gt; None:\n    \"\"\"Parses a BIGG metabolites text file and returns a dictionary for this file.\n\n    As of Sep 14 2024, a BIGG metabolites list of all BIGG-included metabolites\n    is retrievable under http://bigg.ucsd.edu/data_access\n\n    Arguments\n    ----------\n    * bigg_metabolites_file_path: str ~ The file path to the BIGG metabolites file.\n      The usual file name (which has to be included too in this argument) is\n      bigg_models_metabolites.txt\n    * output_folder: str ~ The folder in which the JSON including the parsed BIGG\n      metabolites file data is stored with the name 'bigg_id_name_mapping.json'\n\n    Output\n    ----------\n    * A JSON file with the name 'bigg_id_name_mapping.json' in the given output folder,\n      with the following structure:\n    &lt;pre&gt;\n     {\n         \"$BIGG_ID\": \"$CHEMICAL_OR_USUAL_NAME\",\n         (...),\n         \"$BIGG_ID\": \"$BIGG_ID\",\n         (...),\n     }\n    &lt;/pre&gt;\n    The BIGG ID &lt;-&gt; BIGG ID mapping is done for models which already use the BIGG IDs.\n    \"\"\"\n    # Open the BIGG metabolites file as string list, and remove all newlines\n    with open(bigg_metabolites_txt_path, encoding=\"utf-8\") as f:\n        lines = f.readlines()\n    lines = [x.replace(\"\\n\", \"\") for x in lines if len(x) &gt; 0]\n\n    # Mapping variable which will store the BIGG ID&lt;-&gt;\n    bigg_id_name_mapping = {}\n    # Go through each BIGG metabolites file line (which is a tab-separated file)\n    # and retrieve the BIGG ID and the name (if there is a name for the given BIGG\n    # ID)\n    for line in lines:\n        bigg_id = line.split(\"\\t\")[1]\n        bigg_id_name_mapping[bigg_id] = bigg_id\n\n        # Exception to check if there is no name :O\n        try:\n            name = line.split(\"\\t\")[2].lower()\n        except Exception:\n            continue\n        bigg_id_name_mapping[name] = bigg_id\n\n        try:\n            database_links = line.split(\"\\t\")[4]\n        except Exception:\n            continue\n        for database_link_part in database_links.split(\": \"):\n            if \"CHEBI:\" not in database_link_part:\n                continue\n            subpart = database_link_part.split(\"CHEBI:\")[1].strip()\n            chebi_id = subpart.split(\"; \")[0] if \"; \" in subpart else subpart\n            bigg_id_name_mapping[chebi_id] = bigg_id\n\n    # Write the JSON in the given folder :D\n    json_write(bigg_metabolites_json_path, bigg_id_name_mapping)\n</code></pre>"},{"location":"api.html#cobrak.brenda_functionality","title":"<code>brenda_functionality</code>","text":"<p>Contains functions which allow one to create a model-specific and BRENDA-depending kinetic data database.</p>"},{"location":"api.html#cobrak.brenda_functionality.brenda_select_enzyme_kinetic_data_for_model","title":"<code>brenda_select_enzyme_kinetic_data_for_model(cobra_model, brenda_json_targz_file_path, bigg_metabolites_json_path, brenda_version, base_species, ncbi_parsed_json_path, kinetic_ignored_metabolites=[], kinetic_ignored_enzyme_ids=[], custom_enzyme_kinetic_data={}, min_ph=-float('inf'), max_ph=float('inf'), accept_nan_ph=True, min_temperature=-float('inf'), max_temperature=float('inf'), accept_nan_temperature=True, kcat_overwrite={}, transfered_ec_number_json='', max_taxonomy_level=1000000000.0)</code>","text":"<p>Select and assign enzyme kinetic data for each reaction in a COBRApy model based on BRENDA database entries and taxonomic similarity.</p> <p>This function retrieves enzyme kinetic data from a compressed BRENDA JSON file, merges it with BiGG metabolite translation data and taxonomy information from NCBI. It then iterates over the reactions in the provided COBRApy model to:</p> <ul> <li>Filter reactions that have EC code annotations.</li> <li>Identify eligible EC codes (ignoring those with hyphens).</li> <li>Collect kinetic entries (e.g., turnover numbers, KM values, KI values) for each metabolite     involved in the reaction.</li> <li>Choose the best kinetic parameters (k_cat, k_ms, k_is) based on taxonomic similarity to     a base species.</li> <li>Apply conversion factors (e.g., s\u207b\u00b9 to h\u207b\u00b9 for k_cat, mM to M for KM and KI).</li> <li>Respect ignore lists for metabolites and enzymes.</li> <li>Override computed k_cat values if provided in the kcat_overwrite dictionary.</li> <li>Merge with any custom enzyme kinetic data provided.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>cobra_model</code> <code>Model</code> <p>A COBRApy model object representing the metabolic network.</p> required <code>brenda_json_targz_file_path</code> <code>str</code> <p>Path to the compressed JSON file containing BRENDA enzyme kinetic data.</p> required <code>bigg_metabolites_json_path</code> <code>str</code> <p>Path to the JSON file mapping metabolite IDs to BiGG identifiers.</p> required <code>brenda_version</code> <code>str</code> <p>String identifier for the BRENDA database version.</p> required <code>base_species</code> <code>str</code> <p>Species identifier used as the reference for taxonomic similarity.</p> required <code>ncbi_parsed_json_path</code> <code>str</code> <p>Path to the parsed JSON file containing NCBI taxonomy data.</p> required <code>kinetic_ignored_metabolites</code> <code>list[str]</code> <p>List of metabolite IDs to exclude from kinetic parameter selection. Defaults to an empty list.</p> <code>[]</code> <code>kinetic_ignored_enzyme_ids</code> <code>list[str]</code> <p>List of enzyme identifiers to ignore when considering a reaction. Defaults to an empty list.</p> <code>[]</code> <code>custom_enzyme_kinetic_data</code> <code>dict[str, EnzymeReactionData | None]</code> <p>Dictionary of custom enzyme kinetic data to override or supplement computed data. The keys are reaction IDs and the values are EnzymeReactionData instances or None. Defaults to an empty dictionary.</p> <code>{}</code> <code>min_ph</code> <code>float</code> <p>The minimum pH value for kinetic data inclusion. Defaults to negative infinity.</p> <code>-float('inf')</code> <code>max_ph</code> <code>float</code> <p>The maximum pH value for kinetic data inclusion. Defaults to positive infinity.</p> <code>float('inf')</code> <code>accept_nan_ph</code> <code>bool</code> <p>If True, kinetic entries with NaN pH values are accepted. Defaults to True.</p> <code>True</code> <code>min_temperature</code> <code>float</code> <p>The minimum temperature value (e.g., in Kelvin) for kinetic data inclusion. Defaults to negative infinity.</p> <code>-float('inf')</code> <code>max_temperature</code> <code>float</code> <p>The maximum temperature value for kinetic data inclusion. Defaults to positive infinity.</p> <code>float('inf')</code> <code>accept_nan_temperature</code> <code>bool</code> <p>If True, kinetic entries with NaN temperature values are accepted. Defaults to True.</p> <code>True</code> <code>kcat_overwrite</code> <code>dict[str, float]</code> <p>Dictionary mapping reaction IDs to k_cat values that should override computed values. Defaults to an empty dictionary.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, EnzymeReactionData | None]</code> <p>dict[str, EnzymeReactionData | None]: A dictionary mapping reaction IDs (str) from the COBRApy model to their corresponding EnzymeReactionData instances. If no suitable kinetic data are found (or if the enzyme is in the ignore list), the value will be None for that reaction.</p> Notes <ul> <li>Kinetic values are converted to standardized units:<ul> <li>k_cat values are converted from s\u207b\u00b9 to h\u207b\u00b9.</li> <li>KM and KI values are converted from mM to M.</li> </ul> </li> <li>The function leverages taxonomic similarity (using NCBI TAXONOMY data)   to select the most relevant kinetic values.</li> <li>Custom enzyme kinetic data and k_cat overrides will replace any computed values.</li> </ul> Source code in <code>cobrak/brenda_functionality.py</code> <pre><code>@validate_call(config=ConfigDict(arbitrary_types_allowed=True))\ndef brenda_select_enzyme_kinetic_data_for_model(\n    cobra_model: cobra.Model,\n    brenda_json_targz_file_path: str,\n    bigg_metabolites_json_path: str,\n    brenda_version: str,\n    base_species: str,\n    ncbi_parsed_json_path: str,\n    kinetic_ignored_metabolites: list[str] = [],\n    kinetic_ignored_enzyme_ids: list[str] = [],\n    custom_enzyme_kinetic_data: dict[str, EnzymeReactionData | None] = {},\n    min_ph: float = -float(\"inf\"),\n    max_ph: float = float(\"inf\"),\n    accept_nan_ph: bool = True,\n    min_temperature: float = -float(\"inf\"),\n    max_temperature: float = float(\"inf\"),\n    accept_nan_temperature: bool = True,\n    kcat_overwrite: dict[str, float] = {},\n    transfered_ec_number_json: str = \"\",\n    max_taxonomy_level: NonNegativeInt = 1e9,\n) -&gt; dict[str, EnzymeReactionData | None]:\n    \"\"\"Select and assign enzyme kinetic data for each reaction in a COBRApy model based on BRENDA\n    database entries and taxonomic similarity.\n\n    This function retrieves enzyme kinetic data from a compressed BRENDA JSON file, merges it\n    with BiGG metabolite translation data and taxonomy information from NCBI. It then iterates\n    over the reactions in the provided COBRApy model to:\n\n      - Filter reactions that have EC code annotations.\n      - Identify eligible EC codes (ignoring those with hyphens).\n      - Collect kinetic entries (e.g., turnover numbers, KM values, KI values) for each metabolite\n        involved in the reaction.\n      - Choose the best kinetic parameters (k_cat, k_ms, k_is) based on taxonomic similarity to\n        a base species.\n      - Apply conversion factors (e.g., s\u207b\u00b9 to h\u207b\u00b9 for k_cat, mM to M for KM and KI).\n      - Respect ignore lists for metabolites and enzymes.\n      - Override computed k_cat values if provided in the kcat_overwrite dictionary.\n      - Merge with any custom enzyme kinetic data provided.\n\n    Parameters:\n        cobra_model (cobra.Model): A COBRApy model object representing the metabolic network.\n        brenda_json_targz_file_path (str): Path to the compressed JSON file containing\n            BRENDA enzyme kinetic data.\n        bigg_metabolites_json_path (str): Path to the JSON file mapping metabolite IDs to\n            BiGG identifiers.\n        brenda_version (str): String identifier for the BRENDA database version.\n        base_species (str): Species identifier used as the reference for taxonomic similarity.\n        ncbi_parsed_json_path (str): Path to the parsed JSON file containing NCBI taxonomy data.\n        kinetic_ignored_metabolites (list[str], optional): List of metabolite IDs to exclude\n            from kinetic parameter selection. Defaults to an empty list.\n        kinetic_ignored_enzyme_ids (list[str], optional): List of enzyme identifiers to ignore\n            when considering a reaction. Defaults to an empty list.\n        custom_enzyme_kinetic_data (dict[str, EnzymeReactionData | None], optional):\n            Dictionary of custom enzyme kinetic data to override or supplement computed data.\n            The keys are reaction IDs and the values are EnzymeReactionData instances or None.\n            Defaults to an empty dictionary.\n        min_ph (float, optional): The minimum pH value for kinetic data inclusion. Defaults\n            to negative infinity.\n        max_ph (float, optional): The maximum pH value for kinetic data inclusion. Defaults\n            to positive infinity.\n        accept_nan_ph (bool, optional): If True, kinetic entries with NaN pH values are accepted.\n            Defaults to True.\n        min_temperature (float, optional): The minimum temperature value (e.g., in Kelvin) for\n            kinetic data inclusion. Defaults to negative infinity.\n        max_temperature (float, optional): The maximum temperature value for kinetic data inclusion.\n            Defaults to positive infinity.\n        accept_nan_temperature (bool, optional): If True, kinetic entries with NaN temperature values\n            are accepted. Defaults to True.\n        kcat_overwrite (dict[str, float], optional): Dictionary mapping reaction IDs to k_cat values\n            that should override computed values. Defaults to an empty dictionary.\n\n    Returns:\n        dict[str, EnzymeReactionData | None]:\n            A dictionary mapping reaction IDs (str) from the COBRApy model to their corresponding\n            EnzymeReactionData instances. If no suitable kinetic data are found (or if the enzyme\n            is in the ignore list), the value will be None for that reaction.\n\n    Notes:\n        - Kinetic values are converted to standardized units:\n            - k_cat values are converted from s\u207b\u00b9 to h\u207b\u00b9.\n            - KM and KI values are converted from mM to M.\n        - The function leverages taxonomic similarity (using NCBI TAXONOMY data)\n          to select the most relevant kinetic values.\n        - Custom enzyme kinetic data and k_cat overrides will replace any computed values.\n    \"\"\"\n    transfered_ec_codes: dict[str, str] = (\n        json_load(transfered_ec_number_json, dict[str, str])\n        if transfered_ec_number_json\n        else {}\n    )\n    brenda_database_for_model = _brenda_get_all_enzyme_kinetic_data_for_model(\n        cobra_model,\n        brenda_json_targz_file_path,\n        bigg_metabolites_json_path,\n        brenda_version,\n        min_ph,\n        max_ph,\n        accept_nan_ph,\n        min_temperature,\n        max_temperature,\n        accept_nan_temperature,\n        transfered_ec_codes=transfered_ec_codes,\n    )\n    ncbi_parsed_json_data = json_zip_load(ncbi_parsed_json_path)\n\n    bigg_metabolites_data: dict[str, str] = json_load(\n        bigg_metabolites_json_path,\n        dict[str, str],\n    )\n\n    # Get reaction&lt;-&gt;enzyme reaction data mapping\n    enzyme_reaction_data: dict[str, EnzymeReactionData | None] = {}\n    for reaction in cobra_model.reactions:\n        if \"ec-code\" not in reaction.annotation:\n            continue\n\n        substrate_names_and_ids = []\n        for metabolite, stoichiometry in reaction.metabolites.items():\n            if stoichiometry &lt; 0:\n                substrate_names_and_ids.extend((metabolite.id, metabolite.name.lower()))\n                for checked_string in (metabolite.id, metabolite.name.lower()):\n                    bigg_id = _search_metname_in_bigg_ids(\n                        checked_string,\n                        bigg_id=\"\",\n                        entry=None,\n                        name_to_bigg_id_dict=bigg_metabolites_data,\n                    )\n                    if bigg_id:\n                        substrate_names_and_ids.append(bigg_id)\n        substrate_names_and_ids_set = set(substrate_names_and_ids)\n\n        reaction_ec_codes = reaction.annotation[\"ec-code\"]\n        if isinstance(reaction_ec_codes, str):\n            reaction_ec_codes = [reaction_ec_codes]\n        eligible_reaction_ec_codes = [\n            ec_code\n            for ec_code in reaction_ec_codes\n            if (ec_code in brenda_database_for_model) and (\"-\" not in ec_code)\n        ]\n\n        reaction_transfered_ec_codes = []\n        for ec_code in eligible_reaction_ec_codes:\n            if ec_code in transfered_ec_codes:\n                single_transfered_ec_code = transfered_ec_codes[ec_code]\n                if single_transfered_ec_code in brenda_database_for_model:\n                    reaction_transfered_ec_codes.append(single_transfered_ec_code)\n        eligible_reaction_ec_codes += reaction_transfered_ec_codes\n\n        metabolite_entries: dict[str, dict[str, Any]] = {}\n        for ec_code in eligible_reaction_ec_codes:\n            ec_code_entry = brenda_database_for_model[ec_code]\n            for met_id in ec_code_entry:\n                if met_id == \"WILDCARD\":\n                    continue\n                if met_id not in metabolite_entries:\n                    metabolite_entries[met_id] = {}\n                for organism in ec_code_entry[met_id]:\n                    if organism not in metabolite_entries[met_id]:\n                        metabolite_entries[met_id][organism] = []\n                    metabolite_entries[met_id][organism] += ec_code_entry[met_id][\n                        organism\n                    ]\n\n        # Choose kcats and kms taxonomically\n        best_kcat_taxonomy_level = float(\"inf\")\n        best_km_taxonomy_levels = {\n            metabolite.id: float(\"inf\") for metabolite in cobra_model.metabolites\n        }\n        best_ki_taxonomy_levels = {\n            metabolite.id: float(\"inf\") for metabolite in cobra_model.metabolites\n        }\n        taxonomically_best_kcats: list[float] = []\n        taxonomically_best_kms: dict[str, list[float]] = {}\n        taxonomically_best_kis: dict[str, list[float]] = {}\n        k_cat_references: list[ParameterReference] = []\n        k_m_references: dict[str, list[ParameterReference]] = {}\n        k_i_references: dict[str, list[ParameterReference]] = {}\n        for metabolite in cobra_model.metabolites:\n            idx_last_underscore = metabolite.id.rfind(\"_\")\n            met_id = metabolite.id[:idx_last_underscore]\n            if metabolite.id in kinetic_ignored_metabolites:\n                continue\n            if met_id not in metabolite_entries:\n                continue\n            organisms = list(metabolite_entries[met_id].keys())\n            if base_species not in organisms:\n                organisms.append(base_species)\n            taxonomy_dict = get_taxonomy_dict_from_nbci_taxonomy(\n                organisms, ncbi_parsed_json_data\n            )\n            taxonomy_similarities = most_taxonomic_similar(base_species, taxonomy_dict)\n            highest_taxonomy_level = max(taxonomy_similarities.values())\n            for taxonomy_level in range(highest_taxonomy_level + 1):\n                if taxonomy_level &gt; max_taxonomy_level:\n                    continue\n\n                level_organisms = [\n                    organism\n                    for organism in organisms\n                    if taxonomy_similarities[organism] == taxonomy_level\n                ]\n                for level_organism in level_organisms:\n                    if (level_organism not in metabolite_entries[met_id]) and (\n                        level_organism == base_species\n                    ):  # I.e., if it is the base species\n                        continue\n                    kinetic_entries = metabolite_entries[met_id][level_organism]\n                    if taxonomy_level &lt;= best_kcat_taxonomy_level:\n                        kcat_entries = [\n                            km_kcat_entry\n                            for km_kcat_entry in kinetic_entries\n                            if (km_kcat_entry[0] == \"turnover_number\")\n                            and not (\n                                substrate_names_and_ids_set.isdisjoint(km_kcat_entry[5])\n                            )\n                        ]\n\n                        if len(kcat_entries) &gt; 0:\n                            if (\n                                best_kcat_taxonomy_level &gt; taxonomy_level\n                            ):  # \"Erase\" if we find a better level\n                                taxonomically_best_kcats = []\n                            best_kcat_taxonomy_level = min(\n                                taxonomy_level, best_kcat_taxonomy_level\n                            )\n                            if taxonomy_level &lt;= best_kcat_taxonomy_level:\n                                for kcat_entry in kcat_entries:\n                                    taxonomically_best_kcats.append(\n                                        kcat_entry[1] * 3_600\n                                    )  # convert from s\u207b\u00b9 to h\u207b\u00b9\n                                    k_cat_references.append(\n                                        ParameterReference(\n                                            database=\"BRENDA\",\n                                            comment=kcat_entry[3],\n                                            species=level_organism,\n                                            pubs=kcat_entry[2],\n                                            substrate=kcat_entry[4],\n                                            tax_distance=taxonomy_level,\n                                            value=kcat_entry[1] * 3_600,\n                                        )\n                                    )\n\n                    if taxonomy_level &lt;= best_km_taxonomy_levels[metabolite.id]:\n                        km_entries = [\n                            km_kcat_entry\n                            for km_kcat_entry in kinetic_entries\n                            if km_kcat_entry[0] == \"km_value\"\n                            and not (\n                                substrate_names_and_ids_set.isdisjoint(km_kcat_entry[5])\n                            )\n                        ]\n                        if len(km_entries) &gt; 0:\n                            if metabolite.id not in taxonomically_best_kms:\n                                taxonomically_best_kms[metabolite.id] = []\n                                k_m_references[metabolite.id] = []\n                            if (\n                                best_km_taxonomy_levels[metabolite.id] &gt; taxonomy_level\n                            ):  # \"Erase\" if we find a better level\n                                taxonomically_best_kms[metabolite.id] = []\n                            best_km_taxonomy_levels[metabolite.id] = min(\n                                taxonomy_level, best_km_taxonomy_levels[metabolite.id]\n                            )\n                            if taxonomy_level &lt;= best_km_taxonomy_levels[metabolite.id]:\n                                for km_entry in km_entries:\n                                    taxonomically_best_kms[metabolite.id].append(\n                                        km_entry[1] / 1_000\n                                    )  # convert from mM to M\n                                    k_m_references[metabolite.id].append(\n                                        ParameterReference(\n                                            database=\"BRENDA\",\n                                            comment=km_entry[3],\n                                            species=level_organism,\n                                            pubs=km_entry[2],\n                                            substrate=km_entry[4],\n                                            tax_distance=taxonomy_level,\n                                            value=km_entry[1] / 1_000,\n                                        )\n                                    )\n\n                    if taxonomy_level &lt;= best_ki_taxonomy_levels[metabolite.id]:\n                        ki_entries = [\n                            kinetic_entry\n                            for kinetic_entry in kinetic_entries\n                            if kinetic_entry[0] == \"ki_value\"\n                            and not (\n                                substrate_names_and_ids_set.isdisjoint(kinetic_entry[5])\n                            )\n                        ]\n                        if len(ki_entries) &gt; 0:\n                            if metabolite.id not in taxonomically_best_kis:\n                                taxonomically_best_kis[metabolite.id] = []\n                                k_i_references[metabolite.id] = []\n                            if (\n                                best_ki_taxonomy_levels[metabolite.id] &gt; taxonomy_level\n                            ):  # \"Erase\" if we find a better level\n                                taxonomically_best_kis[metabolite.id] = []\n                            best_ki_taxonomy_levels[metabolite.id] = min(\n                                taxonomy_level, best_ki_taxonomy_levels[metabolite.id]\n                            )\n                            if taxonomy_level &lt;= best_ki_taxonomy_levels[metabolite.id]:\n                                for ki_entry in ki_entries:\n                                    taxonomically_best_kis[metabolite.id].append(\n                                        ki_entry[1] / 1_000\n                                    )  # convert from mM to M\n                                    k_i_references[metabolite.id].append(\n                                        ParameterReference(\n                                            database=\"BRENDA\",\n                                            comment=ki_entry[3],\n                                            species=level_organism,\n                                            pubs=ki_entry[2],\n                                            substrate=ki_entry[4],\n                                            value=ki_entry[1] / 1_000,\n                                            tax_distance=taxonomy_level,\n                                        )\n                                    )\n\n        if reaction.id in kcat_overwrite:\n            taxonomically_best_kcats = [kcat_overwrite[reaction.id]]\n            k_cat_references = [\n                ParameterReference(database=\"OVERWRITE\", tax_distance=-1)\n            ]\n        else:\n            taxonomically_best_kcats = []\n\n        reaction_kms = {}\n        for met_id, values in taxonomically_best_kms.items():\n            if met_id not in [x.id for x in reaction.metabolites]:\n                continue\n            reaction_kms[met_id] = median(values)\n\n        reaction_kis = {}\n        for met_id, values in taxonomically_best_kis.items():\n            if met_id not in taxonomically_best_kis:\n                continue\n            reaction_kis[met_id] = median(taxonomically_best_kis[met_id])\n\n        enzyme_identifiers = reaction.gene_reaction_rule.split(\" and \")\n        has_found_ignored_enzyme = False\n        for enzyme_identifier in enzyme_identifiers:\n            if enzyme_identifier in kinetic_ignored_enzyme_ids:\n                has_found_ignored_enzyme = True\n                break\n\n        if (len(taxonomically_best_kcats) &gt; 0) and (not has_found_ignored_enzyme):\n            reaction_kcat = median(taxonomically_best_kcats)  # or max(), min(), ...\n            enzyme_reaction_data[reaction.id] = EnzymeReactionData(\n                identifiers=enzyme_identifiers,\n                k_cat=reaction_kcat,\n                k_cat_references=k_cat_references,\n                k_ms=reaction_kms,\n                k_m_references=k_m_references,\n                k_is=reaction_kis,\n                k_i_references=k_i_references,\n            )\n        else:\n            enzyme_reaction_data[reaction.id] = None\n\n    enzyme_reaction_data = {**enzyme_reaction_data, **custom_enzyme_kinetic_data}\n\n    for reac_id in kcat_overwrite:  # noqa: PLC0206\n        if reac_id not in enzyme_reaction_data:\n            reaction = cobra_model.reactions.get_by_id(reac_id)\n            enzyme_identifiers = reaction.gene_reaction_rule.split(\" and \")\n            enzyme_reaction_data[reac_id] = EnzymeReactionData(\n                identifiers=enzyme_identifiers,\n                k_cat=kcat_overwrite[reac_id],\n                k_cat_references=[\n                    ParameterReference(database=\"OVERWRITE\", tax_distance=-1)\n                ],\n                k_ms={},\n                k_is={},\n            )\n    return enzyme_reaction_data\n</code></pre>"},{"location":"api.html#cobrak.cobrapy_model_functionality","title":"<code>cobrapy_model_functionality</code>","text":"<p>Contains methods that directly apply on COBRApy models.</p>"},{"location":"api.html#cobrak.cobrapy_model_functionality.create_irreversible_cobrapy_model_from_stoichiometries","title":"<code>create_irreversible_cobrapy_model_from_stoichiometries(stoichiometries)</code>","text":"<p>Create an irreversible COBRApy model out of the given dictionary.</p> <p>E.g., if the following dict is the argument: {     \"EX_A\": { \"A\": +1 },     \"R1\": { \"A\": -1, \"B\": +1 },     \"EX_B\": { \"B\": -1 }, } ...then, the following three irreversible (i.e, flux from 0 to 1_000) reactions are created and returned as a single COBRApy model: EX_A: -&gt; A R1: A -&gt; B EX_B: B -&gt;</p> <p>Parameters:</p> Name Type Description Default <code>stoichiometries</code> <code>dict[str, dict[str, float]]</code> <p>The model-describing dictionary</p> required <p>Returns:</p> Type Description <code>Model</code> <p>cobra.Model: The resulting COBRApy model with the given reactions and metabolites</p> Source code in <code>cobrak/cobrapy_model_functionality.py</code> <pre><code>@validate_call(config=ConfigDict(arbitrary_types_allowed=True))\ndef create_irreversible_cobrapy_model_from_stoichiometries(\n    stoichiometries: dict[str, dict[str, float]],\n) -&gt; cobra.Model:\n    \"\"\"Create an irreversible COBRApy model out of the given dictionary.\n\n    E.g., if the following dict is the argument:\n    {\n        \"EX_A\": { \"A\": +1 },\n        \"R1\": { \"A\": -1, \"B\": +1 },\n        \"EX_B\": { \"B\": -1 },\n    }\n    ...then, the following three irreversible (i.e, flux from 0 to 1_000) reactions\n    are created and returned as a single COBRApy model:\n    EX_A: -&gt; A\n    R1: A -&gt; B\n    EX_B: B -&gt;\n\n    Args:\n        stoichiometries (dict[str, dict[str, float]]): The model-describing dictionary\n\n    Returns:\n        cobra.Model: The resulting COBRApy model with the given reactions and metabolites\n    \"\"\"\n    cobra_model: cobra.Model = cobra.Model()\n    reac_ids = stoichiometries.keys()\n    metabolite_ids_list = []\n    for stoichiometry_entry in stoichiometries.values():\n        metabolite_ids_list.extend(list(stoichiometry_entry.keys()))\n    metabolite_ids = set(metabolite_ids_list)\n    cobra_model.add_metabolites(\n        [cobra.Metabolite(id=met_id, compartment=\"c\") for met_id in metabolite_ids]\n    )\n    cobra_model.add_reactions(\n        [\n            cobra.Reaction(\n                id=reac_id,\n                name=reac_id,\n                lower_bound=0.0,\n                upper_bound=1000.0,\n            )\n            for reac_id in reac_ids\n        ]\n    )\n    for reac_id in reac_ids:\n        reaction: cobra.Reaction = cobra_model.reactions.get_by_id(reac_id)\n        reaction.add_metabolites(\n            {\n                cobra_model.metabolites.get_by_id(met_id): stoichiometry\n                for met_id, stoichiometry in stoichiometries[reac_id].items()\n            }\n        )\n\n    return cobra_model\n</code></pre>"},{"location":"api.html#cobrak.cobrapy_model_functionality.get_fullsplit_cobra_model","title":"<code>get_fullsplit_cobra_model(cobra_model, fwd_suffix=REAC_FWD_SUFFIX, rev_suffix=REAC_REV_SUFFIX, add_cobrak_sbml_annotation=False, cobrak_default_min_conc=1e-06, cobrak_default_max_conc=0.2, cobrak_extra_linear_constraints=[], cobrak_kinetic_ignored_metabolites=[], cobrak_no_extra_versions=False, reac_lb_ub_cap=float('inf'))</code>","text":"<p>Return a COBRApy model where reactions are split according to reversibility and enzymes.</p> <p>\"Reversibility\" means that, if a reaction i can run in both directions (\u03b1_i&lt;0), then it is split as follows: Ri: A&lt;-&gt;B [-50;100]=&gt; Ri_FWD: A-&gt;B [0;100]; Ri_REV: B-&gt;A [0;50] where the ending \"FWD\" and \"REV\" are set in COBRAk's constants REAC_FWD_SUFFIX and REAC_REV_SUFFIX.</p> <p>\"enzymes\" means that, if a reaction i can be catalyzed by multiple enzymes (i.e., at least one OR block in the reaction's gene-protein rule), then it is split for each reaction. Say, for example, Rj: A-&gt;B [0;100] has the following gene-protein rule: (E1 OR E2) ...then, Rj is split into: Rj_ENZ_E1: A-&gt;B [0;100] Rj_ENZ_E2: A-&gt;B [0;100] where the infix \"ENZ\" is set in COBRAk's constants REAC_ENZ_SEPARATOR.</p> <p>Parameters:</p> Name Type Description Default <code>cobra_model</code> <code>Model</code> <p>The COBRApy model that shall be 'fullsplit'.</p> required <p>Returns:</p> Type Description <code>Model</code> <p>cobra.Model: The 'fullsplit' COBRApy model.</p> Source code in <code>cobrak/cobrapy_model_functionality.py</code> <pre><code>@validate_call(config=ConfigDict(arbitrary_types_allowed=True))\ndef get_fullsplit_cobra_model(\n    cobra_model: cobra.Model,\n    fwd_suffix: str = REAC_FWD_SUFFIX,\n    rev_suffix: str = REAC_REV_SUFFIX,\n    add_cobrak_sbml_annotation: bool = False,\n    cobrak_default_min_conc: float = 1e-6,\n    cobrak_default_max_conc: float = 0.2,\n    cobrak_extra_linear_constraints: list[ExtraLinearConstraint] = [],\n    cobrak_kinetic_ignored_metabolites: list[str] = [],\n    cobrak_no_extra_versions: bool = False,\n    reac_lb_ub_cap: float = float(\"inf\"),\n) -&gt; cobra.Model:\n    \"\"\"Return a COBRApy model where reactions are split according to reversibility and enzymes.\n\n    \"Reversibility\" means that, if a reaction i can run in both directions (\u03b1_i&lt;0), then it is split as follows:\n    Ri: A&lt;-&gt;B [-50;100]=&gt; Ri_FWD: A-&gt;B [0;100]; Ri_REV: B-&gt;A [0;50]\n    where the ending \"FWD\" and \"REV\" are set in COBRAk's constants REAC_FWD_SUFFIX and REAC_REV_SUFFIX.\n\n    \"enzymes\" means that, if a reaction i can be catalyzed by multiple enzymes (i.e., at least one OR block in the\n    reaction's gene-protein rule), then it is split for each reaction. Say, for example,\n    Rj: A-&gt;B [0;100]\n    has the following gene-protein rule:\n    (E1 OR E2)\n    ...then, Rj is split into:\n    Rj_ENZ_E1: A-&gt;B [0;100]\n    Rj_ENZ_E2: A-&gt;B [0;100]\n    where the infix \"_ENZ_\" is set in COBRAk's constants REAC_ENZ_SEPARATOR.\n\n    Args:\n        cobra_model (cobra.Model): The COBRApy model that shall be 'fullsplit'.\n\n    Returns:\n        cobra.Model: The 'fullsplit' COBRApy model.\n    \"\"\"\n    fullsplit_cobra_model = cobra.Model(cobra_model.id)\n\n    if add_cobrak_sbml_annotation:\n        settings_reac = cobra.Reaction(\n            id=\"cobrak_global_settings\",\n            name=\"Global COBRA-k settings\",\n            lower_bound=0.0,\n            upper_bound=0.0,\n        )\n        settings_reac.annotation[\"cobrak_max_prot_pool\"] = 1000.0\n        settings_reac.annotation[\"cobrak_R\"] = STANDARD_R\n        settings_reac.annotation[\"cobrak_T\"] = STANDARD_T\n        settings_reac.annotation[\"cobrak_kinetic_ignored_metabolites\"] = {}\n        settings_reac.annotation[\"cobrak_reac_rev_suffix\"] = (\n            rev_suffix  # A \"special\" suffix to show that this is added\n        )\n        settings_reac.annotation[\"cobrak_reac_fwd_suffix\"] = fwd_suffix\n        settings_reac.annotation[\"cobrak_reac_enz_separator\"] = REAC_ENZ_SEPARATOR\n        settings_reac.annotation[\"cobrak_extra_linear_constraints\"] = str(\n            [asdict(x) for x in cobrak_extra_linear_constraints]\n        )\n        settings_reac.annotation[\"cobrak_kinetic_ignored_metabolites\"] = str(\n            cobrak_kinetic_ignored_metabolites\n        )\n\n        fullsplit_cobra_model.add_reactions([settings_reac])\n\n    fullsplit_cobra_model.add_metabolites(cobra_model.metabolites)\n\n    for gene in cobra_model.genes:\n        fullsplit_cobra_model.genes.add(deepcopy(gene))\n\n    for reaction_x in cobra_model.reactions:\n        reaction: cobra.Reaction = reaction_x\n\n        if add_cobrak_sbml_annotation:\n            for old_name, new_name in (\n                (\"dG0\", \"cobrak_dG0\"),\n                (\"dG0_uncertainty\", \"cobrak_dG0_uncertainty\"),\n            ):\n                if old_name in reaction.annotation:\n                    reaction.annotation[new_name] = reaction.annotation[old_name]\n\n            fwd_dG0 = (\n                float(reaction.annotation[\"cobrak_dG0\"])\n                if \"cobrak_dG0\" in reaction.annotation\n                else None\n            )\n            dG0_uncertainty = (\n                abs(float(reaction.annotation[\"cobrak_dG0_uncertainty\"]))\n                if \"cobrak_dG0_uncertainty\" in reaction.annotation\n                else None\n            )\n\n        is_reversible = False\n        if reaction.lower_bound &lt; 0.0:\n            is_reversible = True\n\n        single_enzyme_blocks = (\n            reaction.gene_reaction_rule.replace(\"(\", \"\").replace(\")\", \"\").split(\" or \")\n        )\n        current_reac_version = 0\n        for single_enzyme_block in single_enzyme_blocks:\n            if single_enzyme_block:\n                new_reac_base_id = (\n                    reaction.id\n                    + REAC_ENZ_SEPARATOR\n                    + single_enzyme_block.replace(\" \", \"_\")\n                )\n            else:\n                new_reac_base_id = reaction.id\n            new_reaction_1 = cobra.Reaction(\n                id=new_reac_base_id,\n                lower_bound=reaction.lower_bound,\n                upper_bound=min(reac_lb_ub_cap, reaction.upper_bound),\n            )\n            new_reaction_1.annotation = deepcopy(reaction.annotation)\n            if add_cobrak_sbml_annotation:\n                if fwd_dG0 is not None:\n                    new_reaction_1.annotation[f\"cobrak_dG0_V{current_reac_version}\"] = (\n                        fwd_dG0\n                    )\n                if dG0_uncertainty is not None:\n                    new_reaction_1.annotation[\n                        f\"cobrak_dG0_uncertainty_V{current_reac_version}\"\n                    ] = dG0_uncertainty\n                new_reaction_1.annotation[f\"cobrak_id_V{current_reac_version}\"] = (\n                    new_reaction_1.id + (fwd_suffix if is_reversible else \"\")\n                )\n            if single_enzyme_block:\n                new_reaction_1.gene_reaction_rule = single_enzyme_block\n            new_reaction_1_met_addition = {}\n            for met, stoichiometry in reaction.metabolites.items():\n                new_reaction_1_met_addition[met] = stoichiometry\n            new_reaction_1.add_metabolites(new_reaction_1_met_addition)\n\n            if is_reversible:\n                current_reac_version += 1\n\n                original_lb = new_reaction_1.lower_bound\n                new_reaction_2 = cobra.Reaction(\n                    id=new_reac_base_id,\n                )\n                new_reaction_2.annotation = deepcopy(reaction.annotation)\n                if add_cobrak_sbml_annotation:\n                    if fwd_dG0 is not None:\n                        new_reaction_2.annotation[\n                            f\"cobrak_dG0_V{current_reac_version}\"\n                        ] = -fwd_dG0\n                    if dG0_uncertainty is not None:\n                        new_reaction_2.annotation[\n                            f\"cobrak_dG0_uncertainty_V{current_reac_version}\"\n                        ] = dG0_uncertainty\n                    new_reaction_2.annotation[f\"cobrak_id_V{current_reac_version}\"] = (\n                        new_reaction_2.id + rev_suffix\n                    )\n                if single_enzyme_block:\n                    new_reaction_2.gene_reaction_rule = single_enzyme_block\n                new_reaction_1.id += fwd_suffix\n                new_reaction_1.lower_bound = 0\n                new_reaction_2.id += rev_suffix\n                new_reaction_2.lower_bound = 0\n                new_reaction_2.upper_bound = min(reac_lb_ub_cap, abs(original_lb))\n\n                new_reaction_2_met_addition = {}\n                for met, stoichiometry in new_reaction_1.metabolites.items():\n                    new_reaction_2_met_addition[met] = -stoichiometry\n                new_reaction_2.add_metabolites(new_reaction_2_met_addition)\n\n                fullsplit_cobra_model.add_reactions([new_reaction_2])\n            fullsplit_cobra_model.add_reactions([new_reaction_1])\n            current_reac_version += 1\n            if cobrak_no_extra_versions and (\n                (\"cobrak_k_cat_V0\" not in reaction.annotation)\n                or (\"cobrak_k_cat\" not in reaction.annotation)\n            ):\n                break\n\n    for metabolite in fullsplit_cobra_model.metabolites:\n        for old_name, new_name in ((\"Cmin\", \"cobrak_Cmin\"), (\"Cmax\", \"cobrak_Cmax\")):\n            if old_name in metabolite.annotation:\n                metabolite.annotation[new_name] = metabolite.annotation[old_name]\n        if \"cobrak_Cmin\" not in metabolite.annotation:\n            metabolite.annotation[\"cobrak_Cmin\"] = cobrak_default_min_conc\n        if \"cobrak_Cmax\" not in metabolite.annotation:\n            metabolite.annotation[\"cobrak_Cmax\"] = cobrak_default_max_conc\n\n    return fullsplit_cobra_model\n</code></pre>"},{"location":"api.html#cobrak.cobrapy_model_functionality.get_fullsplit_cobra_model_from_sbml","title":"<code>get_fullsplit_cobra_model_from_sbml(sbml_path, fwd_suffix=REAC_FWD_SUFFIX, rev_suffix=REAC_REV_SUFFIX, add_cobrak_sbml_annotation=False, cobrak_default_min_conc=1e-06, cobrak_default_max_conc=0.2, cobrak_extra_linear_constraints=[], cobrak_kinetic_ignored_metabolites=[], cobrak_no_extra_versions=False, reac_lb_ub_cap=float('inf'))</code>","text":"<p>Return a COBRApy model (loaded from the SBML) where reactions are split according to reversibility and enzymes.</p> <p>\"Reversibility\" means that, if a reaction i can run in both directions (\u03b1_i&lt;0), then it is split as follows: Ri: A&lt;-&gt;B [-50;100]=&gt; Ri_FWD: A-&gt;B [0;100]; Ri_REV: B-&gt;A [0;50] where the ending \"FWD\" and \"REV\" are set in COBRAk's constants REAC_FWD_SUFFIX and REAC_REV_SUFFIX.</p> <p>\"enzymes\" means that, if a reaction i can be catalyzed by multiple enzymes (i.e., at least one OR block in the reaction's gene-protein rule), then it is split for each reaction. Say, for example, Rj: A-&gt;B [0;100] has the following gene-protein rule: (E1 OR E2) ...then, Rj is split into: Rj_ENZ_E1: A-&gt;B [0;100] Rj_ENZ_E2: A-&gt;B [0;100] where the infix \"ENZ\" is set in COBRAk's constants REAC_ENZ_SEPARATOR.</p> <p>Parameters:</p> Name Type Description Default <code>cobra_model</code> <code>Model</code> <p>The COBRApy model that shall be 'fullsplit'.</p> required <p>Returns:</p> Type Description <code>Model</code> <p>cobra.Model: The 'fullsplit' COBRApy model.</p> Source code in <code>cobrak/cobrapy_model_functionality.py</code> <pre><code>@validate_call(config=ConfigDict(arbitrary_types_allowed=True))\ndef get_fullsplit_cobra_model_from_sbml(\n    sbml_path: str,\n    fwd_suffix: str = REAC_FWD_SUFFIX,\n    rev_suffix: str = REAC_REV_SUFFIX,\n    add_cobrak_sbml_annotation: bool = False,\n    cobrak_default_min_conc: float = 1e-6,\n    cobrak_default_max_conc: float = 0.2,\n    cobrak_extra_linear_constraints: list[ExtraLinearConstraint] = [],\n    cobrak_kinetic_ignored_metabolites: list[str] = [],\n    cobrak_no_extra_versions: bool = False,\n    reac_lb_ub_cap: float = float(\"inf\"),\n) -&gt; cobra.Model:\n    \"\"\"Return a COBRApy model (loaded from the SBML) where reactions are split according to reversibility and enzymes.\n\n    \"Reversibility\" means that, if a reaction i can run in both directions (\u03b1_i&lt;0), then it is split as follows:\n    Ri: A&lt;-&gt;B [-50;100]=&gt; Ri_FWD: A-&gt;B [0;100]; Ri_REV: B-&gt;A [0;50]\n    where the ending \"FWD\" and \"REV\" are set in COBRAk's constants REAC_FWD_SUFFIX and REAC_REV_SUFFIX.\n\n    \"enzymes\" means that, if a reaction i can be catalyzed by multiple enzymes (i.e., at least one OR block in the\n    reaction's gene-protein rule), then it is split for each reaction. Say, for example,\n    Rj: A-&gt;B [0;100]\n    has the following gene-protein rule:\n    (E1 OR E2)\n    ...then, Rj is split into:\n    Rj_ENZ_E1: A-&gt;B [0;100]\n    Rj_ENZ_E2: A-&gt;B [0;100]\n    where the infix \"_ENZ_\" is set in COBRAk's constants REAC_ENZ_SEPARATOR.\n\n    Args:\n        cobra_model (cobra.Model): The COBRApy model that shall be 'fullsplit'.\n\n    Returns:\n        cobra.Model: The 'fullsplit' COBRApy model.\n    \"\"\"\n    return get_fullsplit_cobra_model(\n        cobra.io.read_sbml_model(sbml_path),\n        fwd_suffix=fwd_suffix,\n        rev_suffix=rev_suffix,\n        add_cobrak_sbml_annotation=add_cobrak_sbml_annotation,\n        cobrak_default_min_conc=cobrak_default_min_conc,\n        cobrak_default_max_conc=cobrak_default_max_conc,\n        cobrak_extra_linear_constraints=cobrak_extra_linear_constraints,\n        cobrak_kinetic_ignored_metabolites=cobrak_kinetic_ignored_metabolites,\n        cobrak_no_extra_versions=cobrak_no_extra_versions,\n        reac_lb_ub_cap=reac_lb_ub_cap,\n    )\n</code></pre>"},{"location":"api.html#cobrak.constants","title":"<code>constants</code>","text":"<p>This module contains all COBRAk constants that are used throughout its packages.</p> <p>These constants are especially used for problem constructions (to determine prefixes, suffixes, names, ... for pyomo variables) as well as thermodynamic standard values.</p>"},{"location":"api.html#cobrak.constants.ALL_OK_KEY","title":"<code>ALL_OK_KEY = 'ALL_OK'</code>  <code>module-attribute</code>","text":"<p>Shows that the result is optimal and the termination condition is ok</p>"},{"location":"api.html#cobrak.constants.ALPHA_VAR_PREFIX","title":"<code>ALPHA_VAR_PREFIX = 'alpha_var_'</code>  <code>module-attribute</code>","text":"<p>Prefix for variables representing the activation of a reaction (used in non-linear programs)</p>"},{"location":"api.html#cobrak.constants.BIG_M","title":"<code>BIG_M = 10000</code>  <code>module-attribute</code>","text":"<p>Big M value for MILPs</p>"},{"location":"api.html#cobrak.constants.DF_VAR_PREFIX","title":"<code>DF_VAR_PREFIX = 'f_var_'</code>  <code>module-attribute</code>","text":"<p>Prefix for driving force problem variables</p>"},{"location":"api.html#cobrak.constants.DG0_VAR_PREFIX","title":"<code>DG0_VAR_PREFIX = 'dG0_'</code>  <code>module-attribute</code>","text":"<p>Prefix for Gibb's free energy problem variables</p>"},{"location":"api.html#cobrak.constants.EC_INNER_TO_OUTER_COMPARTMENTS","title":"<code>EC_INNER_TO_OUTER_COMPARTMENTS = ['c', 'p', 'e']</code>  <code>module-attribute</code>","text":"<p>Inner to outer compartments in this order for E. coli models used here</p>"},{"location":"api.html#cobrak.constants.EC_IONIC_STRENGTHS","title":"<code>EC_IONIC_STRENGTHS = {'c': 250, 'p': 250, 'e': 250}</code>  <code>module-attribute</code>","text":"<p>Ionic strenghts (in mM) for E. coli model compartments used here</p>"},{"location":"api.html#cobrak.constants.EC_PHS","title":"<code>EC_PHS = {'c': 7.5, 'p': 7.5, 'e': 7.5}</code>  <code>module-attribute</code>","text":"<p>pH values (unitless) for E. coli model compartments used here</p>"},{"location":"api.html#cobrak.constants.EC_PMGS","title":"<code>EC_PMGS = {'c': 2.5, 'p': 2.5, 'e': 2.5}</code>  <code>module-attribute</code>","text":"<p>pMg values (unitless) for E. coli model compartments used here</p>"},{"location":"api.html#cobrak.constants.EC_POTENTIAL_DIFFERENCES","title":"<code>EC_POTENTIAL_DIFFERENCES = {('c', 'p'): 0.15, ('p', 'e'): 0.15}</code>  <code>module-attribute</code>","text":"<p>Potential differences (in V) for E. coli model compartments used here</p>"},{"location":"api.html#cobrak.constants.ENZYME_VAR_INFIX","title":"<code>ENZYME_VAR_INFIX = '_of_'</code>  <code>module-attribute</code>","text":"<p>Infix for separation of enzyme name and reaction name</p>"},{"location":"api.html#cobrak.constants.ENZYME_VAR_PREFIX","title":"<code>ENZYME_VAR_PREFIX = 'enzyme_'</code>  <code>module-attribute</code>","text":"<p>Prefix of problem variables which stand for enzyme concentrations</p>"},{"location":"api.html#cobrak.constants.ERROR_BOUND_LOWER_CHANGE_PREFIX","title":"<code>ERROR_BOUND_LOWER_CHANGE_PREFIX = 'bound_error_change_lower_'</code>  <code>module-attribute</code>","text":"<p>Prefix for fixed variables that show how much affected lower variable bounds have to be changed</p>"},{"location":"api.html#cobrak.constants.ERROR_BOUND_UPPER_CHANGE_PREFIX","title":"<code>ERROR_BOUND_UPPER_CHANGE_PREFIX = 'bound_error_change_upper_'</code>  <code>module-attribute</code>","text":"<p>Prefix for fixed variables that show how much affected lower variable bounds have to be changed</p>"},{"location":"api.html#cobrak.constants.ERROR_CONSTRAINT_PREFIX","title":"<code>ERROR_CONSTRAINT_PREFIX = 'flux_error_'</code>  <code>module-attribute</code>","text":"<p>Prefix for the constraint that defines a scenario flux constraint</p>"},{"location":"api.html#cobrak.constants.ERROR_SUM_VAR_ID","title":"<code>ERROR_SUM_VAR_ID = 'error_sum'</code>  <code>module-attribute</code>","text":"<p>Name for the variable that holds the sum of all error term variables</p>"},{"location":"api.html#cobrak.constants.ERROR_VAR_PREFIX","title":"<code>ERROR_VAR_PREFIX = 'error_'</code>  <code>module-attribute</code>","text":"<p>Prefix for error term variables for feasibility-making optimizations</p>"},{"location":"api.html#cobrak.constants.FLUX_SUM_VAR_ID","title":"<code>FLUX_SUM_VAR_ID = 'FLUX_SUM_VAR'</code>  <code>module-attribute</code>","text":"<p>Name of optional variable that holds the sum of all reaction fluxes</p>"},{"location":"api.html#cobrak.constants.GAMMA_VAR_PREFIX","title":"<code>GAMMA_VAR_PREFIX = 'gamma_var_'</code>  <code>module-attribute</code>","text":"<p>Prefix for variables representing the thermodynamic restriction of a reaction (used in non-linear programs)</p>"},{"location":"api.html#cobrak.constants.IOTA_VAR_PREFIX","title":"<code>IOTA_VAR_PREFIX = 'iota_var_'</code>  <code>module-attribute</code>","text":"<p>Prefix for variables representing the inhibition of a reaction (used in non-linear programs)</p>"},{"location":"api.html#cobrak.constants.KAPPA_PRODUCTS_VAR_PREFIX","title":"<code>KAPPA_PRODUCTS_VAR_PREFIX = 'kappa_products_'</code>  <code>module-attribute</code>","text":"<p>Prefix for variables representing the sum of logairthmized product concentration minus the logarithmized sum of km values</p>"},{"location":"api.html#cobrak.constants.KAPPA_SUBSTRATES_VAR_PREFIX","title":"<code>KAPPA_SUBSTRATES_VAR_PREFIX = 'kappa_substrates_'</code>  <code>module-attribute</code>","text":"<p>Prefix for variables representing the sum of logairthmized substrate concentration minus the logarithmized sum of km values</p>"},{"location":"api.html#cobrak.constants.KAPPA_VAR_PREFIX","title":"<code>KAPPA_VAR_PREFIX = 'kappa_var_'</code>  <code>module-attribute</code>","text":"<p>Prefix for variables representing the thermodynamic restriction of a reaction (used in non-linear programs)</p>"},{"location":"api.html#cobrak.constants.LNCONC_VAR_PREFIX","title":"<code>LNCONC_VAR_PREFIX = 'x_'</code>  <code>module-attribute</code>","text":"<p>Prefix for logarithmized concentration problem variables</p>"},{"location":"api.html#cobrak.constants.MDF_VAR_ID","title":"<code>MDF_VAR_ID = 'var_B'</code>  <code>module-attribute</code>","text":"<p>Name for minimally occuring driving force variable</p>"},{"location":"api.html#cobrak.constants.OBJECTIVE_CONSTRAINT_NAME","title":"<code>OBJECTIVE_CONSTRAINT_NAME = 'objective_constraint'</code>  <code>module-attribute</code>","text":"<p>Name for constraint that defines the objective function's term</p>"},{"location":"api.html#cobrak.constants.OBJECTIVE_VAR_NAME","title":"<code>OBJECTIVE_VAR_NAME = 'OBJECTIVE_VAR'</code>  <code>module-attribute</code>","text":"<p>Name for variable that holds the objective value</p>"},{"location":"api.html#cobrak.constants.PROT_POOL_MET_NAME","title":"<code>PROT_POOL_MET_NAME = 'prot_pool'</code>  <code>module-attribute</code>","text":"<p>Identifier of the protein pool representing pseudo-metabolite</p>"},{"location":"api.html#cobrak.constants.PROT_POOL_REAC_NAME","title":"<code>PROT_POOL_REAC_NAME = PROT_POOL_MET_NAME + '_delivery'</code>  <code>module-attribute</code>","text":"<p>Identifier of the pseudo-reaction which created the protein pool pseudo-metabolite</p>"},{"location":"api.html#cobrak.constants.QUASI_INF","title":"<code>QUASI_INF = 100000</code>  <code>module-attribute</code>","text":"<p>Big number (larger than big M) for values that would reach inf (thereby potentially causing solver problems)</p>"},{"location":"api.html#cobrak.constants.REAC_ENZ_SEPARATOR","title":"<code>REAC_ENZ_SEPARATOR = '_ENZ_'</code>  <code>module-attribute</code>","text":"<p>Separator between enzyme-constrained reaction ID and attached enzyme name</p>"},{"location":"api.html#cobrak.constants.REAC_FWD_SUFFIX","title":"<code>REAC_FWD_SUFFIX = '_FWD'</code>  <code>module-attribute</code>","text":"<p>Standard suffix for reaction IDs that represent forward directions of originally irreversible reactions</p>"},{"location":"api.html#cobrak.constants.REAC_REV_SUFFIX","title":"<code>REAC_REV_SUFFIX = '_REV'</code>  <code>module-attribute</code>","text":"<p>Standard suffix for reaction IDs that represent reverse directions of originally irreversible reactions</p>"},{"location":"api.html#cobrak.constants.SOLVER_STATUS_KEY","title":"<code>SOLVER_STATUS_KEY = 'SOLVER_STATUS'</code>  <code>module-attribute</code>","text":"<p>Solver status optimization dict key</p>"},{"location":"api.html#cobrak.constants.STANDARD_MIN_MDF","title":"<code>STANDARD_MIN_MDF = 0.001</code>  <code>module-attribute</code>","text":"<p>Standard minimally ocurring driving force for active reactions in kJ\u22c5mol\u207b\u00b9</p>"},{"location":"api.html#cobrak.constants.STANDARD_R","title":"<code>STANDARD_R = 0.008314</code>  <code>module-attribute</code>","text":"<p>Standard gas constant in kJ\u22c5K\u207b1\u22c5mol\u207b1 (Attention: Standard value is often given in J\u22c5K\u207b1\u22c5mol\u207b1, but we need in kJ\u22c5K\u207b1\u22c5mol\u207b1)</p>"},{"location":"api.html#cobrak.constants.STANDARD_T","title":"<code>STANDARD_T = 298.15</code>  <code>module-attribute</code>","text":"<p>Standard temperature in Kelvin</p>"},{"location":"api.html#cobrak.constants.TERMINATION_CONDITION_KEY","title":"<code>TERMINATION_CONDITION_KEY = 'TERMINATION_CONDITION'</code>  <code>module-attribute</code>","text":"<p>Solver termination condition key in optimization dict</p>"},{"location":"api.html#cobrak.constants.USED_IDENTIFIERS_FOR_EQUILIBRATOR","title":"<code>USED_IDENTIFIERS_FOR_EQUILIBRATOR = ['inchi', 'inchi_key', 'metanetx.chemical', 'bigg.metabolite', 'kegg.compound', 'chebi', 'sabiork.compound', 'metacyc.compound', 'hmdb', 'swisslipid', 'reactome', 'lipidmaps', 'seed.compound']</code>  <code>module-attribute</code>","text":"<p>Standard bunch of reaction identifier annotation names for E. coli models used here</p>"},{"location":"api.html#cobrak.constants.ZB_VAR_PREFIX","title":"<code>ZB_VAR_PREFIX = 'zb_var_'</code>  <code>module-attribute</code>","text":"<p>Extra zb variable prefix for thermodynamic bottleneck analyses</p>"},{"location":"api.html#cobrak.constants.Z_VAR_PREFIX","title":"<code>Z_VAR_PREFIX = 'z_var_'</code>  <code>module-attribute</code>","text":"<p>Prefix of z variables (used with thermodynamic constraints in MI(N)LPs)</p>"},{"location":"api.html#cobrak.dataclasses","title":"<code>dataclasses</code>","text":"<p>Contains all dataclasses (and enums) used by COBRAk to define a metabolic model and its extra constraints and optimization objective.</p> <p>Dataclasses are similar to structs in C: They are not intended to have member functions, only other types of member variables. The main dataclass used by COBRAk is Model, which contains the full information about the metabolic model. As member variables, a Model contains further dataclasses (such as Reaction, Metabolite, ...). As dataclass_json is also invoked, it is possible to store and load the COBRAk dataclasses as JSON.</p>"},{"location":"api.html#cobrak.dataclasses.ErrorScenario","title":"<code>ErrorScenario = dict[str, tuple[float, float]]</code>  <code>module-attribute</code>","text":"<p>A COBRAk error scenario type alias for a ConfigurationConfig; Is dict[str, tuple[float, float]]</p>"},{"location":"api.html#cobrak.dataclasses.OptResult","title":"<code>OptResult = dict[str, float]</code>  <code>module-attribute</code>","text":"<p>A COBRAk variability optimization result type alias; Is dict[str, float]</p>"},{"location":"api.html#cobrak.dataclasses.VarResult","title":"<code>VarResult = dict[str, tuple[float | None, float | None]]</code>  <code>module-attribute</code>","text":"<p>A COBRAk variability result type alias; Is dict[str, tuple[float | None, float | None]]</p>"},{"location":"api.html#cobrak.dataclasses.CorrectionConfig","title":"<code>CorrectionConfig</code>","text":"<p>Stores the configuration for corrections in a model (see parameter corrections chapter in documentation).</p> Source code in <code>cobrak/dataclasses.py</code> <pre><code>@dataclass\nclass CorrectionConfig:\n    \"\"\"Stores the configuration for corrections in a model (see parameter corrections chapter in documentation).\"\"\"\n\n    error_scenario: dict[str, tuple[float, float]] = Field(default_factory=dict)\n    \"\"\"A dictionary where keys are error scenarios and values are tuples representing the lower and upper bounds of the error. Defaults to {}.\"\"\"\n    add_flux_error_term: bool = False\n    \"\"\"Indicates whether to add flux error terms. Defaults to False.\"\"\"\n    add_met_logconc_error_term: bool = False\n    \"\"\"Indicates whether to add metabolite log concentration error terms. Defaults to False.\"\"\"\n    add_enzyme_conc_error_term: bool = False\n    \"\"\"Indicates whether to add enzyme concentration error terms. Defaults to False.\"\"\"\n    add_kcat_times_e_error_term: bool = False\n    \"\"\"Indicates whether to add k_cat \u22c5 [E] error terms. Defaults to False.\"\"\"\n    kcat_times_e_error_cutoff: PositiveFloat = 1.0\n    \"\"\"The cutoff value for the k_cat \u22c5 [E] error term. Defaults to 1.0.\"\"\"\n    max_rel_kcat_times_e_correction: PositiveFloat = QUASI_INF\n    \"\"\"Maximal relative correction for the k_cat \u22c5 [E] error error term. Defaults to QUASI_INF.\"\"\"\n    add_dG0_error_term: bool = False\n    \"\"\"Indicates whether to add \u0394G'\u00b0 error terms. Defaults to False.\"\"\"\n    dG0_error_cutoff: PositiveFloat = 1.0\n    \"\"\"The cutoff value for the \u0394G'\u00b0 error terms. Defaults to 1.0.\"\"\"\n    max_abs_dG0_correction: PositiveFloat = QUASI_INF\n    \"\"\"Maximal absolute correction for the dG0 error term. Defaults to QUASI_INF.\"\"\"\n    add_km_error_term: bool = False\n    \"\"\"Indicates whether to add a kappa error term. Defaults to False.\"\"\"\n    km_error_cutoff: PositiveFloat = 1.0\n    \"\"\"Cutoff value for the \u03ba error term. Defaults to 1.0.\"\"\"\n    max_rel_km_correction: PositiveFloat = 0.999\n    \"\"\"Maximal relative correction for the \u03ba error term. Defaults to 0.999.\"\"\"\n    add_ki_error_term: bool = False\n    \"\"\"Indicates whether to add a \u03b9 error term. Defaults to False.\"\"\"\n    ki_error_cutoff: PositiveFloat = 1.0\n    \"\"\"Cutoff value for the \u03b9 error term. Defaults to 1.0.\"\"\"\n    max_rel_ki_correction: PositiveFloat = 0.999\n    \"\"\"Maximal relative correction for the \u03b9 error term. Defaults to 0.999.\"\"\"\n    add_ka_error_term: bool = False\n    \"\"\"Indicates whether to add an \u03b1 error term. Defaults to False.\"\"\"\n    ka_error_cutoff: PositiveFloat = 1.0\n    \"\"\"Cutoff value for the \u03b1 error term. Defaults to 1.0.\"\"\"\n    max_rel_ka_correction: PositiveFloat = 0.999\n    \"\"\"Maximal relative correction for the \u03b1 error term. Defaults to 0.999.\"\"\"\n    error_sum_as_qp: bool = False\n    \"\"\"Indicates whether to use a quadratic programming approach for the error sum. Defaults to False.\"\"\"\n    add_error_sum_term: bool = True\n    \"\"\"Whether to add an error sum term. Defaults to True.\"\"\"\n    use_weights: bool = False\n    \"\"\"Indicates whether to use weights for the corrections (otherwise, the weight is 1.0). Defaults to False.\"\"\"\n    weight_percentile: NonNegativeInt = 90\n    \"\"\"Percentile to use for weight calculation. Defaults to 90.\"\"\"\n    extra_weights: dict[str, float] = Field(default_factory=dict)\n    \"\"\"Dictionary to store extra weights for specific corrections. Defaults to {}.\"\"\"\n    var_lb_ub_application: Literal[\"\", \"exp\", \"log\"] = \"\"\n    \"\"\"The application method for variable lower and upper bounds. Either '' (x=x), 'exp' or 'log'. Defaults to ''.\"\"\"\n</code></pre>"},{"location":"api.html#cobrak.dataclasses.CorrectionConfig.add_dG0_error_term","title":"<code>add_dG0_error_term = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Indicates whether to add \u0394G'\u00b0 error terms. Defaults to False.</p>"},{"location":"api.html#cobrak.dataclasses.CorrectionConfig.add_enzyme_conc_error_term","title":"<code>add_enzyme_conc_error_term = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Indicates whether to add enzyme concentration error terms. Defaults to False.</p>"},{"location":"api.html#cobrak.dataclasses.CorrectionConfig.add_error_sum_term","title":"<code>add_error_sum_term = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to add an error sum term. Defaults to True.</p>"},{"location":"api.html#cobrak.dataclasses.CorrectionConfig.add_flux_error_term","title":"<code>add_flux_error_term = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Indicates whether to add flux error terms. Defaults to False.</p>"},{"location":"api.html#cobrak.dataclasses.CorrectionConfig.add_ka_error_term","title":"<code>add_ka_error_term = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Indicates whether to add an \u03b1 error term. Defaults to False.</p>"},{"location":"api.html#cobrak.dataclasses.CorrectionConfig.add_kcat_times_e_error_term","title":"<code>add_kcat_times_e_error_term = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Indicates whether to add k_cat \u22c5 [E] error terms. Defaults to False.</p>"},{"location":"api.html#cobrak.dataclasses.CorrectionConfig.add_ki_error_term","title":"<code>add_ki_error_term = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Indicates whether to add a \u03b9 error term. Defaults to False.</p>"},{"location":"api.html#cobrak.dataclasses.CorrectionConfig.add_km_error_term","title":"<code>add_km_error_term = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Indicates whether to add a kappa error term. Defaults to False.</p>"},{"location":"api.html#cobrak.dataclasses.CorrectionConfig.add_met_logconc_error_term","title":"<code>add_met_logconc_error_term = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Indicates whether to add metabolite log concentration error terms. Defaults to False.</p>"},{"location":"api.html#cobrak.dataclasses.CorrectionConfig.dG0_error_cutoff","title":"<code>dG0_error_cutoff = 1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The cutoff value for the \u0394G'\u00b0 error terms. Defaults to 1.0.</p>"},{"location":"api.html#cobrak.dataclasses.CorrectionConfig.error_scenario","title":"<code>error_scenario = Field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A dictionary where keys are error scenarios and values are tuples representing the lower and upper bounds of the error. Defaults to {}.</p>"},{"location":"api.html#cobrak.dataclasses.CorrectionConfig.error_sum_as_qp","title":"<code>error_sum_as_qp = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Indicates whether to use a quadratic programming approach for the error sum. Defaults to False.</p>"},{"location":"api.html#cobrak.dataclasses.CorrectionConfig.extra_weights","title":"<code>extra_weights = Field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Dictionary to store extra weights for specific corrections. Defaults to {}.</p>"},{"location":"api.html#cobrak.dataclasses.CorrectionConfig.ka_error_cutoff","title":"<code>ka_error_cutoff = 1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Cutoff value for the \u03b1 error term. Defaults to 1.0.</p>"},{"location":"api.html#cobrak.dataclasses.CorrectionConfig.kcat_times_e_error_cutoff","title":"<code>kcat_times_e_error_cutoff = 1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The cutoff value for the k_cat \u22c5 [E] error term. Defaults to 1.0.</p>"},{"location":"api.html#cobrak.dataclasses.CorrectionConfig.ki_error_cutoff","title":"<code>ki_error_cutoff = 1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Cutoff value for the \u03b9 error term. Defaults to 1.0.</p>"},{"location":"api.html#cobrak.dataclasses.CorrectionConfig.km_error_cutoff","title":"<code>km_error_cutoff = 1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Cutoff value for the \u03ba error term. Defaults to 1.0.</p>"},{"location":"api.html#cobrak.dataclasses.CorrectionConfig.max_abs_dG0_correction","title":"<code>max_abs_dG0_correction = QUASI_INF</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximal absolute correction for the dG0 error term. Defaults to QUASI_INF.</p>"},{"location":"api.html#cobrak.dataclasses.CorrectionConfig.max_rel_ka_correction","title":"<code>max_rel_ka_correction = 0.999</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximal relative correction for the \u03b1 error term. Defaults to 0.999.</p>"},{"location":"api.html#cobrak.dataclasses.CorrectionConfig.max_rel_kcat_times_e_correction","title":"<code>max_rel_kcat_times_e_correction = QUASI_INF</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximal relative correction for the k_cat \u22c5 [E] error error term. Defaults to QUASI_INF.</p>"},{"location":"api.html#cobrak.dataclasses.CorrectionConfig.max_rel_ki_correction","title":"<code>max_rel_ki_correction = 0.999</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximal relative correction for the \u03b9 error term. Defaults to 0.999.</p>"},{"location":"api.html#cobrak.dataclasses.CorrectionConfig.max_rel_km_correction","title":"<code>max_rel_km_correction = 0.999</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximal relative correction for the \u03ba error term. Defaults to 0.999.</p>"},{"location":"api.html#cobrak.dataclasses.CorrectionConfig.use_weights","title":"<code>use_weights = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Indicates whether to use weights for the corrections (otherwise, the weight is 1.0). Defaults to False.</p>"},{"location":"api.html#cobrak.dataclasses.CorrectionConfig.var_lb_ub_application","title":"<code>var_lb_ub_application = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The application method for variable lower and upper bounds. Either '' (x=x), 'exp' or 'log'. Defaults to ''.</p>"},{"location":"api.html#cobrak.dataclasses.CorrectionConfig.weight_percentile","title":"<code>weight_percentile = 90</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Percentile to use for weight calculation. Defaults to 90.</p>"},{"location":"api.html#cobrak.dataclasses.Enzyme","title":"<code>Enzyme</code>","text":"<p>Represents an enzyme in a metabolic model.</p> Members <p>molecular_weight (float):     The enzyme's molecular weight in kDa. min_conc (float | None):     [Optional] If wanted, one can set a special minimal concentration     for the enzyme.     Defaults to None, i.e., no given concentration value (i.e., only the total     enzyme pool is the limit). max_conc (float | None):     [Optional] If wanted, one can set a special maximal concentration     for the enzyme.     Defaults to None, i.e., no given concentration value (i.e., only the total     enzyme pool is the limit). annotation (dict[str, str | list[str]]):     [Optional] Dictionary containing additional enzyme annotation,     e.g., {\"UNIPROT_ID\": \"b12345\"}.     Defaults to '{}'. name: str:     [Optional] Colloquial name of enzyme</p> Source code in <code>cobrak/dataclasses.py</code> <pre><code>@dataclass\nclass Enzyme:\n    \"\"\"Represents an enzyme in a metabolic model.\n\n    Members:\n        molecular_weight (float):\n            The enzyme's molecular weight in kDa.\n        min_conc (float | None):\n            [Optional] If wanted, one can set a special minimal concentration\n            for the enzyme.\n            Defaults to None, i.e., no given concentration value (i.e., only the total\n            enzyme pool is the limit).\n        max_conc (float | None):\n            [Optional] If wanted, one can set a special maximal concentration\n            for the enzyme.\n            Defaults to None, i.e., no given concentration value (i.e., only the total\n            enzyme pool is the limit).\n        annotation (dict[str, str | list[str]]):\n            [Optional] Dictionary containing additional enzyme annotation,\n            e.g., {\"UNIPROT_ID\": \"b12345\"}.\n            Defaults to '{}'.\n        name: str:\n            [Optional] Colloquial name of enzyme\n    \"\"\"\n\n    molecular_weight: FiniteFloat\n    \"\"\"The enzyme's molecular weight in kDa\"\"\"\n    min_conc: PositiveFloat | None = None\n    \"\"\"[Optional] The enzyme's minimal concentration in mmol\u22c5gDW\u207b\u00b9\"\"\"\n    max_conc: PositiveFloat | None = None\n    \"\"\"[Optional] The enzyme's minimal concentration in mmol\u22c5gDW\u207b\u00b9\"\"\"\n    annotation: dict[str, str | list[str]] = Field(default_factory=dict)\n    \"\"\"[Optional] Any annotation data for the enzyme (e.g., references). Has no effect on calculations\"\"\"\n    name: str = \"\"\n    \"\"\"Colloquial name of enzyme\"\"\"\n</code></pre>"},{"location":"api.html#cobrak.dataclasses.Enzyme.annotation","title":"<code>annotation = Field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[Optional] Any annotation data for the enzyme (e.g., references). Has no effect on calculations</p>"},{"location":"api.html#cobrak.dataclasses.Enzyme.max_conc","title":"<code>max_conc = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[Optional] The enzyme's minimal concentration in mmol\u22c5gDW\u207b\u00b9</p>"},{"location":"api.html#cobrak.dataclasses.Enzyme.min_conc","title":"<code>min_conc = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[Optional] The enzyme's minimal concentration in mmol\u22c5gDW\u207b\u00b9</p>"},{"location":"api.html#cobrak.dataclasses.Enzyme.molecular_weight","title":"<code>molecular_weight</code>  <code>instance-attribute</code>","text":"<p>The enzyme's molecular weight in kDa</p>"},{"location":"api.html#cobrak.dataclasses.Enzyme.name","title":"<code>name = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Colloquial name of enzyme</p>"},{"location":"api.html#cobrak.dataclasses.EnzymeReactionData","title":"<code>EnzymeReactionData</code>","text":"<p>Represents the enzymes used by a reaction.</p> Source code in <code>cobrak/dataclasses.py</code> <pre><code>@dataclass\nclass EnzymeReactionData:\n    \"\"\"Represents the enzymes used by a reaction.\"\"\"\n\n    identifiers: list[str]\n    \"\"\"The identifiers (must be given in the associated Model enzymes instance) of the reaction's enzyme(s)\"\"\"\n    k_cat: PositiveFloat\n    \"\"\"The reaction's k_cat (turnover numbers) in h\u207b\u00b9\"\"\"\n    k_cat_references: list[ParameterReference] = Field(default_factory=list)\n    \"\"\"[Optional] List of references showing the source(s) of the k_cat value\"\"\"\n    k_ms: dict[str, PositiveFloat] = Field(default_factory=dict)\n    \"\"\"[Optional] The reaction's k_ms (Michaelis-Menten constants) in M=mol\u22c5l\u207b\u00b9. Metabolite IDs are keys, k_ms the values. Default is {}\"\"\"\n    k_m_references: dict[str, list[ParameterReference]] = Field(default_factory=dict)\n    \"\"\"[Optional] References showing the source(s) of the k_m values. Metabolite IDs are keys, the source lists values. Default is {}\"\"\"\n    k_is: dict[str, PositiveFloat] = Field(default_factory=dict)\n    \"\"\"[Optional] The reaction's k_is (Inhibition constants) in M=mol\u22c5l\u207b\u00b9. Metabolite IDs are keys, k_is the values. Default is {}\"\"\"\n    k_i_references: dict[str, list[ParameterReference]] = Field(default_factory=dict)\n    \"\"\"[Optional] References showing the source(s) of the k_i values. Metabolite IDs are keys, the source lists values. Default is {}\"\"\"\n    k_as: dict[str, PositiveFloat] = Field(default_factory=dict)\n    \"\"\"[Optional] The reaction's k_as (Activation constants) in M=mol\u22c5l\u207b\u00b9. Metabolite IDs are keys, k_as the values. Default is {}\"\"\"\n    k_a_references: dict[str, list[ParameterReference]] = Field(default_factory=dict)\n    \"\"\"[Optional] References showing the source(s) of the k_a values. Metabolite IDs are keys, the source lists values. Default is {}\"\"\"\n    hill_coefficients: HillCoefficients = HillCoefficients()\n    \"\"\"[Optional] If given, the reaction's Hill coefficients. Metabolite IDs are keys, coefficients the  in form of HillCoefficients instances. Default is empty HillCoefficients().\"\"\"\n    hill_coefficient_references: HillParameterReferences = HillParameterReferences()\n    \"\"\"[Optional] References showing the source(s) of the Hill coefficients. Metabolite IDs are keys, the source lists values. Default is {}\"\"\"\n    special_stoichiometries: dict[str, PositiveFloat] = Field(default_factory=dict)\n    \"\"\"[Optional] Special (non-1) stoichiometries of polypeptides/enzymes in the reaction's enzyme. Default is {}\"\"\"\n</code></pre>"},{"location":"api.html#cobrak.dataclasses.EnzymeReactionData.hill_coefficient_references","title":"<code>hill_coefficient_references = HillParameterReferences()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[Optional] References showing the source(s) of the Hill coefficients. Metabolite IDs are keys, the source lists values. Default is {}</p>"},{"location":"api.html#cobrak.dataclasses.EnzymeReactionData.hill_coefficients","title":"<code>hill_coefficients = HillCoefficients()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[Optional] If given, the reaction's Hill coefficients. Metabolite IDs are keys, coefficients the  in form of HillCoefficients instances. Default is empty HillCoefficients().</p>"},{"location":"api.html#cobrak.dataclasses.EnzymeReactionData.identifiers","title":"<code>identifiers</code>  <code>instance-attribute</code>","text":"<p>The identifiers (must be given in the associated Model enzymes instance) of the reaction's enzyme(s)</p>"},{"location":"api.html#cobrak.dataclasses.EnzymeReactionData.k_a_references","title":"<code>k_a_references = Field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[Optional] References showing the source(s) of the k_a values. Metabolite IDs are keys, the source lists values. Default is {}</p>"},{"location":"api.html#cobrak.dataclasses.EnzymeReactionData.k_as","title":"<code>k_as = Field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[Optional] The reaction's k_as (Activation constants) in M=mol\u22c5l\u207b\u00b9. Metabolite IDs are keys, k_as the values. Default is {}</p>"},{"location":"api.html#cobrak.dataclasses.EnzymeReactionData.k_cat","title":"<code>k_cat</code>  <code>instance-attribute</code>","text":"<p>The reaction's k_cat (turnover numbers) in h\u207b\u00b9</p>"},{"location":"api.html#cobrak.dataclasses.EnzymeReactionData.k_cat_references","title":"<code>k_cat_references = Field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[Optional] List of references showing the source(s) of the k_cat value</p>"},{"location":"api.html#cobrak.dataclasses.EnzymeReactionData.k_i_references","title":"<code>k_i_references = Field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[Optional] References showing the source(s) of the k_i values. Metabolite IDs are keys, the source lists values. Default is {}</p>"},{"location":"api.html#cobrak.dataclasses.EnzymeReactionData.k_is","title":"<code>k_is = Field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[Optional] The reaction's k_is (Inhibition constants) in M=mol\u22c5l\u207b\u00b9. Metabolite IDs are keys, k_is the values. Default is {}</p>"},{"location":"api.html#cobrak.dataclasses.EnzymeReactionData.k_m_references","title":"<code>k_m_references = Field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[Optional] References showing the source(s) of the k_m values. Metabolite IDs are keys, the source lists values. Default is {}</p>"},{"location":"api.html#cobrak.dataclasses.EnzymeReactionData.k_ms","title":"<code>k_ms = Field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[Optional] The reaction's k_ms (Michaelis-Menten constants) in M=mol\u22c5l\u207b\u00b9. Metabolite IDs are keys, k_ms the values. Default is {}</p>"},{"location":"api.html#cobrak.dataclasses.EnzymeReactionData.special_stoichiometries","title":"<code>special_stoichiometries = Field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[Optional] Special (non-1) stoichiometries of polypeptides/enzymes in the reaction's enzyme. Default is {}</p>"},{"location":"api.html#cobrak.dataclasses.ExtraLinearConstraint","title":"<code>ExtraLinearConstraint</code>","text":"<p>Represents a general linear Model constraint.</p> <p>This can affect not only reactions, but also all other variables (including watches) set in a COBRAk model. E.g., if one wants (for whatever reason) the following constraint: 0.5 &lt;= [A] - 2 * r_R1 &lt;= 2.1 the corresponding ExtraLinearConstraint instance would be: ExtraLinearConstraint(     stoichiometries = {         \"x_A\": 1.0,         \"R1\": -2,     },     lower_value = 0.5,     upper_value = 2.1, ) lower_value or upper_value can be None if no such limit is desired.</p> Source code in <code>cobrak/dataclasses.py</code> <pre><code>@dataclass\nclass ExtraLinearConstraint:\n    \"\"\"Represents a general linear Model constraint.\n\n    This can affect not only reactions, but also all other\n    variables (including watches) set in a COBRAk model. E.g., if one wants (for whatever\n    reason) the following constraint:\n    0.5 &lt;= [A] - 2 * r_R1 &lt;= 2.1\n    the corresponding ExtraLinearConstraint instance would be:\n    ExtraLinearConstraint(\n        stoichiometries = {\n            \"x_A\": 1.0,\n            \"R1\": -2,\n        },\n        lower_value = 0.5,\n        upper_value = 2.1,\n    )\n    lower_value or upper_value can be None if no such limit is desired.\n    \"\"\"\n\n    stoichiometries: dict[str, float]\n    \"\"\"Keys: Model variable names; Children: Multipliers of constraint\"\"\"\n    lower_value: float | None = None\n    \"\"\"Minimal numeric constraint value. Either this and/or upper_value must be not None. Defaults to None.\"\"\"\n    upper_value: float | None = None\n    \"\"\"Maximal numeric constraint value. Either this and/or lower_value must be not None. Defaults to None.\"\"\"\n</code></pre>"},{"location":"api.html#cobrak.dataclasses.ExtraLinearConstraint.lower_value","title":"<code>lower_value = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Minimal numeric constraint value. Either this and/or upper_value must be not None. Defaults to None.</p>"},{"location":"api.html#cobrak.dataclasses.ExtraLinearConstraint.stoichiometries","title":"<code>stoichiometries</code>  <code>instance-attribute</code>","text":"<p>Keys: Model variable names; Children: Multipliers of constraint</p>"},{"location":"api.html#cobrak.dataclasses.ExtraLinearConstraint.upper_value","title":"<code>upper_value = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximal numeric constraint value. Either this and/or lower_value must be not None. Defaults to None.</p>"},{"location":"api.html#cobrak.dataclasses.ExtraLinearWatch","title":"<code>ExtraLinearWatch</code>","text":"<p>Represents a linear 'watch', i.e. a variable that shows the linear sum of other variables.</p> <p>A watch can be not only about reactions, but also all other variables (except of watches that are defined after this one in the Model's extra_linear_watches member variable) set in a COBRAk model. E.g., if one wants (for whatever reason) a variable for the following constraint: [A] - 2 * r_R1, we set ExtraLinearWatch(     stoichiometries = {         \"x_A\": 1.0,         \"R1\": -2,     }, )</p> <p>The name of the watch is set in as dictionary key for the model's extra_linear_watches member variable.</p> Source code in <code>cobrak/dataclasses.py</code> <pre><code>@dataclass\nclass ExtraLinearWatch:\n    \"\"\"Represents a linear 'watch', i.e. a variable that shows the linear sum of other variables.\n\n    A watch can be not only about reactions, but also all other\n    variables (except of watches that are defined *after* this one in the Model's extra_linear_watches\n    member variable) set in a COBRAk model. E.g., if one wants (for whatever\n    reason) a variable for the following constraint:\n    [A] - 2 * r_R1, we set\n    ExtraLinearWatch(\n        stoichiometries = {\n            \"x_A\": 1.0,\n            \"R1\": -2,\n        },\n    )\n\n    The name of the watch is set in as dictionary key for the model's extra_linear_watches\n    member variable.\n    \"\"\"\n\n    stoichiometries: dict[str, float]\n</code></pre>"},{"location":"api.html#cobrak.dataclasses.ExtraNonlinearConstraint","title":"<code>ExtraNonlinearConstraint</code>","text":"<p>Represents a general non-linear Model constraint.</p> <p>Important note: Setting such a non-linear watch makes any optimization non-linear and thus incompatible with linear solvers and computationally much more expensive!</p> <p>This can affect not only reactions, but also all other variables (including watches) set in a COBRA-k model. E.g., if one wants (for whatever reason) the following constraint: 0.5 &lt;= log([A]^2 - 2 * exp(r_R1)) &lt;= 2.1 the corresponding ExtraNonlinearConstraint instance would be: ExtraNonlinearConstraint(     stoichiometries = {         \"x_A\": (1.0, \"power2\"),         \"R1\": (-2, \"exp\"),     },     full_application = \"log\",     lower_value = 0.5,     upper_value = 2.1, ) Allowed non-linear functions are currently 'powerX' (with X as float-readable exponent), 'exp' and 'log'. If you just want the normal value, 'same' can be used (i.e. multiply with 1). lower_value or upper_value can be None if no such limit is desired. Also, full_application is by default 'same', which is to be set if no function on the full term is wished.</p> Source code in <code>cobrak/dataclasses.py</code> <pre><code>@dataclass\nclass ExtraNonlinearConstraint:\n    \"\"\"Represents a general non-linear Model constraint.\n\n    Important note: Setting such a non-linear watch makes any optimization non-linear and thus incompatible\n    with linear solvers and computationally much more expensive!\n\n    This can affect not only reactions, but also all other\n    variables (including watches) set in a COBRA-k model. E.g., if one wants (for whatever\n    reason) the following constraint:\n    0.5 &lt;= log([A]^2 - 2 * exp(r_R1)) &lt;= 2.1\n    the corresponding ExtraNonlinearConstraint instance would be:\n    ExtraNonlinearConstraint(\n        stoichiometries = {\n            \"x_A\": (1.0, \"power2\"),\n            \"R1\": (-2, \"exp\"),\n        },\n        full_application = \"log\",\n        lower_value = 0.5,\n        upper_value = 2.1,\n    )\n    Allowed non-linear functions are currently 'powerX' (with X as float-readable exponent), 'exp' and 'log'. If you just want\n    the normal value, 'same' can be used (i.e. multiply with 1).\n    lower_value or upper_value can be None if no such limit is desired.\n    Also, full_application is by default 'same', which is to be set if no function on the full term is wished.\n    \"\"\"\n\n    stoichiometries: dict[str, tuple[float, str]]\n    \"\"\"Keys: Model variable names; Children: (Multipliers of constraint, function name 'same' (multiply with 1), 'powerX' (with X as float-readable exponent), 'exp' or 'log')\"\"\"\n    full_application: str = \"same\"\n    \"\"\"Either function name 'same' (multiply with 1), 'powerX' (with X as float-readable exponent), 'exp' or 'log'). Defaults to 'same'.\"\"\"\n    lower_value: float | None = None\n    \"\"\"Minimal numeric constraint value. Either this and/or upper_value must be not None. Defaults to None.\"\"\"\n    upper_value: float | None = None\n    \"\"\"Maximal numeric constraint value. Either this and/or lower_value must be not None. Defaults to None.\"\"\"\n</code></pre>"},{"location":"api.html#cobrak.dataclasses.ExtraNonlinearConstraint.full_application","title":"<code>full_application = 'same'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Either function name 'same' (multiply with 1), 'powerX' (with X as float-readable exponent), 'exp' or 'log'). Defaults to 'same'.</p>"},{"location":"api.html#cobrak.dataclasses.ExtraNonlinearConstraint.lower_value","title":"<code>lower_value = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Minimal numeric constraint value. Either this and/or upper_value must be not None. Defaults to None.</p>"},{"location":"api.html#cobrak.dataclasses.ExtraNonlinearConstraint.stoichiometries","title":"<code>stoichiometries</code>  <code>instance-attribute</code>","text":"<p>Keys: Model variable names; Children: (Multipliers of constraint, function name 'same' (multiply with 1), 'powerX' (with X as float-readable exponent), 'exp' or 'log')</p>"},{"location":"api.html#cobrak.dataclasses.ExtraNonlinearConstraint.upper_value","title":"<code>upper_value = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximal numeric constraint value. Either this and/or lower_value must be not None. Defaults to None.</p>"},{"location":"api.html#cobrak.dataclasses.ExtraNonlinearWatch","title":"<code>ExtraNonlinearWatch</code>","text":"<p>Represents a non-linear 'watch', i.e. a variable that shows the linear sum of other variables.</p> <p>Important note: Setting such a non-linear watch makes any optimization non-linear and thus incompatible with linear solvers and computationally much more expensive!</p> <p>A watch can be not only about reactions, but also all other variables (except of watches that are defined after this one in the Model's extra_linear_watches member variable) set in a COBRAk model. E.g., if one wants (for whatever reason) a variable for the following constraint: exp([A]) - 2 * r_R1^3, we set ExtraLinearWatch(     stoichiometries = {         \"x_A\": (1.0, \"exp\"),         \"R1\": (-2, \"power3\"),     }, )</p> <p>Allowed non-linear functions are currently 'powerX' (with X as float-readable exponent), 'exp' and 'log'. If you just want the normal value, 'same' can be used (i.e. multiply with 1). The name of the watch is set in as dictionary key for the model's extra_linear_watches member variable.</p> Source code in <code>cobrak/dataclasses.py</code> <pre><code>@dataclass\nclass ExtraNonlinearWatch:\n    \"\"\"Represents a non-linear 'watch', i.e. a variable that shows the linear sum of other variables.\n\n    Important note: Setting such a non-linear watch makes any optimization non-linear and thus incompatible\n    with linear solvers and computationally much more expensive!\n\n    A watch can be not only about reactions, but also all other\n    variables (except of watches that are defined *after* this one in the Model's extra_linear_watches\n    member variable) set in a COBRAk model. E.g., if one wants (for whatever\n    reason) a variable for the following constraint:\n    exp([A]) - 2 * r_R1^3, we set\n    ExtraLinearWatch(\n        stoichiometries = {\n            \"x_A\": (1.0, \"exp\"),\n            \"R1\": (-2, \"power3\"),\n        },\n    )\n\n    Allowed non-linear functions are currently 'powerX' (with X as float-readable exponent), 'exp' and 'log'. If you just want\n    the normal value, 'same' can be used (i.e. multiply with 1).\n    The name of the watch is set in as dictionary key for the model's extra_linear_watches\n    member variable.\n    \"\"\"\n\n    stoichiometries: dict[str, tuple[float, str]]\n</code></pre>"},{"location":"api.html#cobrak.dataclasses.HillCoefficients","title":"<code>HillCoefficients</code>","text":"<p>Represents the Hill coefficients of a reactions, seperated according to efficiency terms</p> Source code in <code>cobrak/dataclasses.py</code> <pre><code>@dataclass\nclass HillCoefficients:\n    \"\"\"Represents the Hill coefficients of a reactions, seperated according to efficiency terms\"\"\"\n\n    kappa: dict[str, PositiveFloat] = Field(default_factory=dict)\n    \"\"\"Hill coefficients affecting the \u03ba saturation term. Metabolite IDs are keys, coefficients values. Defaults to {}.\"\"\"\n    iota: dict[str, PositiveFloat] = Field(default_factory=dict)\n    \"\"\"Hill coefficients affecting the \u03b9 inhibition term. Metabolite IDs are keys, coefficients values. Defaults to {}.\"\"\"\n    alpha: dict[str, PositiveFloat] = Field(default_factory=dict)\n    \"\"\"Hill coefficients affecting the \u03b1 activation term. Metabolite IDs are keys, coefficients values. Defaults to {}.\"\"\"\n</code></pre>"},{"location":"api.html#cobrak.dataclasses.HillCoefficients.alpha","title":"<code>alpha = Field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Hill coefficients affecting the \u03b1 activation term. Metabolite IDs are keys, coefficients values. Defaults to {}.</p>"},{"location":"api.html#cobrak.dataclasses.HillCoefficients.iota","title":"<code>iota = Field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Hill coefficients affecting the \u03b9 inhibition term. Metabolite IDs are keys, coefficients values. Defaults to {}.</p>"},{"location":"api.html#cobrak.dataclasses.HillCoefficients.kappa","title":"<code>kappa = Field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Hill coefficients affecting the \u03ba saturation term. Metabolite IDs are keys, coefficients values. Defaults to {}.</p>"},{"location":"api.html#cobrak.dataclasses.HillParameterReferences","title":"<code>HillParameterReferences</code>","text":"<p>Represents the database reference for the \u03b9, \u03b1 and \u03ba Hill coefficients.</p> Source code in <code>cobrak/dataclasses.py</code> <pre><code>@dataclass\nclass HillParameterReferences:\n    \"\"\"Represents the database reference for the \u03b9, \u03b1 and \u03ba Hill coefficients.\"\"\"\n\n    kappa: dict[str, list[ParameterReference]] = Field(default_factory=dict)\n    \"\"\"References for \u03ba Hill coefficients.\"\"\"\n    iota: dict[str, list[ParameterReference]] = Field(default_factory=dict)\n    \"\"\"References for \u03b9 Hill coefficients.\"\"\"\n    alpha: dict[str, list[ParameterReference]] = Field(default_factory=dict)\n    \"\"\"References for \u03b1 Hill coefficients.\"\"\"\n</code></pre>"},{"location":"api.html#cobrak.dataclasses.HillParameterReferences.alpha","title":"<code>alpha = Field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>References for \u03b1 Hill coefficients.</p>"},{"location":"api.html#cobrak.dataclasses.HillParameterReferences.iota","title":"<code>iota = Field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>References for \u03b9 Hill coefficients.</p>"},{"location":"api.html#cobrak.dataclasses.HillParameterReferences.kappa","title":"<code>kappa = Field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>References for \u03ba Hill coefficients.</p>"},{"location":"api.html#cobrak.dataclasses.Metabolite","title":"<code>Metabolite</code>","text":"<p>Represents a Model's metabolite.</p> Source code in <code>cobrak/dataclasses.py</code> <pre><code>@dataclass\nclass Metabolite:\n    \"\"\"Represents a Model's metabolite.\"\"\"\n\n    log_min_conc: FiniteFloat = log(1e-6)\n    \"\"\"Maximal logarithmic concentration (only relevant for thermodynamic constraints); Default is log(1e-6 M)\"\"\"\n    log_max_conc: FiniteFloat = log(0.02)\n    \"\"\"Maximal logarithmic concentration (only relevant for thermodynamic constraints); Default is log(0.02 M)\"\"\"\n    annotation: dict[str, str | list[str]] = Field(default_factory=dict)\n    \"\"\"Optional annotation (e.g., CHEBI numbers, ...); Default is {}\"\"\"\n    name: str = \"\"\n    \"\"\"Colloquial name of metabolite\"\"\"\n    formula: str = \"\"\n    \"\"\"Chemical formula of metabolite\"\"\"\n    charge: int = 0\n    \"\"\"Electron charge of metabolite\"\"\"\n</code></pre>"},{"location":"api.html#cobrak.dataclasses.Metabolite.annotation","title":"<code>annotation = Field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional annotation (e.g., CHEBI numbers, ...); Default is {}</p>"},{"location":"api.html#cobrak.dataclasses.Metabolite.charge","title":"<code>charge = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Electron charge of metabolite</p>"},{"location":"api.html#cobrak.dataclasses.Metabolite.formula","title":"<code>formula = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Chemical formula of metabolite</p>"},{"location":"api.html#cobrak.dataclasses.Metabolite.log_max_conc","title":"<code>log_max_conc = log(0.02)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximal logarithmic concentration (only relevant for thermodynamic constraints); Default is log(0.02 M)</p>"},{"location":"api.html#cobrak.dataclasses.Metabolite.log_min_conc","title":"<code>log_min_conc = log(1e-06)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximal logarithmic concentration (only relevant for thermodynamic constraints); Default is log(1e-6 M)</p>"},{"location":"api.html#cobrak.dataclasses.Metabolite.name","title":"<code>name = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Colloquial name of metabolite</p>"},{"location":"api.html#cobrak.dataclasses.Model","title":"<code>Model</code>","text":"<p>Represents a metabolic model in COBRAk.</p> <p>This includes its Reaction instances (which define the reaction stoichiometries), its Metabolite instances (which are referenced in the mentioned stoichiometries), as well as optional enzymatic and thermodynamic data.</p> Source code in <code>cobrak/dataclasses.py</code> <pre><code>@dataclass\nclass Model:\n    \"\"\"Represents a metabolic model in COBRAk.\n\n    This includes its Reaction instances (which define the reaction stoichiometries),\n    its Metabolite instances (which are referenced in the mentioned stoichiometries),\n    as well as optional enzymatic and thermodynamic data.\n    \"\"\"\n\n    metabolites: dict[str, Metabolite]\n    \"\"\"Keys: Metabolite IDs; Children: Metabolite instances\"\"\"\n    reactions: dict[str, Reaction]\n    \"\"\"Keys: Reaction IDs; Children: Reaction instances\"\"\"\n    enzymes: dict[str, Enzyme] = Field(default_factory=dict)\n    \"\"\"[Only neccessary with enzymatic constraints] Keys: Enzyme IDs; Children: Enzyme instances; default is {}\"\"\"\n    max_prot_pool: PositiveFloat = Field(default=1e9)\n    \"\"\"[Only neccessary with enzymatic constraints] Maximal usable protein pool in g/gDW; default is 1e9, i.e. basically unrestricted\"\"\"\n    extra_linear_watches: dict[str, ExtraLinearWatch] = Field(default_factory=dict)\n    \"\"\"[Optional] Extra non-linear watches. Keys are watch names, children the watch definition.\"\"\"\n    extra_nonlinear_watches: dict[str, ExtraNonlinearWatch] = Field(\n        default_factory=dict\n    )\n    \"\"\"[Optional] Extra non-linear watches. Keys are watch names, children the watch definition.\"\"\"\n    extra_linear_constraints: list[ExtraLinearConstraint] = Field(default_factory=list)\n    \"\"\"[Optional] Extra linear constraints\"\"\"\n    extra_nonlinear_constraints: list[ExtraNonlinearConstraint] = Field(\n        default_factory=list\n    )\n    \"\"\"[Optional] Extra non-linear constraints\"\"\"\n    kinetic_ignored_metabolites: list[str] = Field(default_factory=list)\n    \"\"\"[Optional and only works with saturation term constraints] Metabolite IDs for which no k_m is neccessary\"\"\"\n    R: PositiveFloat = Field(default=STANDARD_R)\n    \"\"\"[Optional and only works with thermodynamic constraints] Gas constant reference for dG'\u00b0 in kJ\u22c5K\u207b\u00b9\u22c5mol\u207b\u00b9; default is STANDARD_R\"\"\"\n    T: PositiveFloat = Field(default=STANDARD_T)\n    \"\"\"[Optional and only works with thermodynamic constraints] Temperature reference for dG'\u00b0 in K; default is STANDARD_T\"\"\"\n    annotation: dict[str, str | list[str]] = Field(default_factory=dict)\n    \"\"\"[Optional] Any annotation for the model itself (e.g., its name or references). Has no effect on calculations.\"\"\"\n    reac_enz_separator: str = REAC_ENZ_SEPARATOR\n    \"\"\"[Optional] String infix that separated reaction IDs of reaction with multiple enzyme variants from their enzyme ID. Defaults to '_ENZ_'\"\"\"\n    fwd_suffix: str = REAC_FWD_SUFFIX\n    \"\"\"[Optional] Reaction ID suffix of forward reaction variants (e.g. in a reversible reaction A\u2192B, for the direction A\u2192B). Default is '_FWD'\"\"\"\n    rev_suffix: str = REAC_REV_SUFFIX\n    \"\"\"[Optional] Reaction ID suffix of reverse reaction variants (e.g. in a reversible reaction A\u2192B, for the direction B\u2192A). Default is '_REV'\"\"\"\n    max_conc_sum: float = float(\"inf\")\n    \"\"\"[Optional and only works with thermodynamic constraints] Maximal allowed sum of concentrations (for MILPs: linear approximation; for NLPs: Exact value). Inactive if set to default value of float('inf')\"\"\"\n    conc_sum_ignore_prefixes: list[str] = Field(default_factory=list)\n    \"\"\"[Optional and only works with thermodynamic constraints] \"\"\"\n    conc_sum_include_suffixes: list[str] = Field(default_factory=list)\n    \"\"\"[Optional and only works with thermodynamic constraints] \"\"\"\n    conc_sum_max_rel_error: float = 0.05\n    \"\"\"[Optional and only works with MILPs with thermodynamic constraints] Maximal relative concentration sum approximation error\"\"\"\n    conc_sum_min_abs_error: float = 1e-6\n    \"\"\"[Optional and only works with MILPs with thermodynamic constraints] Maximal absolute concentration sum approximation error\"\"\"\n\n    def __enter__(self):  # noqa: ANN204\n        \"\"\"Method called when entering 'with' blocks\"\"\"\n        # Return a deep copy of self\n        return deepcopy(self)\n\n    def __exit__(self, a, b, c):  # noqa: ANN001, ANN204\n        \"\"\"Method called when leaving a 'with' block\"\"\"\n        return  # Return None to propagate any exceptions\n</code></pre>"},{"location":"api.html#cobrak.dataclasses.Model.R","title":"<code>R = Field(default=STANDARD_R)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[Optional and only works with thermodynamic constraints] Gas constant reference for dG'\u00b0 in kJ\u22c5K\u207b\u00b9\u22c5mol\u207b\u00b9; default is STANDARD_R</p>"},{"location":"api.html#cobrak.dataclasses.Model.T","title":"<code>T = Field(default=STANDARD_T)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[Optional and only works with thermodynamic constraints] Temperature reference for dG'\u00b0 in K; default is STANDARD_T</p>"},{"location":"api.html#cobrak.dataclasses.Model.annotation","title":"<code>annotation = Field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[Optional] Any annotation for the model itself (e.g., its name or references). Has no effect on calculations.</p>"},{"location":"api.html#cobrak.dataclasses.Model.conc_sum_ignore_prefixes","title":"<code>conc_sum_ignore_prefixes = Field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[Optional and only works with thermodynamic constraints]</p>"},{"location":"api.html#cobrak.dataclasses.Model.conc_sum_include_suffixes","title":"<code>conc_sum_include_suffixes = Field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[Optional and only works with thermodynamic constraints]</p>"},{"location":"api.html#cobrak.dataclasses.Model.conc_sum_max_rel_error","title":"<code>conc_sum_max_rel_error = 0.05</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[Optional and only works with MILPs with thermodynamic constraints] Maximal relative concentration sum approximation error</p>"},{"location":"api.html#cobrak.dataclasses.Model.conc_sum_min_abs_error","title":"<code>conc_sum_min_abs_error = 1e-06</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[Optional and only works with MILPs with thermodynamic constraints] Maximal absolute concentration sum approximation error</p>"},{"location":"api.html#cobrak.dataclasses.Model.enzymes","title":"<code>enzymes = Field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[Only neccessary with enzymatic constraints] Keys: Enzyme IDs; Children: Enzyme instances; default is {}</p>"},{"location":"api.html#cobrak.dataclasses.Model.extra_linear_constraints","title":"<code>extra_linear_constraints = Field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[Optional] Extra linear constraints</p>"},{"location":"api.html#cobrak.dataclasses.Model.extra_linear_watches","title":"<code>extra_linear_watches = Field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[Optional] Extra non-linear watches. Keys are watch names, children the watch definition.</p>"},{"location":"api.html#cobrak.dataclasses.Model.extra_nonlinear_constraints","title":"<code>extra_nonlinear_constraints = Field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[Optional] Extra non-linear constraints</p>"},{"location":"api.html#cobrak.dataclasses.Model.extra_nonlinear_watches","title":"<code>extra_nonlinear_watches = Field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[Optional] Extra non-linear watches. Keys are watch names, children the watch definition.</p>"},{"location":"api.html#cobrak.dataclasses.Model.fwd_suffix","title":"<code>fwd_suffix = REAC_FWD_SUFFIX</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[Optional] Reaction ID suffix of forward reaction variants (e.g. in a reversible reaction A\u2192B, for the direction A\u2192B). Default is '_FWD'</p>"},{"location":"api.html#cobrak.dataclasses.Model.kinetic_ignored_metabolites","title":"<code>kinetic_ignored_metabolites = Field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[Optional and only works with saturation term constraints] Metabolite IDs for which no k_m is neccessary</p>"},{"location":"api.html#cobrak.dataclasses.Model.max_conc_sum","title":"<code>max_conc_sum = float('inf')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[Optional and only works with thermodynamic constraints] Maximal allowed sum of concentrations (for MILPs: linear approximation; for NLPs: Exact value). Inactive if set to default value of float('inf')</p>"},{"location":"api.html#cobrak.dataclasses.Model.max_prot_pool","title":"<code>max_prot_pool = Field(default=1000000000.0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[Only neccessary with enzymatic constraints] Maximal usable protein pool in g/gDW; default is 1e9, i.e. basically unrestricted</p>"},{"location":"api.html#cobrak.dataclasses.Model.metabolites","title":"<code>metabolites</code>  <code>instance-attribute</code>","text":"<p>Keys: Metabolite IDs; Children: Metabolite instances</p>"},{"location":"api.html#cobrak.dataclasses.Model.reac_enz_separator","title":"<code>reac_enz_separator = REAC_ENZ_SEPARATOR</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[Optional] String infix that separated reaction IDs of reaction with multiple enzyme variants from their enzyme ID. Defaults to 'ENZ'</p>"},{"location":"api.html#cobrak.dataclasses.Model.reactions","title":"<code>reactions</code>  <code>instance-attribute</code>","text":"<p>Keys: Reaction IDs; Children: Reaction instances</p>"},{"location":"api.html#cobrak.dataclasses.Model.rev_suffix","title":"<code>rev_suffix = REAC_REV_SUFFIX</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[Optional] Reaction ID suffix of reverse reaction variants (e.g. in a reversible reaction A\u2192B, for the direction B\u2192A). Default is '_REV'</p>"},{"location":"api.html#cobrak.dataclasses.Model.__enter__","title":"<code>__enter__()</code>","text":"<p>Method called when entering 'with' blocks</p> Source code in <code>cobrak/dataclasses.py</code> <pre><code>def __enter__(self):  # noqa: ANN204\n    \"\"\"Method called when entering 'with' blocks\"\"\"\n    # Return a deep copy of self\n    return deepcopy(self)\n</code></pre>"},{"location":"api.html#cobrak.dataclasses.Model.__exit__","title":"<code>__exit__(a, b, c)</code>","text":"<p>Method called when leaving a 'with' block</p> Source code in <code>cobrak/dataclasses.py</code> <pre><code>def __exit__(self, a, b, c):  # noqa: ANN001, ANN204\n    \"\"\"Method called when leaving a 'with' block\"\"\"\n    return  # Return None to propagate any exceptions\n</code></pre>"},{"location":"api.html#cobrak.dataclasses.ParameterReference","title":"<code>ParameterReference</code>","text":"<p>Represents the database reference for a kinetic parameter.</p> Source code in <code>cobrak/dataclasses.py</code> <pre><code>@dataclass\nclass ParameterReference:\n    \"\"\"Represents the database reference for a kinetic parameter.\"\"\"\n\n    database: str = \"\"\n    \"\"\"(If given) The database from which this parameter was read. Defaults to ''.\"\"\"\n    comment: str = \"(no refs)\"\n    \"\"\"Any comment given for this value (e.g. literature)? Defaults to '(no refs)'.\"\"\"\n    species: str = \"\"\n    \"\"\"Scientific name of the species where this value was measured. Defaults to ''.\"\"\"\n    substrate: str = \"\"\n    \"\"\"The metabolite (or reaction substrate) for which this value was measured. Defaults to ''.\"\"\"\n    pubs: list[str] = Field(default_factory=list)\n    \"\"\"\"\"\"\n    tax_distance: int | None = None\n    value: float | None = None\n</code></pre>"},{"location":"api.html#cobrak.dataclasses.ParameterReference.comment","title":"<code>comment = '(no refs)'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Any comment given for this value (e.g. literature)? Defaults to '(no refs)'.</p>"},{"location":"api.html#cobrak.dataclasses.ParameterReference.database","title":"<code>database = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>(If given) The database from which this parameter was read. Defaults to ''.</p>"},{"location":"api.html#cobrak.dataclasses.ParameterReference.pubs","title":"<code>pubs = Field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api.html#cobrak.dataclasses.ParameterReference.species","title":"<code>species = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Scientific name of the species where this value was measured. Defaults to ''.</p>"},{"location":"api.html#cobrak.dataclasses.ParameterReference.substrate","title":"<code>substrate = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The metabolite (or reaction substrate) for which this value was measured. Defaults to ''.</p>"},{"location":"api.html#cobrak.dataclasses.Reaction","title":"<code>Reaction</code>","text":"<p>Represents a Model's reaction.</p> <p>E.g., a reaction A -&gt; B [0; 1000], \u0394G'\u00b0=12.1 kJ\u22c5mol\u207b\u00b9, catalyzed by E1 with k_cat=1000 h\u207b\u00b9 would be Reaction(     stoichiometries: {         \"A\": -1,         \"B\": +1,     },     min_flux: 0,     max_flux: 1000,     dG0=12.1,     dG0_uncertainty=None,     enzyme_reaction_data=EnzymeReactionData(         identifiers=[\"E1\"],         k_cat=1000,         k_ms=None,         k_is=None,         k_as=None,         hill_coefficients=None,     ),     annotation={}, # Can be also ignored )</p> Source code in <code>cobrak/dataclasses.py</code> <pre><code>@dataclass\nclass Reaction:\n    \"\"\"Represents a Model's reaction.\n\n    E.g., a reaction\n    A -&gt; B [0; 1000], \u0394G'\u00b0=12.1 kJ\u22c5mol\u207b\u00b9, catalyzed by E1 with k_cat=1000 h\u207b\u00b9\n    would be\n    Reaction(\n        stoichiometries: {\n            \"A\": -1,\n            \"B\": +1,\n        },\n        min_flux: 0,\n        max_flux: 1000,\n        dG0=12.1,\n        dG0_uncertainty=None,\n        enzyme_reaction_data=EnzymeReactionData(\n            identifiers=[\"E1\"],\n            k_cat=1000,\n            k_ms=None,\n            k_is=None,\n            k_as=None,\n            hill_coefficients=None,\n        ),\n        annotation={}, # Can be also ignored\n    )\n    \"\"\"\n\n    stoichiometries: dict[str, float]\n    \"\"\"Metabolite stoichiometries\"\"\"\n    min_flux: float\n    \"\"\"Minimal flux (for COBRAk, this must be \u2265 0)\"\"\"\n    max_flux: float\n    \"\"\"Maximal flux (must be &gt;= min_flux)\"\"\"\n    dG0: FiniteFloat | None = None\n    \"\"\"If given, the Gibb's free energy of the reaction (only relevant for thermodynamic constraints); Default is None\"\"\"\n    dG0_uncertainty: FiniteFloat | None = None\n    \"\"\"If given, the Gibb's free energy's uncertainty (only relevant for thermodynamic constraints); Default is None\"\"\"\n    enzyme_reaction_data: EnzymeReactionData | None = None\n    \"\"\"If given, enzymatic data (only relevant for enzymatic constraints); Default is None\"\"\"\n    annotation: dict[str, str | list[str]] = Field(default_factory=dict)\n    \"\"\"Optional annotation (e.g., KEGG identifiers, ...)\"\"\"\n    name: str = \"\"\n    \"\"\"Colloquial name of reaction\"\"\"\n</code></pre>"},{"location":"api.html#cobrak.dataclasses.Reaction.annotation","title":"<code>annotation = Field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Optional annotation (e.g., KEGG identifiers, ...)</p>"},{"location":"api.html#cobrak.dataclasses.Reaction.dG0","title":"<code>dG0 = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If given, the Gibb's free energy of the reaction (only relevant for thermodynamic constraints); Default is None</p>"},{"location":"api.html#cobrak.dataclasses.Reaction.dG0_uncertainty","title":"<code>dG0_uncertainty = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If given, the Gibb's free energy's uncertainty (only relevant for thermodynamic constraints); Default is None</p>"},{"location":"api.html#cobrak.dataclasses.Reaction.enzyme_reaction_data","title":"<code>enzyme_reaction_data = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If given, enzymatic data (only relevant for enzymatic constraints); Default is None</p>"},{"location":"api.html#cobrak.dataclasses.Reaction.max_flux","title":"<code>max_flux</code>  <code>instance-attribute</code>","text":"<p>Maximal flux (must be &gt;= min_flux)</p>"},{"location":"api.html#cobrak.dataclasses.Reaction.min_flux","title":"<code>min_flux</code>  <code>instance-attribute</code>","text":"<p>Minimal flux (for COBRAk, this must be \u2265 0)</p>"},{"location":"api.html#cobrak.dataclasses.Reaction.name","title":"<code>name = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Colloquial name of reaction</p>"},{"location":"api.html#cobrak.dataclasses.Reaction.stoichiometries","title":"<code>stoichiometries</code>  <code>instance-attribute</code>","text":"<p>Metabolite stoichiometries</p>"},{"location":"api.html#cobrak.dataclasses.Solver","title":"<code>Solver</code>","text":"<p>Represents options for a pyomo-compatible solver</p> Source code in <code>cobrak/dataclasses.py</code> <pre><code>@dataclass\nclass Solver:\n    \"\"\"Represents options for a pyomo-compatible solver\"\"\"\n\n    name: str\n    \"\"\"The solver's name. E.g. 'scip' for SCIP and 'cplex_direct' for CPLEX.\"\"\"\n    solver_options: dict[str, float | int | str] = Field(default_factory=dict)\n    \"\"\"[Optional] Options transmitted to the solver itself.\"\"\"\n    solver_attrs: dict[str, float | int | str] = Field(default_factory=dict)\n    \"\"\"[Optional] Options set on the solver object in pyomo.\"\"\"\n    solve_extra_options: dict[str, Any] = Field(default_factory=dict)\n    \"\"\"[Optional] Options set on pyomo's solve function.\"\"\"\n</code></pre>"},{"location":"api.html#cobrak.dataclasses.Solver.name","title":"<code>name</code>  <code>instance-attribute</code>","text":"<p>The solver's name. E.g. 'scip' for SCIP and 'cplex_direct' for CPLEX.</p>"},{"location":"api.html#cobrak.dataclasses.Solver.solve_extra_options","title":"<code>solve_extra_options = Field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[Optional] Options set on pyomo's solve function.</p>"},{"location":"api.html#cobrak.dataclasses.Solver.solver_attrs","title":"<code>solver_attrs = Field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[Optional] Options set on the solver object in pyomo.</p>"},{"location":"api.html#cobrak.dataclasses.Solver.solver_options","title":"<code>solver_options = Field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[Optional] Options transmitted to the solver itself.</p>"},{"location":"api.html#cobrak.equilibrator_functionality","title":"<code>equilibrator_functionality</code>","text":"<p>This script is a wrapper for the \u0394G'\u00b0 determination with the eQuilibrator API.</p> <p>This wrapper intends to work with BiGG-styled cobrapy metabolic models.</p>"},{"location":"api.html#cobrak.equilibrator_functionality.equilibrator_get_model_dG0_and_uncertainty_values","title":"<code>equilibrator_get_model_dG0_and_uncertainty_values(sbml_path, inner_to_outer_compartments, phs, pmgs, ionic_strengths, potential_differences, exclusion_prefixes=[], exclusion_inner_parts=[], ignore_uncertainty=False, max_uncertainty=1000.0)</code>","text":"<p>Cobrapy model wrapper for the \u0394G'\u00b0 determination of reactions using the eQuilibrator-API.</p> <p>Reactions are identified according to all annotation (in the cobrapy reaction's annotation member variable) given in this modules global USED_IDENTIFIERS list.</p> <p>Parameters:</p> Name Type Description Default <code>sbml_path</code> <code>str</code> <p>The path to the SBML-encoded constraint-based metabolic model for which \u0394G'\u00b0 values are determined.</p> required <code>inner_to_outer_compartments</code> <code>List[str]</code> <p>A list with compartment IDs going from inner (e.g., in E. coli, the cytosol or 'c' in iML1515) to outer (e.g., the extracellular component or 'e' in iML1515). Used for the \u0394G'\u00b0 calculation in multi-compartmental reactions.</p> required <code>phs</code> <code>Dict[str, float]</code> <p>A dictionary with compartment IDs as keys and the compartment pHs as values.</p> required <code>pmgs</code> <code>Dict[str, float]</code> <p>A dictionary with compartment IDs as keys and the compartment pMgs as values.</p> required <code>ionic_strengths</code> <code>Dict[str, float]</code> <p>A dictionary with compartment IDs as keys and the ionic strengths as values.</p> required <code>potential_differences</code> <code>Dict[Tuple[str, str], float]</code> <p>A dictionary containing tuples with 2 elements describing the ID of an innter and outer compartment, and the potential difference between them.</p> required <code>max_uncertainty</code> <code>float</code> <p>The maximal accepted uncertainty value (defaults to 1000 kJ\u22c5mol\u207b\u00b9). If a calculated uncertainty is higher than this value, the associated \u0394G'\u00b0 is not used (i.e., the specific reaction gets no \u0394G'\u00b0).</p> <code>1000.0</code> <p>Returns:</p> Type Description <code>tuple[dict[str, float], dict[str, float]]</code> <p>Dict[str, Dict[str, float]]: A dictionary with the reaction IDs as keys, and dictionaries as values which, in turn, contain the \u0394G'\u00b0 of a reaction under the key 'dG0' and the calculated uncertainty as 'uncertainty'.</p> Source code in <code>cobrak/equilibrator_functionality.py</code> <pre><code>@validate_call(config=ConfigDict(arbitrary_types_allowed=True))\ndef equilibrator_get_model_dG0_and_uncertainty_values(\n    sbml_path: str,\n    inner_to_outer_compartments: list[str],\n    phs: dict[str, float],\n    pmgs: dict[str, float],\n    ionic_strengths: dict[str, float],\n    potential_differences: dict[tuple[str, str], float],\n    exclusion_prefixes: list[str] = [],\n    exclusion_inner_parts: list[str] = [],\n    ignore_uncertainty: bool = False,\n    max_uncertainty: float = 1_000.0,\n) -&gt; tuple[dict[str, float], dict[str, float]]:\n    \"\"\"Cobrapy model wrapper for the \u0394G'\u00b0 determination of reactions using the eQuilibrator-API.\n\n    Reactions are identified according to all annotation (in the cobrapy reaction's annotation member variable)\n    given in this modules global USED_IDENTIFIERS list.\n\n    Args:\n        sbml_path (str): The path to the SBML-encoded constraint-based metabolic model for which \u0394G'\u00b0 values are determined.\n        inner_to_outer_compartments (List[str]): A list with compartment IDs going from inner (e.g., in E. coli,\n            the cytosol or 'c' in iML1515) to outer (e.g., the extracellular component or 'e' in iML1515). Used\n            for the \u0394G'\u00b0 calculation in multi-compartmental reactions.\n        phs (Dict[str, float]): A dictionary with compartment IDs as keys and the compartment pHs as values.\n        pmgs (Dict[str, float]): A dictionary with compartment IDs as keys and the compartment pMgs as values.\n        ionic_strengths (Dict[str, float]): A dictionary with compartment IDs as keys and the ionic strengths as values.\n        potential_differences (Dict[Tuple[str, str], float]): A dictionary containing tuples with 2 elements describing\n            the ID of an innter and outer compartment, and the potential difference between them.\n        max_uncertainty (float): The maximal accepted uncertainty value (defaults to 1000 kJ\u22c5mol\u207b\u00b9). If a calculated uncertainty\n            is higher than this value, the associated \u0394G'\u00b0 is *not* used (i.e., the specific reaction gets no \u0394G'\u00b0).\n\n    Returns:\n        Dict[str, Dict[str, float]]: A dictionary with the reaction IDs as keys, and dictionaries as values which,\n            in turn, contain the \u0394G'\u00b0 of a reaction under the key 'dG0' and the calculated uncertainty as 'uncertainty'.\n    \"\"\"\n    cobra_model = cobra.io.read_sbml_model(sbml_path)\n\n    reaction_dG0s: dict[str, float] = {}\n    reaction_dG0_uncertainties: dict[str, float] = {}\n    cc = ComponentContribution()\n    for reaction_x in cobra_model.reactions:\n        reaction: cobra.Reaction = reaction_x\n\n        stop = False\n        for exclusion_prefix in exclusion_prefixes:\n            if reaction.id.startswith(exclusion_prefix):\n                stop = True\n        for exclusion_inner_part in exclusion_inner_parts:\n            if exclusion_inner_part in reaction.id:\n                stop = True\n        if stop:\n            continue\n\n        stoichiometries: list[float] = []\n        compartments: list[str] = []\n        identifiers: list[str] = []\n        identifier_keys: list[str] = []\n        for metabolite_x in reaction.metabolites:\n            metabolite: cobra.Metabolite = metabolite_x\n            stoichiometries.append(reaction.metabolites[metabolite])\n            compartments.append(metabolite.compartment)\n            identifier = \"\"\n            for used_identifier in USED_IDENTIFIERS_FOR_EQUILIBRATOR:\n                if used_identifier not in metabolite.annotation:\n                    continue\n                metabolite_identifiers = metabolite.annotation[used_identifier]\n                identifier_temp = \"\"\n                if isinstance(metabolite_identifiers, list):\n                    identifier_temp = metabolite_identifiers[0]\n                elif isinstance(metabolite_identifiers, str):\n                    identifier_temp = metabolite_identifiers\n                if used_identifier == \"inchi\":\n                    compound = cc.get_compound_by_inchi(identifier_temp)\n                elif used_identifier == \"inchi_key\":\n                    compound_list = cc.search_compound_by_inchi_key(identifier_temp)\n                    compound = compound_list[0] if len(compound_list) &gt; 0 else None\n                else:\n                    identifier_temp = used_identifier + \":\" + identifier_temp\n                    compound = cc.get_compound(identifier_temp)\n                if compound is not None:\n                    identifier_key = used_identifier\n                    identifier = identifier_temp\n                    break\n            if not identifier:\n                break\n            identifier_keys.append(identifier_key)\n            identifiers.append(identifier)\n\n        if not identifier:\n            print(\n                f\"ERROR: Metabolite {metabolite_x.id} has no identifier of the given types!\"\n            )\n            print(metabolite_x.annotation)\n            continue\n\n        # Check for three cases:\n        # 1: Single-compartment reaction\n        # 2: Double-compartment reaction\n        # 3: Multi-compartment reaction (not possible)\n        unique_reaction_compartments = list(set(compartments))\n        num_compartments = len(unique_reaction_compartments)\n        if num_compartments == 1:\n            # Set compartment conditions\n            compartment = unique_reaction_compartments[0]\n            cc.p_h = Q_(phs[compartment])\n            cc.p_mg = Q_(pmgs[compartment])\n            cc.ionic_strength = Q_(str(ionic_strengths[compartment]) + \"mM\")\n\n            # Build together reaction\n            reaction_dict: dict[Any, float] = {}\n            for i in range(len(stoichiometries)):\n                identifier_string = identifiers[i]\n                identifier_key = identifier_keys[i]\n                stoichiometry = stoichiometries[i]\n                if identifier_key == \"inchi\":\n                    compound = cc.get_compound_by_inchi(identifier_string)\n                elif identifier_key == \"inchi_key\":\n                    compound = cc.search_compound_by_inchi_key(identifier_string)[0]\n                else:\n                    compound = cc.get_compound(identifier_string)\n                reaction_dict[compound] = stoichiometry\n            cc_reaction = Reaction(reaction_dict)\n\n            # Check whether or not the reaction is balanced and...\n            if not cc_reaction.is_balanced():\n                print(f\"INFO: Reaction {reaction.id} is not balanced\")\n                continue\n\n            standard_dg_prime = cc.standard_dg_prime(cc_reaction)\n            uncertainty = standard_dg_prime.error.m_as(\"kJ\u22c5mol\u207b\u00b9\")\n            if uncertainty &lt; max_uncertainty:\n                dG0 = standard_dg_prime.value.m_as(\"kJ\u22c5mol\u207b\u00b9\")\n                reaction_dG0s[reaction.id] = dG0\n                if ignore_uncertainty:\n                    reaction_dG0_uncertainties[reaction.id] = 0.0\n                else:\n                    reaction_dG0_uncertainties[reaction.id] = abs(uncertainty)\n\n                print(\n                    f\"No error with reaction {reaction.id}, \u0394G'\u00b0 succesfully calculated!\"\n                )\n            else:\n                print(\n                    f\"INFO: Reaction {reaction.id} uncertainty is too high with {uncertainty} kJ\u22c5mol\u207b\u00b9; \u0394G'\u00b0 not assigned for this reaction\"\n                )\n        elif num_compartments == 2:\n            index_zero = inner_to_outer_compartments.index(\n                unique_reaction_compartments[0]\n            )\n            index_one = inner_to_outer_compartments.index(\n                unique_reaction_compartments[1]\n            )\n\n            if index_one &gt; index_zero:\n                outer_compartment = unique_reaction_compartments[1]\n                inner_compartment = unique_reaction_compartments[0]\n            else:\n                outer_compartment = unique_reaction_compartments[0]\n                inner_compartment = unique_reaction_compartments[1]\n\n            ph_inner = Q_(phs[inner_compartment])\n            ph_outer = Q_(phs[outer_compartment])\n            ionic_strength_inner = Q_(str(ionic_strengths[inner_compartment]) + \" mM\")\n            ionic_strength_outer = Q_(str(ionic_strengths[outer_compartment]) + \" mM\")\n            pmg_inner = Q_(pmgs[inner_compartment])\n            pmg_outer = Q_(pmgs[outer_compartment])\n\n            if (inner_compartment, outer_compartment) in potential_differences:\n                potential_difference = Q_(\n                    str(potential_differences[(inner_compartment, outer_compartment)])\n                    + \" V\"\n                )\n            elif (outer_compartment, inner_compartment) in potential_differences:\n                potential_difference = Q_(\n                    str(potential_differences[(outer_compartment, inner_compartment)])\n                    + \" V\"\n                )\n            else:\n                print(\"ERROR\")\n                continue\n\n            inner_reaction_dict: dict[str, float] = {}\n            outer_reaction_dict: dict[str, float] = {}\n            for i in range(len(stoichiometries)):\n                key = identifiers[i]\n                stoichiometry = stoichiometries[i]\n                try:\n                    compound_key = cc.get_compound(key)\n                except Exception:  # sqlalchemy.orm.exc.MultipleResultsFound\n                    print(\"ERROR\")\n                    continue\n\n                if compound_key is None:\n                    print(\"NONE in compound\")\n                    continue\n\n                if compartments[i] == inner_compartment:\n                    inner_reaction_dict[compound_key] = stoichiometry\n                else:\n                    outer_reaction_dict[compound_key] = stoichiometry\n\n            cc_inner_reaction = Reaction(inner_reaction_dict)\n            cc_outer_reaction = Reaction(outer_reaction_dict)\n\n            cc.p_h = ph_inner\n            cc.ionic_strength = ionic_strength_inner\n            cc.p_mg = pmg_inner\n            try:\n                standard_dg_prime = cc.multicompartmental_standard_dg_prime(\n                    cc_inner_reaction,\n                    cc_outer_reaction,\n                    e_potential_difference=potential_difference,\n                    p_h_outer=ph_outer,\n                    p_mg_outer=pmg_outer,\n                    ionic_strength_outer=ionic_strength_outer,\n                )\n                uncertainty = standard_dg_prime.error.m_as(\"kJ\u22c5mol\u207b\u00b9\")\n                if uncertainty &lt; max_uncertainty:\n                    dG0 = standard_dg_prime.value.m_as(\"kJ\u22c5mol\u207b\u00b9\")\n                    reaction_dG0s[reaction.id] = dG0\n                    if ignore_uncertainty:\n                        reaction_dG0_uncertainties[reaction.id] = 0.0\n                    else:\n                        reaction_dG0_uncertainties[reaction.id] = abs(uncertainty)\n            except ValueError:\n                print(\"ERROR: Multi-compartmental reaction is not balanced\")\n                continue\n        else:\n            print(\"ERROR: More than two compartments are not possible\")\n            continue\n\n    return reaction_dG0s, reaction_dG0_uncertainties\n</code></pre>"},{"location":"api.html#cobrak.evolution","title":"<code>evolution</code>","text":"<p>Includes functions for calling COBRA-k's genetic algorithm for global NLP-based optimization.</p> <p>The actual genetic algorithm can be found in the module 'genetic'.</p>"},{"location":"api.html#cobrak.evolution.COBRAKProblem","title":"<code>COBRAKProblem</code>","text":"<p>Represents a problem to be solved using evolutionary optimization techniques.</p> <p>Parameters:</p> Name Type Description Default <code>cobrak_model</code> <code>Model</code> <p>The original COBRA-k model to optimize.</p> required <code>objective_target</code> <code>dict[str, float]</code> <p>The target values for the objectives.</p> required <code>objective_sense</code> <code>int</code> <p>The sense of the objective function (1 for maximization, -1 for minimization).</p> required <code>variability_dict</code> <code>dict[str, tuple[float, float]]</code> <p>The variability data for each reaction.</p> required <code>nlp_dict_list</code> <code>list[dict[str, float]]</code> <p>A list of initial NLP solutions.</p> required <code>best_value</code> <code>float</code> <p>The best value found so far.</p> required <code>with_kappa</code> <code>bool</code> <p>Whether to use kappa parameter. Defaults to True.</p> <code>True</code> <code>with_gamma</code> <code>bool</code> <p>Whether to use gamma parameter. Defaults to True.</p> <code>True</code> <code>with_iota</code> <code>bool</code> <p>Whether to use iota parameter. Defaults to True.</p> <code>True</code> <code>with_alpha</code> <code>bool</code> <p>Whether to use alpha parameter. Defaults to True.</p> <code>True</code> <code>num_gens</code> <code>int</code> <p>The number of generations in the evolutionary algorithm. Defaults to 5.</p> <code>5</code> <code>algorithm</code> <code>Literal['genetic']</code> <p>The type of optimization algorithm to use. Defaults to \"genetic\", the only available algorithm right now.</p> <code>'genetic'</code> <code>lp_solver</code> <code>Solver</code> <p>The linear programming solver to use. Defaults to SCIP.</p> <code>SCIP</code> <code>nlp_solver</code> <code>Solver</code> <p>The nonlinear programming solver to use. Defaults to IPOPT.</p> <code>IPOPT</code> <code>objvalue_json_path</code> <code>str</code> <p>The path to the JSON file for storing objective values. Defaults to \"\".</p> <code>''</code> <code>max_rounds_same_objvalue</code> <code>float</code> <p>The maximum number of rounds with the same objective value before stopping. Defaults to float(\"inf\").</p> <code>float('inf')</code> <code>correction_config</code> <code>CorrectionConfig</code> <p>Configuration for corrections during optimization. Defaults to CorrectionConfig().</p> <code>CorrectionConfig()</code> <code>min_abs_objvalue</code> <code>float</code> <p>The minimum absolute value of the objective function to consider as valid. Defaults to 1e-6.</p> <code>1e-06</code> <code>pop_size</code> <code>int | None</code> <p>The population size for the evolutionary algorithm. Defaults to None.</p> <code>None</code> <code>ignore_nonlinear_extra_terms_in_ectfbas</code> <code>bool</code> <p>(bool, optional): Whether or not non-linear watches/constraints shall be ignored in ecTFBAs. Defaults to True.</p> <code>True</code> <p>Attributes:</p> Name Type Description <code>original_cobrak_model</code> <code>Model</code> <p>A deep copy of the original COBRA-k model.</p> <code>blocked_reacs</code> <code>list[str]</code> <p>List of blocked reactions.</p> <code>initial_xs_list</code> <code>list[list[int | float]]</code> <p>Initial list of solutions for each NLP.</p> <code>minimal_xs_dict</code> <code>dict[float, list[float]]</code> <p>Dictionary to store minimal solutions.</p> <code>variability_data</code> <code>dict[str, tuple[float, float]]</code> <p>A deep copy of the variability data.</p> <code>idx_to_reac_ids</code> <code>dict[int, tuple[str, ...]]</code> <p>Mapping from index to reaction IDs.</p> <code>dim</code> <code>int</code> <p>The dimension of the problem.</p> <code>lp_solver</code> <code>Solver</code> <p>The linear programming solver.</p> <code>nlp_solver</code> <code>Solver</code> <p>The nonlinear programming solver.</p> <code>temp_directory_name</code> <code>str</code> <p>Name of the temporary directory for storing results.</p> <code>best_value</code> <code>float</code> <p>The best value found so far.</p> <code>objvalue_json_path</code> <code>str</code> <p>Path to the JSON file for objective values.</p> <code>max_rounds_same_objvalue</code> <code>float</code> <p>Maximum number of rounds with same objective value.</p> <code>correction_config</code> <code>CorrectionConfig</code> <p>Configuration for corrections.</p> <code>min_abs_objvalue</code> <code>float</code> <p>Minimum absolute value of objective function to consider valid.</p> Source code in <code>cobrak/evolution.py</code> <pre><code>class COBRAKProblem:\n    \"\"\"Represents a problem to be solved using evolutionary optimization techniques.\n\n    Args:\n        cobrak_model (Model): The original COBRA-k model to optimize.\n        objective_target (dict[str, float]): The target values for the objectives.\n        objective_sense (int): The sense of the objective function (1 for maximization, -1 for minimization).\n        variability_dict (dict[str, tuple[float, float]]): The variability data for each reaction.\n        nlp_dict_list (list[dict[str, float]]): A list of initial NLP solutions.\n        best_value (float): The best value found so far.\n        with_kappa (bool, optional): Whether to use kappa parameter. Defaults to True.\n        with_gamma (bool, optional): Whether to use gamma parameter. Defaults to True.\n        with_iota (bool, optional): Whether to use iota parameter. Defaults to True.\n        with_alpha (bool, optional): Whether to use alpha parameter. Defaults to True.\n        num_gens (int, optional): The number of generations in the evolutionary algorithm. Defaults to 5.\n        algorithm (Literal[\"genetic\"], optional): The type of optimization algorithm to use. Defaults to \"genetic\", the only available algorithm right now.\n        lp_solver (Solver, optional): The linear programming solver to use. Defaults to SCIP.\n        nlp_solver (Solver, optional): The nonlinear programming solver to use. Defaults to IPOPT.\n        objvalue_json_path (str, optional): The path to the JSON file for storing objective values. Defaults to \"\".\n        max_rounds_same_objvalue (float, optional): The maximum number of rounds with the same objective value before stopping. Defaults to float(\"inf\").\n        correction_config (CorrectionConfig, optional): Configuration for corrections during optimization. Defaults to CorrectionConfig().\n        min_abs_objvalue (float, optional): The minimum absolute value of the objective function to consider as valid. Defaults to 1e-6.\n        pop_size (int | None, optional): The population size for the evolutionary algorithm. Defaults to None.\n        ignore_nonlinear_extra_terms_in_ectfbas: (bool, optional): Whether or not non-linear watches/constraints shall be ignored in ecTFBAs. Defaults to True.\n\n    Attributes:\n        original_cobrak_model (Model): A deep copy of the original COBRA-k model.\n        blocked_reacs (list[str]): List of blocked reactions.\n        initial_xs_list (list[list[int | float]]): Initial list of solutions for each NLP.\n        minimal_xs_dict (dict[float, list[float]]): Dictionary to store minimal solutions.\n        variability_data (dict[str, tuple[float, float]]): A deep copy of the variability data.\n        idx_to_reac_ids (dict[int, tuple[str, ...]]): Mapping from index to reaction IDs.\n        dim (int): The dimension of the problem.\n        lp_solver (Solver): The linear programming solver.\n        nlp_solver (Solver): The nonlinear programming solver.\n        temp_directory_name (str): Name of the temporary directory for storing results.\n        best_value (float): The best value found so far.\n        objvalue_json_path (str): Path to the JSON file for objective values.\n        max_rounds_same_objvalue (float): Maximum number of rounds with same objective value.\n        correction_config (CorrectionConfig): Configuration for corrections.\n        min_abs_objvalue (float): Minimum absolute value of objective function to consider valid.\n    \"\"\"\n\n    def __init__(\n        self,\n        cobrak_model: Model,\n        objective_target: dict[str, float],\n        objective_sense: int,\n        variability_dict: dict[str, tuple[float, float]],\n        nlp_dict_list: list[dict[str, float]],\n        best_value: float,\n        with_kappa: bool = True,\n        with_gamma: bool = True,\n        with_iota: bool = True,\n        with_alpha: bool = True,\n        num_gens: int = 5,\n        algorithm: Literal[\"genetic\"] = \"genetic\",\n        lp_solver: Solver = SCIP,\n        nlp_solver: Solver = IPOPT,\n        nlp_strict_mode: bool = False,\n        nlp_single_strict_reacs: list[str] = [],\n        objvalue_json_path: str = \"\",\n        max_rounds_same_objvalue: float = float(\"inf\"),\n        correction_config: CorrectionConfig = CorrectionConfig(),\n        min_abs_objvalue: float = 1e-6,\n        pop_size: int | None = None,\n        ignore_nonlinear_extra_terms_in_ectfbas: bool = True,\n    ) -&gt; None:\n        \"\"\"Initializes a COBRAKProblem object.\n\n        Args:\n            cobrak_model (Model): The original COBRA-k model to optimize.\n            objective_target (dict[str, float]): The target values for the objectives.\n            objective_sense (int): The sense of the objective function (1 for maximization, -1 for minimization).\n            variability_dict (dict[str, tuple[float, float]]): The variability data for each reaction.\n            nlp_dict_list (list[dict[str, float]]): A list of initial NLP solutions.\n            best_value (float): The best value found so far.\n            with_kappa (bool, optional): Whether to use kappa parameter. Defaults to True.\n            with_gamma (bool, optional): Whether to use gamma parameter. Defaults to True.\n            with_iota (bool, optional): Whether to use iota parameter. Defaults to True.\n            with_alpha (bool, optional): Whether to use alpha parameter. Defaults to True.\n            num_gens (int, optional): The number of generations in the evolutionary algorithm. Defaults to 5.\n            algorithm (Literal[\"genetic\"], optional): The type of optimization algorithm to use. Defaults to \"genetic\", the only algorithm currently available.\n            lp_solver (Solver, optional): The linear programming solver to use. Defaults to SCIP.\n            nlp_solver (Solver, optional): The nonlinear programming solver to use. Defaults to IPOPT.\n            nlp_strict_mode (bool, optional): Whether or not the &lt;= heuristic (True) or not (False; i.e. setting all equations to ==) shall be used. Defaults to False.\n            nlp_single_strict_reacs (list[str], optional): List of single reactions that shall be in strict mode (see ```nlp_strict_mode```argument above).\n                If ```nlp_strict_mode=True```, this has no effect. Defaults to [].\n            objvalue_json_path (str, optional): The path to the JSON file for storing objective values. Defaults to \"\".\n            max_rounds_same_objvalue (float, optional): The maximum number of rounds with the same objective value before stopping. Defaults to float(\"inf\").\n            correction_config (CorrectionConfig, optional): Configuration for corrections during optimization. Defaults to CorrectionConfig().\n            min_abs_objvalue (float, optional): The minimum absolute value of the objective function to consider as valid. Defaults to 1e-6.\n            pop_size (int | None, optional): The population size for the evolutionary algorithm. Defaults to None.\n            ignore_nonlinear_extra_terms_in_ectfbas: (bool, optional): Whether or not non-linear watches/constraints shall be ignored in ecTFBAs. Defaults to True.\n        \"\"\"\n        self.original_cobrak_model: Model = deepcopy(cobrak_model)\n        self.objective_target = objective_target\n        self.objective_sense = objective_sense\n        self.blocked_reacs: list[str] = []\n        self.initial_xs_list: list[list[int | float]] = [\n            [] for _ in range(len(nlp_dict_list))\n        ]\n        self.minimal_xs_dict: dict[float, list[float]] = {}\n        self.variability_data = deepcopy(variability_dict)\n        self.algorithm = algorithm\n\n        reac_couples = get_stoichiometrically_coupled_reactions(\n            self.original_cobrak_model\n        )\n\n        objective_target_ids = list(objective_target.keys())\n        filtered_reac_couples: list[tuple[str, ...]] = []\n        for reac_couple in reac_couples:\n            filtered_reac_couple = [\n                reac_id\n                for reac_id in reac_couple\n                if (abs(self.variability_data[reac_id][1]) &gt; 0.0)\n                and (abs(self.variability_data[reac_id][0]) &lt;= 0.0)\n                and not (\n                    cobrak_model.reactions[reac_id].dG0 is None\n                    and cobrak_model.reactions[reac_id].enzyme_reaction_data is None\n                )\n            ]\n\n            found_invalid_id = False\n            for objective_target_id in objective_target_ids:\n                if objective_target_id in filtered_reac_couple:\n                    found_invalid_id = True\n            for var_id in correction_config.error_scenario:\n                if var_id in filtered_reac_couple:\n                    found_invalid_id = True\n\n            if found_invalid_id:\n                continue\n\n            if len(filtered_reac_couple) &gt; 0:\n                filtered_reac_couples.append(tuple(filtered_reac_couple))\n\n        self.idx_to_reac_ids: dict[int, tuple[str, ...]] = {}\n        couple_idx = 0\n        for filtered_reac_couplex in filtered_reac_couples:\n            nlp_idx = 0\n            for nlp_dict in nlp_dict_list:\n                first_reac_id = filtered_reac_couplex[0]\n                if (first_reac_id in nlp_dict) and (nlp_dict[first_reac_id] &gt; 0.0):\n                    self.initial_xs_list[nlp_idx].append(\n                        1.0 if algorithm != \"genetic\" else 1\n                    )\n                else:\n                    self.initial_xs_list[nlp_idx].append(\n                        0.0 if algorithm != \"genetic\" else 0\n                    )\n\n                nlp_idx += 1  # noqa: SIM113\n\n            self.idx_to_reac_ids[couple_idx] = filtered_reac_couplex\n            couple_idx += 1\n\n        self.with_kappa = with_kappa\n        self.with_gamma = with_gamma\n        self.with_iota = with_iota\n        self.with_alpha = with_alpha\n        self.dim = couple_idx\n        self.num_gens = num_gens\n        self.lp_solver = lp_solver\n        self.nlp_solver = nlp_solver\n        self.nlp_strict_mode = nlp_strict_mode\n        self.nlp_single_strict_reacs = nlp_single_strict_reacs\n        self.temp_directory_name = \"\"\n        self.best_value = best_value\n        self.objvalue_json_path = objvalue_json_path\n        self.max_rounds_same_objvalue = max_rounds_same_objvalue\n        self.correction_config = correction_config\n        self.min_abs_objvalue = min_abs_objvalue\n        self.pop_size = pop_size\n        self.ignore_nonlinear_extra_terms_in_ectfbas = (\n            ignore_nonlinear_extra_terms_in_ectfbas\n        )\n\n    def fitness(\n        self,\n        x: list[float | int],\n    ) -&gt; list[tuple[float, list[float | int]]]:\n        \"\"\"Calculates the fitness of a given solution.\n\n        Args:\n            x (list[float | int]): The solution to evaluate.\n\n        Returns:\n            list[tuple[float, list[float | int]]]: A list of tuples, where each tuple contains the fitness value and the corresponding solution.\n        \"\"\"\n        # Preliminary TFBA :3\n        deactivated_reactions: list[str] = []\n        for couple_idx, reac_ids in self.idx_to_reac_ids.items():\n            if x[couple_idx] &lt;= 0.02:\n                deactivated_reactions.extend(reac_ids)\n\n        try:\n            first_ectfba_dict = perform_lp_optimization(\n                cobrak_model=self.original_cobrak_model,\n                objective_target=self.objective_target,\n                objective_sense=self.objective_sense,\n                with_enzyme_constraints=True,\n                with_thermodynamic_constraints=True,\n                with_loop_constraints=True,\n                variability_dict=deepcopy(self.variability_data),\n                ignored_reacs=deactivated_reactions,\n                solver=self.lp_solver,\n                correction_config=self.correction_config,\n                ignore_nonlinear_terms=self.ignore_nonlinear_extra_terms_in_ectfbas,\n            )\n        except (ApplicationError, AttributeError, ValueError):\n            first_ectfba_dict = {ALL_OK_KEY: False}\n        if not first_ectfba_dict[ALL_OK_KEY]:\n            return [(1_000_000.0, [])]\n\n        nlp_results: list[dict[str, float]] = []\n\n        if is_objsense_maximization(self.objective_sense):\n            lower_value = first_ectfba_dict[OBJECTIVE_VAR_NAME] - 1e-12\n            upper_value = None\n        else:\n            lower_value = None\n            upper_value = first_ectfba_dict[OBJECTIVE_VAR_NAME] + 1e-12\n\n        maxz_model = deepcopy(self.original_cobrak_model)\n        maxz_model.extra_linear_constraints = [\n            ExtraLinearConstraint(\n                stoichiometries=self.objective_target,\n                lower_value=lower_value,\n                upper_value=upper_value,\n            )\n        ]\n        maxz_model.extra_linear_constraints += [\n            ExtraLinearConstraint(\n                stoichiometries={f\"{Z_VAR_PREFIX}{reac_id}\": 1.0},\n                upper_value=0.0,\n            )\n            for (reac_id, reac_data) in self.original_cobrak_model.reactions.items()\n            if (reac_data.dG0 is not None) and (reac_id in deactivated_reactions)\n        ]\n        eligible_z_sum_objective = {\n            f\"{Z_VAR_PREFIX}{reac_id}\": 1.0\n            for (reac_id, reac_data) in self.original_cobrak_model.reactions.items()\n            if (reac_data.dG0 is not None)\n            and (self.variability_data[reac_id][1] &gt; 0.0)\n            and (reac_id not in deactivated_reactions)\n        }\n        try:\n            maxz_ectfba_dict = perform_lp_optimization(\n                cobrak_model=maxz_model,\n                objective_target=eligible_z_sum_objective,\n                objective_sense=+1,\n                with_enzyme_constraints=True,\n                with_thermodynamic_constraints=True,\n                with_loop_constraints=True,\n                variability_dict=deepcopy(self.variability_data),\n                ignored_reacs=deactivated_reactions,\n                solver=self.lp_solver,\n                correction_config=self.correction_config,\n                ignore_nonlinear_terms=self.ignore_nonlinear_extra_terms_in_ectfbas,\n            )\n        except (ApplicationError, AttributeError, ValueError):\n            maxz_ectfba_dict = {ALL_OK_KEY: False}\n        if maxz_ectfba_dict[ALL_OK_KEY]:\n            used_maxz_tfba_dict: dict[str, float] = {}\n            for var_id in maxz_ectfba_dict:\n                if var_id not in self.original_cobrak_model.reactions:\n                    continue\n                reaction = self.original_cobrak_model.reactions[var_id]\n                if (\n                    (reaction.dG0 is None) and (var_id not in deactivated_reactions)\n                ) or (\n                    (reaction.dG0 is not None)\n                    and (maxz_ectfba_dict[f\"{Z_VAR_PREFIX}{var_id}\"] &gt; 0.0)\n                ):\n                    used_maxz_tfba_dict[var_id] = 1.0\n                else:\n                    used_maxz_tfba_dict[var_id] = 0.0\n\n            used_maxz_tfba_dict[ALL_OK_KEY] = True\n\n            if used_maxz_tfba_dict[ALL_OK_KEY]:\n                try:\n                    second_nlp_dict = (\n                        perform_nlp_irreversible_optimization_with_active_reacs_only(\n                            cobrak_model=self.original_cobrak_model,\n                            objective_target=self.objective_target,\n                            objective_sense=self.objective_sense,\n                            optimization_dict=deepcopy(used_maxz_tfba_dict),\n                            variability_dict=deepcopy(self.variability_data),\n                            with_kappa=self.with_kappa,\n                            with_gamma=self.with_gamma,\n                            with_iota=self.with_iota,\n                            with_alpha=self.with_alpha,\n                            solver=self.nlp_solver,\n                            correction_config=self.correction_config,\n                            strict_mode=self.nlp_strict_mode,\n                            single_strict_reacs=self.nlp_single_strict_reacs,\n                        )\n                    )\n                    if second_nlp_dict[ALL_OK_KEY] and (\n                        abs(second_nlp_dict[OBJECTIVE_VAR_NAME]) &gt; self.min_abs_objvalue\n                    ):\n                        nlp_results.append(second_nlp_dict)\n                except (ApplicationError, AttributeError, ValueError):\n                    pass\n\n        ####\n        try:\n            minz_ectfba_dict = perform_lp_optimization(\n                cobrak_model=maxz_model,\n                objective_target=eligible_z_sum_objective,\n                objective_sense=-1,\n                with_enzyme_constraints=True,\n                with_thermodynamic_constraints=True,\n                with_loop_constraints=True,\n                variability_dict=deepcopy(self.variability_data),\n                ignored_reacs=deactivated_reactions,\n                solver=self.lp_solver,\n                correction_config=self.correction_config,\n                ignore_nonlinear_terms=self.ignore_nonlinear_extra_terms_in_ectfbas,\n            )\n        except (ApplicationError, AttributeError, ValueError):\n            minz_ectfba_dict = {ALL_OK_KEY: False}\n        if minz_ectfba_dict[ALL_OK_KEY]:\n            used_minz_tfba_dict: dict[str, float] = {}\n            for var_id in minz_ectfba_dict:\n                if var_id not in self.original_cobrak_model.reactions:\n                    continue\n                reaction = self.original_cobrak_model.reactions[var_id]\n                if (\n                    (reaction.dG0 is None) and (var_id not in deactivated_reactions)\n                ) or (\n                    (reaction.dG0 is not None)\n                    and (minz_ectfba_dict[f\"{Z_VAR_PREFIX}{var_id}\"] &gt; 0.0)\n                ):\n                    used_minz_tfba_dict[var_id] = 1.0\n                else:\n                    used_minz_tfba_dict[var_id] = 0.0\n\n            used_minz_tfba_dict[ALL_OK_KEY] = True\n\n            if used_minz_tfba_dict[ALL_OK_KEY]:\n                try:\n                    third_nlp_dict = (\n                        perform_nlp_irreversible_optimization_with_active_reacs_only(\n                            cobrak_model=self.original_cobrak_model,\n                            objective_target=self.objective_target,\n                            objective_sense=self.objective_sense,\n                            optimization_dict=deepcopy(used_minz_tfba_dict),\n                            variability_dict=deepcopy(self.variability_data),\n                            with_kappa=self.with_kappa,\n                            with_gamma=self.with_gamma,\n                            with_iota=self.with_iota,\n                            with_alpha=self.with_alpha,\n                            solver=self.nlp_solver,\n                            correction_config=self.correction_config,\n                            strict_mode=self.nlp_strict_mode,\n                            single_strict_reacs=self.nlp_single_strict_reacs,\n                        )\n                    )\n                    if third_nlp_dict[ALL_OK_KEY] and (\n                        abs(third_nlp_dict[OBJECTIVE_VAR_NAME]) &gt; self.min_abs_objvalue\n                    ):\n                        nlp_results.append(third_nlp_dict)\n                except (ApplicationError, AttributeError, ValueError):\n                    pass\n        ####\n\n        output: list[tuple[float, list[float | int]]] = [(1_000_000, [])]\n        for nlp_result in nlp_results:\n            objvalues = [nlp_result[OBJECTIVE_VAR_NAME] for nlp_result in nlp_results]\n            if is_objsense_maximization(self.objective_sense):\n                opt_idx = objvalues.index(max(objvalues))\n            else:\n                opt_idx = objvalues.index(min(objvalues))\n            opt_nlp_dict = nlp_results[opt_idx]\n\n            objective_value = opt_nlp_dict[OBJECTIVE_VAR_NAME]\n\n            if self.temp_directory_name:\n                filename = f\"{self.temp_directory_name}{objective_value}{time()}{randint(0, 1_000_000_000)}.json\"  # noqa: NPY002\n                json_write(filename, opt_nlp_dict)\n\n            if is_objsense_maximization(self.objective_sense):\n                objective_value *= -1\n\n            print(\"No error, objective value is:\", objective_value)\n\n            active_nlp_x: list[float | int] = [\n                0 for _ in range(len(list(self.idx_to_reac_ids.keys())))\n            ]\n            for couple_idx, reac_ids in self.idx_to_reac_ids.items():\n                reac_id = reac_ids[0]\n                if reac_id not in opt_nlp_dict or opt_nlp_dict[reac_id] &lt; 1e-11:\n                    set_value = 0\n                else:\n                    set_value = 1\n                active_nlp_x[couple_idx] = set_value\n            output.append((objective_value, active_nlp_x))\n\n        return output\n\n    def optimize(self) -&gt; dict[float, list[dict[str, float]]]:\n        \"\"\"Performs the optimization process.\n\n        Returns:\n            dict[float, list[dict[str, float]]]: A dictionary containing the optimization results.\n        \"\"\"\n        temp_directory = TemporaryDirectory()\n        self.temp_directory_name = standardize_folder(temp_directory.name)\n\n        match self.algorithm:\n            case \"genetic\":\n                evolution = COBRAKGENETIC(\n                    fitness_function=self.fitness,\n                    xs_dim=self.dim,\n                    extra_xs=self.initial_xs_list,\n                    gen=self.num_gens,\n                    objvalue_json_path=self.objvalue_json_path,\n                    max_rounds_same_objvalue=self.max_rounds_same_objvalue,\n                    pop_size=self.pop_size,\n                )\n            case _:\n                print(\n                    f\"ERROR: Evolution algorithm {self.algorithm} does not exist! Use 'genetic'.\"\n                )\n                raise ValueError\n        evolution.run()\n\n        result_dict: dict[float, list[dict[str, float]]] = {}\n        for json_filename in get_files(self.temp_directory_name):\n            json_data = json_load(f\"{self.temp_directory_name}{json_filename}\", Any)\n            objective_value = json_data[OBJECTIVE_VAR_NAME]\n            if objective_value not in result_dict:\n                result_dict[objective_value] = []\n            result_dict[objective_value].append(deepcopy(json_data))\n\n        temp_directory.cleanup()\n\n        return {\n            key: result_dict[key] for key in sorted(result_dict.keys(), reverse=True)\n        }\n</code></pre>"},{"location":"api.html#cobrak.evolution.COBRAKProblem.__init__","title":"<code>__init__(cobrak_model, objective_target, objective_sense, variability_dict, nlp_dict_list, best_value, with_kappa=True, with_gamma=True, with_iota=True, with_alpha=True, num_gens=5, algorithm='genetic', lp_solver=SCIP, nlp_solver=IPOPT, nlp_strict_mode=False, nlp_single_strict_reacs=[], objvalue_json_path='', max_rounds_same_objvalue=float('inf'), correction_config=CorrectionConfig(), min_abs_objvalue=1e-06, pop_size=None, ignore_nonlinear_extra_terms_in_ectfbas=True)</code>","text":"<p>Initializes a COBRAKProblem object.</p> <p>Parameters:</p> Name Type Description Default <code>cobrak_model</code> <code>Model</code> <p>The original COBRA-k model to optimize.</p> required <code>objective_target</code> <code>dict[str, float]</code> <p>The target values for the objectives.</p> required <code>objective_sense</code> <code>int</code> <p>The sense of the objective function (1 for maximization, -1 for minimization).</p> required <code>variability_dict</code> <code>dict[str, tuple[float, float]]</code> <p>The variability data for each reaction.</p> required <code>nlp_dict_list</code> <code>list[dict[str, float]]</code> <p>A list of initial NLP solutions.</p> required <code>best_value</code> <code>float</code> <p>The best value found so far.</p> required <code>with_kappa</code> <code>bool</code> <p>Whether to use kappa parameter. Defaults to True.</p> <code>True</code> <code>with_gamma</code> <code>bool</code> <p>Whether to use gamma parameter. Defaults to True.</p> <code>True</code> <code>with_iota</code> <code>bool</code> <p>Whether to use iota parameter. Defaults to True.</p> <code>True</code> <code>with_alpha</code> <code>bool</code> <p>Whether to use alpha parameter. Defaults to True.</p> <code>True</code> <code>num_gens</code> <code>int</code> <p>The number of generations in the evolutionary algorithm. Defaults to 5.</p> <code>5</code> <code>algorithm</code> <code>Literal['genetic']</code> <p>The type of optimization algorithm to use. Defaults to \"genetic\", the only algorithm currently available.</p> <code>'genetic'</code> <code>lp_solver</code> <code>Solver</code> <p>The linear programming solver to use. Defaults to SCIP.</p> <code>SCIP</code> <code>nlp_solver</code> <code>Solver</code> <p>The nonlinear programming solver to use. Defaults to IPOPT.</p> <code>IPOPT</code> <code>nlp_strict_mode</code> <code>bool</code> <p>Whether or not the &lt;= heuristic (True) or not (False; i.e. setting all equations to ==) shall be used. Defaults to False.</p> <code>False</code> <code>nlp_single_strict_reacs</code> <code>list[str]</code> <p>List of single reactions that shall be in strict mode (see <code>nlp_strict_mode</code>argument above). If <code>nlp_strict_mode=True</code>, this has no effect. Defaults to [].</p> <code>[]</code> <code>objvalue_json_path</code> <code>str</code> <p>The path to the JSON file for storing objective values. Defaults to \"\".</p> <code>''</code> <code>max_rounds_same_objvalue</code> <code>float</code> <p>The maximum number of rounds with the same objective value before stopping. Defaults to float(\"inf\").</p> <code>float('inf')</code> <code>correction_config</code> <code>CorrectionConfig</code> <p>Configuration for corrections during optimization. Defaults to CorrectionConfig().</p> <code>CorrectionConfig()</code> <code>min_abs_objvalue</code> <code>float</code> <p>The minimum absolute value of the objective function to consider as valid. Defaults to 1e-6.</p> <code>1e-06</code> <code>pop_size</code> <code>int | None</code> <p>The population size for the evolutionary algorithm. Defaults to None.</p> <code>None</code> <code>ignore_nonlinear_extra_terms_in_ectfbas</code> <code>bool</code> <p>(bool, optional): Whether or not non-linear watches/constraints shall be ignored in ecTFBAs. Defaults to True.</p> <code>True</code> Source code in <code>cobrak/evolution.py</code> <pre><code>def __init__(\n    self,\n    cobrak_model: Model,\n    objective_target: dict[str, float],\n    objective_sense: int,\n    variability_dict: dict[str, tuple[float, float]],\n    nlp_dict_list: list[dict[str, float]],\n    best_value: float,\n    with_kappa: bool = True,\n    with_gamma: bool = True,\n    with_iota: bool = True,\n    with_alpha: bool = True,\n    num_gens: int = 5,\n    algorithm: Literal[\"genetic\"] = \"genetic\",\n    lp_solver: Solver = SCIP,\n    nlp_solver: Solver = IPOPT,\n    nlp_strict_mode: bool = False,\n    nlp_single_strict_reacs: list[str] = [],\n    objvalue_json_path: str = \"\",\n    max_rounds_same_objvalue: float = float(\"inf\"),\n    correction_config: CorrectionConfig = CorrectionConfig(),\n    min_abs_objvalue: float = 1e-6,\n    pop_size: int | None = None,\n    ignore_nonlinear_extra_terms_in_ectfbas: bool = True,\n) -&gt; None:\n    \"\"\"Initializes a COBRAKProblem object.\n\n    Args:\n        cobrak_model (Model): The original COBRA-k model to optimize.\n        objective_target (dict[str, float]): The target values for the objectives.\n        objective_sense (int): The sense of the objective function (1 for maximization, -1 for minimization).\n        variability_dict (dict[str, tuple[float, float]]): The variability data for each reaction.\n        nlp_dict_list (list[dict[str, float]]): A list of initial NLP solutions.\n        best_value (float): The best value found so far.\n        with_kappa (bool, optional): Whether to use kappa parameter. Defaults to True.\n        with_gamma (bool, optional): Whether to use gamma parameter. Defaults to True.\n        with_iota (bool, optional): Whether to use iota parameter. Defaults to True.\n        with_alpha (bool, optional): Whether to use alpha parameter. Defaults to True.\n        num_gens (int, optional): The number of generations in the evolutionary algorithm. Defaults to 5.\n        algorithm (Literal[\"genetic\"], optional): The type of optimization algorithm to use. Defaults to \"genetic\", the only algorithm currently available.\n        lp_solver (Solver, optional): The linear programming solver to use. Defaults to SCIP.\n        nlp_solver (Solver, optional): The nonlinear programming solver to use. Defaults to IPOPT.\n        nlp_strict_mode (bool, optional): Whether or not the &lt;= heuristic (True) or not (False; i.e. setting all equations to ==) shall be used. Defaults to False.\n        nlp_single_strict_reacs (list[str], optional): List of single reactions that shall be in strict mode (see ```nlp_strict_mode```argument above).\n            If ```nlp_strict_mode=True```, this has no effect. Defaults to [].\n        objvalue_json_path (str, optional): The path to the JSON file for storing objective values. Defaults to \"\".\n        max_rounds_same_objvalue (float, optional): The maximum number of rounds with the same objective value before stopping. Defaults to float(\"inf\").\n        correction_config (CorrectionConfig, optional): Configuration for corrections during optimization. Defaults to CorrectionConfig().\n        min_abs_objvalue (float, optional): The minimum absolute value of the objective function to consider as valid. Defaults to 1e-6.\n        pop_size (int | None, optional): The population size for the evolutionary algorithm. Defaults to None.\n        ignore_nonlinear_extra_terms_in_ectfbas: (bool, optional): Whether or not non-linear watches/constraints shall be ignored in ecTFBAs. Defaults to True.\n    \"\"\"\n    self.original_cobrak_model: Model = deepcopy(cobrak_model)\n    self.objective_target = objective_target\n    self.objective_sense = objective_sense\n    self.blocked_reacs: list[str] = []\n    self.initial_xs_list: list[list[int | float]] = [\n        [] for _ in range(len(nlp_dict_list))\n    ]\n    self.minimal_xs_dict: dict[float, list[float]] = {}\n    self.variability_data = deepcopy(variability_dict)\n    self.algorithm = algorithm\n\n    reac_couples = get_stoichiometrically_coupled_reactions(\n        self.original_cobrak_model\n    )\n\n    objective_target_ids = list(objective_target.keys())\n    filtered_reac_couples: list[tuple[str, ...]] = []\n    for reac_couple in reac_couples:\n        filtered_reac_couple = [\n            reac_id\n            for reac_id in reac_couple\n            if (abs(self.variability_data[reac_id][1]) &gt; 0.0)\n            and (abs(self.variability_data[reac_id][0]) &lt;= 0.0)\n            and not (\n                cobrak_model.reactions[reac_id].dG0 is None\n                and cobrak_model.reactions[reac_id].enzyme_reaction_data is None\n            )\n        ]\n\n        found_invalid_id = False\n        for objective_target_id in objective_target_ids:\n            if objective_target_id in filtered_reac_couple:\n                found_invalid_id = True\n        for var_id in correction_config.error_scenario:\n            if var_id in filtered_reac_couple:\n                found_invalid_id = True\n\n        if found_invalid_id:\n            continue\n\n        if len(filtered_reac_couple) &gt; 0:\n            filtered_reac_couples.append(tuple(filtered_reac_couple))\n\n    self.idx_to_reac_ids: dict[int, tuple[str, ...]] = {}\n    couple_idx = 0\n    for filtered_reac_couplex in filtered_reac_couples:\n        nlp_idx = 0\n        for nlp_dict in nlp_dict_list:\n            first_reac_id = filtered_reac_couplex[0]\n            if (first_reac_id in nlp_dict) and (nlp_dict[first_reac_id] &gt; 0.0):\n                self.initial_xs_list[nlp_idx].append(\n                    1.0 if algorithm != \"genetic\" else 1\n                )\n            else:\n                self.initial_xs_list[nlp_idx].append(\n                    0.0 if algorithm != \"genetic\" else 0\n                )\n\n            nlp_idx += 1  # noqa: SIM113\n\n        self.idx_to_reac_ids[couple_idx] = filtered_reac_couplex\n        couple_idx += 1\n\n    self.with_kappa = with_kappa\n    self.with_gamma = with_gamma\n    self.with_iota = with_iota\n    self.with_alpha = with_alpha\n    self.dim = couple_idx\n    self.num_gens = num_gens\n    self.lp_solver = lp_solver\n    self.nlp_solver = nlp_solver\n    self.nlp_strict_mode = nlp_strict_mode\n    self.nlp_single_strict_reacs = nlp_single_strict_reacs\n    self.temp_directory_name = \"\"\n    self.best_value = best_value\n    self.objvalue_json_path = objvalue_json_path\n    self.max_rounds_same_objvalue = max_rounds_same_objvalue\n    self.correction_config = correction_config\n    self.min_abs_objvalue = min_abs_objvalue\n    self.pop_size = pop_size\n    self.ignore_nonlinear_extra_terms_in_ectfbas = (\n        ignore_nonlinear_extra_terms_in_ectfbas\n    )\n</code></pre>"},{"location":"api.html#cobrak.evolution.COBRAKProblem.fitness","title":"<code>fitness(x)</code>","text":"<p>Calculates the fitness of a given solution.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list[float | int]</code> <p>The solution to evaluate.</p> required <p>Returns:</p> Type Description <code>list[tuple[float, list[float | int]]]</code> <p>list[tuple[float, list[float | int]]]: A list of tuples, where each tuple contains the fitness value and the corresponding solution.</p> Source code in <code>cobrak/evolution.py</code> <pre><code>def fitness(\n    self,\n    x: list[float | int],\n) -&gt; list[tuple[float, list[float | int]]]:\n    \"\"\"Calculates the fitness of a given solution.\n\n    Args:\n        x (list[float | int]): The solution to evaluate.\n\n    Returns:\n        list[tuple[float, list[float | int]]]: A list of tuples, where each tuple contains the fitness value and the corresponding solution.\n    \"\"\"\n    # Preliminary TFBA :3\n    deactivated_reactions: list[str] = []\n    for couple_idx, reac_ids in self.idx_to_reac_ids.items():\n        if x[couple_idx] &lt;= 0.02:\n            deactivated_reactions.extend(reac_ids)\n\n    try:\n        first_ectfba_dict = perform_lp_optimization(\n            cobrak_model=self.original_cobrak_model,\n            objective_target=self.objective_target,\n            objective_sense=self.objective_sense,\n            with_enzyme_constraints=True,\n            with_thermodynamic_constraints=True,\n            with_loop_constraints=True,\n            variability_dict=deepcopy(self.variability_data),\n            ignored_reacs=deactivated_reactions,\n            solver=self.lp_solver,\n            correction_config=self.correction_config,\n            ignore_nonlinear_terms=self.ignore_nonlinear_extra_terms_in_ectfbas,\n        )\n    except (ApplicationError, AttributeError, ValueError):\n        first_ectfba_dict = {ALL_OK_KEY: False}\n    if not first_ectfba_dict[ALL_OK_KEY]:\n        return [(1_000_000.0, [])]\n\n    nlp_results: list[dict[str, float]] = []\n\n    if is_objsense_maximization(self.objective_sense):\n        lower_value = first_ectfba_dict[OBJECTIVE_VAR_NAME] - 1e-12\n        upper_value = None\n    else:\n        lower_value = None\n        upper_value = first_ectfba_dict[OBJECTIVE_VAR_NAME] + 1e-12\n\n    maxz_model = deepcopy(self.original_cobrak_model)\n    maxz_model.extra_linear_constraints = [\n        ExtraLinearConstraint(\n            stoichiometries=self.objective_target,\n            lower_value=lower_value,\n            upper_value=upper_value,\n        )\n    ]\n    maxz_model.extra_linear_constraints += [\n        ExtraLinearConstraint(\n            stoichiometries={f\"{Z_VAR_PREFIX}{reac_id}\": 1.0},\n            upper_value=0.0,\n        )\n        for (reac_id, reac_data) in self.original_cobrak_model.reactions.items()\n        if (reac_data.dG0 is not None) and (reac_id in deactivated_reactions)\n    ]\n    eligible_z_sum_objective = {\n        f\"{Z_VAR_PREFIX}{reac_id}\": 1.0\n        for (reac_id, reac_data) in self.original_cobrak_model.reactions.items()\n        if (reac_data.dG0 is not None)\n        and (self.variability_data[reac_id][1] &gt; 0.0)\n        and (reac_id not in deactivated_reactions)\n    }\n    try:\n        maxz_ectfba_dict = perform_lp_optimization(\n            cobrak_model=maxz_model,\n            objective_target=eligible_z_sum_objective,\n            objective_sense=+1,\n            with_enzyme_constraints=True,\n            with_thermodynamic_constraints=True,\n            with_loop_constraints=True,\n            variability_dict=deepcopy(self.variability_data),\n            ignored_reacs=deactivated_reactions,\n            solver=self.lp_solver,\n            correction_config=self.correction_config,\n            ignore_nonlinear_terms=self.ignore_nonlinear_extra_terms_in_ectfbas,\n        )\n    except (ApplicationError, AttributeError, ValueError):\n        maxz_ectfba_dict = {ALL_OK_KEY: False}\n    if maxz_ectfba_dict[ALL_OK_KEY]:\n        used_maxz_tfba_dict: dict[str, float] = {}\n        for var_id in maxz_ectfba_dict:\n            if var_id not in self.original_cobrak_model.reactions:\n                continue\n            reaction = self.original_cobrak_model.reactions[var_id]\n            if (\n                (reaction.dG0 is None) and (var_id not in deactivated_reactions)\n            ) or (\n                (reaction.dG0 is not None)\n                and (maxz_ectfba_dict[f\"{Z_VAR_PREFIX}{var_id}\"] &gt; 0.0)\n            ):\n                used_maxz_tfba_dict[var_id] = 1.0\n            else:\n                used_maxz_tfba_dict[var_id] = 0.0\n\n        used_maxz_tfba_dict[ALL_OK_KEY] = True\n\n        if used_maxz_tfba_dict[ALL_OK_KEY]:\n            try:\n                second_nlp_dict = (\n                    perform_nlp_irreversible_optimization_with_active_reacs_only(\n                        cobrak_model=self.original_cobrak_model,\n                        objective_target=self.objective_target,\n                        objective_sense=self.objective_sense,\n                        optimization_dict=deepcopy(used_maxz_tfba_dict),\n                        variability_dict=deepcopy(self.variability_data),\n                        with_kappa=self.with_kappa,\n                        with_gamma=self.with_gamma,\n                        with_iota=self.with_iota,\n                        with_alpha=self.with_alpha,\n                        solver=self.nlp_solver,\n                        correction_config=self.correction_config,\n                        strict_mode=self.nlp_strict_mode,\n                        single_strict_reacs=self.nlp_single_strict_reacs,\n                    )\n                )\n                if second_nlp_dict[ALL_OK_KEY] and (\n                    abs(second_nlp_dict[OBJECTIVE_VAR_NAME]) &gt; self.min_abs_objvalue\n                ):\n                    nlp_results.append(second_nlp_dict)\n            except (ApplicationError, AttributeError, ValueError):\n                pass\n\n    ####\n    try:\n        minz_ectfba_dict = perform_lp_optimization(\n            cobrak_model=maxz_model,\n            objective_target=eligible_z_sum_objective,\n            objective_sense=-1,\n            with_enzyme_constraints=True,\n            with_thermodynamic_constraints=True,\n            with_loop_constraints=True,\n            variability_dict=deepcopy(self.variability_data),\n            ignored_reacs=deactivated_reactions,\n            solver=self.lp_solver,\n            correction_config=self.correction_config,\n            ignore_nonlinear_terms=self.ignore_nonlinear_extra_terms_in_ectfbas,\n        )\n    except (ApplicationError, AttributeError, ValueError):\n        minz_ectfba_dict = {ALL_OK_KEY: False}\n    if minz_ectfba_dict[ALL_OK_KEY]:\n        used_minz_tfba_dict: dict[str, float] = {}\n        for var_id in minz_ectfba_dict:\n            if var_id not in self.original_cobrak_model.reactions:\n                continue\n            reaction = self.original_cobrak_model.reactions[var_id]\n            if (\n                (reaction.dG0 is None) and (var_id not in deactivated_reactions)\n            ) or (\n                (reaction.dG0 is not None)\n                and (minz_ectfba_dict[f\"{Z_VAR_PREFIX}{var_id}\"] &gt; 0.0)\n            ):\n                used_minz_tfba_dict[var_id] = 1.0\n            else:\n                used_minz_tfba_dict[var_id] = 0.0\n\n        used_minz_tfba_dict[ALL_OK_KEY] = True\n\n        if used_minz_tfba_dict[ALL_OK_KEY]:\n            try:\n                third_nlp_dict = (\n                    perform_nlp_irreversible_optimization_with_active_reacs_only(\n                        cobrak_model=self.original_cobrak_model,\n                        objective_target=self.objective_target,\n                        objective_sense=self.objective_sense,\n                        optimization_dict=deepcopy(used_minz_tfba_dict),\n                        variability_dict=deepcopy(self.variability_data),\n                        with_kappa=self.with_kappa,\n                        with_gamma=self.with_gamma,\n                        with_iota=self.with_iota,\n                        with_alpha=self.with_alpha,\n                        solver=self.nlp_solver,\n                        correction_config=self.correction_config,\n                        strict_mode=self.nlp_strict_mode,\n                        single_strict_reacs=self.nlp_single_strict_reacs,\n                    )\n                )\n                if third_nlp_dict[ALL_OK_KEY] and (\n                    abs(third_nlp_dict[OBJECTIVE_VAR_NAME]) &gt; self.min_abs_objvalue\n                ):\n                    nlp_results.append(third_nlp_dict)\n            except (ApplicationError, AttributeError, ValueError):\n                pass\n    ####\n\n    output: list[tuple[float, list[float | int]]] = [(1_000_000, [])]\n    for nlp_result in nlp_results:\n        objvalues = [nlp_result[OBJECTIVE_VAR_NAME] for nlp_result in nlp_results]\n        if is_objsense_maximization(self.objective_sense):\n            opt_idx = objvalues.index(max(objvalues))\n        else:\n            opt_idx = objvalues.index(min(objvalues))\n        opt_nlp_dict = nlp_results[opt_idx]\n\n        objective_value = opt_nlp_dict[OBJECTIVE_VAR_NAME]\n\n        if self.temp_directory_name:\n            filename = f\"{self.temp_directory_name}{objective_value}{time()}{randint(0, 1_000_000_000)}.json\"  # noqa: NPY002\n            json_write(filename, opt_nlp_dict)\n\n        if is_objsense_maximization(self.objective_sense):\n            objective_value *= -1\n\n        print(\"No error, objective value is:\", objective_value)\n\n        active_nlp_x: list[float | int] = [\n            0 for _ in range(len(list(self.idx_to_reac_ids.keys())))\n        ]\n        for couple_idx, reac_ids in self.idx_to_reac_ids.items():\n            reac_id = reac_ids[0]\n            if reac_id not in opt_nlp_dict or opt_nlp_dict[reac_id] &lt; 1e-11:\n                set_value = 0\n            else:\n                set_value = 1\n            active_nlp_x[couple_idx] = set_value\n        output.append((objective_value, active_nlp_x))\n\n    return output\n</code></pre>"},{"location":"api.html#cobrak.evolution.COBRAKProblem.optimize","title":"<code>optimize()</code>","text":"<p>Performs the optimization process.</p> <p>Returns:</p> Type Description <code>dict[float, list[dict[str, float]]]</code> <p>dict[float, list[dict[str, float]]]: A dictionary containing the optimization results.</p> Source code in <code>cobrak/evolution.py</code> <pre><code>def optimize(self) -&gt; dict[float, list[dict[str, float]]]:\n    \"\"\"Performs the optimization process.\n\n    Returns:\n        dict[float, list[dict[str, float]]]: A dictionary containing the optimization results.\n    \"\"\"\n    temp_directory = TemporaryDirectory()\n    self.temp_directory_name = standardize_folder(temp_directory.name)\n\n    match self.algorithm:\n        case \"genetic\":\n            evolution = COBRAKGENETIC(\n                fitness_function=self.fitness,\n                xs_dim=self.dim,\n                extra_xs=self.initial_xs_list,\n                gen=self.num_gens,\n                objvalue_json_path=self.objvalue_json_path,\n                max_rounds_same_objvalue=self.max_rounds_same_objvalue,\n                pop_size=self.pop_size,\n            )\n        case _:\n            print(\n                f\"ERROR: Evolution algorithm {self.algorithm} does not exist! Use 'genetic'.\"\n            )\n            raise ValueError\n    evolution.run()\n\n    result_dict: dict[float, list[dict[str, float]]] = {}\n    for json_filename in get_files(self.temp_directory_name):\n        json_data = json_load(f\"{self.temp_directory_name}{json_filename}\", Any)\n        objective_value = json_data[OBJECTIVE_VAR_NAME]\n        if objective_value not in result_dict:\n            result_dict[objective_value] = []\n        result_dict[objective_value].append(deepcopy(json_data))\n\n    temp_directory.cleanup()\n\n    return {\n        key: result_dict[key] for key in sorted(result_dict.keys(), reverse=True)\n    }\n</code></pre>"},{"location":"api.html#cobrak.evolution.perform_nlp_evolutionary_optimization","title":"<code>perform_nlp_evolutionary_optimization(cobrak_model, objective_target, objective_sense, variability_dict={}, with_kappa=True, with_gamma=True, with_iota=False, with_alpha=False, sampling_wished_num_feasible_starts=3, sampling_max_metarounds=3, sampling_rounds_per_metaround=2, sampling_max_deactivated_reactions=5, sampling_always_deactivated_reactions=[], evolution_num_gens=5, algorithm='genetic', lp_solver=SCIP, nlp_solver=IPOPT, nlp_strict_mode=False, nlp_single_strict_reacs=[], objvalue_json_path='', max_rounds_same_objvalue=float('inf'), correction_config=CorrectionConfig(), min_abs_objvalue=1e-13, pop_size=None, working_results=[], ignore_nonlinear_extra_terms_in_ectfbas=True)</code>","text":"<p>Performs NLP evolutionary optimization on the given COBRA-k model.</p> <p>Parameters:</p> Name Type Description Default <code>cobrak_model</code> <code>Model</code> <p>The COBRA-k model to optimize.</p> required <code>objective_target</code> <code>str | dict[str, float]</code> <p>Target value(s) for the objective function.</p> required <code>objective_sense</code> <code>int</code> <p>Sense of the objective function (1 for maximization, -1 for minimization).</p> required <code>variability_dict</code> <code>dict[str, tuple[float, float]]</code> <p>Variability data for each reaction. Defaults to {}.</p> <code>{}</code> <code>with_kappa</code> <code>bool</code> <p>Whether to use kappa parameter. Defaults to True.</p> <code>True</code> <code>with_gamma</code> <code>bool</code> <p>Whether to use gamma parameter. Defaults to True.</p> <code>True</code> <code>with_iota</code> <code>bool</code> <p>Whether to use iota parameter. Defaults to False.</p> <code>False</code> <code>with_alpha</code> <code>bool</code> <p>Whether to use alpha parameter. Defaults to False.</p> <code>False</code> <code>sampling_wished_num_feasible_starts</code> <code>int</code> <p>The number of wished feasible start solutions. Defaults to 3.</p> <code>3</code> <code>sampling_max_metarounds</code> <code>int</code> <p>Maximum number of meta rounds for sampling. Defaults to 3.</p> <code>3</code> <code>sampling_rounds_per_metaround</code> <code>int</code> <p>Number of rounds per meta round for sampling. Defaults to 2.</p> <code>2</code> <code>sampling_max_deactivated_reactions</code> <code>int</code> <p>Maximum number of deactivated reactions allowed. Defaults to 5.</p> <code>5</code> <code>sampling_always_deactivated_reactions</code> <code>list[str]</code> <p>List of reactions that should always be deactivated. Defaults to [].</p> <code>[]</code> <code>evolution_num_gens</code> <code>int</code> <p>Number of generations for the evolutionary algorithm. Defaults to 5.</p> <code>5</code> <code>algorithm</code> <code>Literal['genetic']</code> <p>Type of optimization algorithm to use. Defaults to \"genetic\", which is also the only algorithm currently available.</p> <code>'genetic'</code> <code>lp_solver</code> <code>Solver</code> <p>The linear programming solver to use. Defaults to SCIP.</p> <code>SCIP</code> <code>nlp_solver</code> <code>Solver</code> <p>The nonlinear programming solver to use. Defaults to IPOPT.</p> <code>IPOPT</code> <code>nlp_strict_mode</code> <code>bool</code> <p>Whether or not the &lt;= heuristic (True) or not (False; i.e. setting all equations to ==) shall be used. Defaults to False.</p> <code>False</code> <code>nlp_single_strict_reacs</code> <code>list[str]</code> <p>List of single reactions that shall be in strict mode (see <code>nlp_strict_mode</code>argument above). If <code>nlp_strict_mode=True</code>, this has no effect. Defaults to [].</p> <code>[]</code> <code>objvalue_json_path</code> <code>str</code> <p>Path to the JSON file for objective values. Defaults to \"\".</p> <code>''</code> <code>max_rounds_same_objvalue</code> <code>float</code> <p>Maximum number of rounds with same objective value before stopping. Defaults to float(\"inf\").</p> <code>float('inf')</code> <code>correction_config</code> <code>CorrectionConfig</code> <p>Configuration for corrections during optimization. Defaults to CorrectionConfig().</p> <code>CorrectionConfig()</code> <code>min_abs_objvalue</code> <code>float</code> <p>Minimum absolute value of objective function to consider valid. Defaults to 1e-13.</p> <code>1e-13</code> <code>pop_size</code> <code>int | None</code> <p>Population size for the evolutionary algorithm. Defaults to None.</p> <code>None</code> <code>working_results</code> <code>list[dict[str, float]]</code> <p>List of initial feasible results. Defaults to [].</p> <code>[]</code> <code>ignore_nonlinear_extra_terms_in_ectfbas</code> <code>bool</code> <p>(bool, optional): Whether or not non-linear watches/constraints shall be ignored in ecTFBAs. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict[float, list[dict[str, float]]]</code> <p>dict[float, list[dict[str, float]]]: Dictionary of objective values and corresponding solutions.</p> Source code in <code>cobrak/evolution.py</code> <pre><code>def perform_nlp_evolutionary_optimization(\n    cobrak_model: Model,\n    objective_target: str | dict[str, float],\n    objective_sense: int,\n    variability_dict: dict[str, tuple[float, float]] = {},\n    with_kappa: bool = True,\n    with_gamma: bool = True,\n    with_iota: bool = False,\n    with_alpha: bool = False,\n    sampling_wished_num_feasible_starts: int = 3,\n    sampling_max_metarounds: int = 3,\n    sampling_rounds_per_metaround: int = 2,\n    sampling_max_deactivated_reactions: int = 5,\n    sampling_always_deactivated_reactions: list[str] = [],\n    evolution_num_gens: int = 5,\n    algorithm: Literal[\"genetic\"] = \"genetic\",\n    lp_solver: Solver = SCIP,\n    nlp_solver: Solver = IPOPT,\n    nlp_strict_mode: bool = False,\n    nlp_single_strict_reacs: list[str] = [],\n    objvalue_json_path: str = \"\",\n    max_rounds_same_objvalue: float = float(\"inf\"),\n    correction_config: CorrectionConfig = CorrectionConfig(),\n    min_abs_objvalue: float = 1e-13,\n    pop_size: int | None = None,\n    working_results: list[dict[str, float]] = [],\n    ignore_nonlinear_extra_terms_in_ectfbas: bool = True,\n) -&gt; dict[float, list[dict[str, float]]]:\n    \"\"\"Performs NLP evolutionary optimization on the given COBRA-k model.\n\n    Args:\n        cobrak_model (Model): The COBRA-k model to optimize.\n        objective_target (str | dict[str, float]): Target value(s) for the objective function.\n        objective_sense (int): Sense of the objective function (1 for maximization, -1 for minimization).\n        variability_dict (dict[str, tuple[float, float]], optional): Variability data for each reaction. Defaults to {}.\n        with_kappa (bool, optional): Whether to use kappa parameter. Defaults to True.\n        with_gamma (bool, optional): Whether to use gamma parameter. Defaults to True.\n        with_iota (bool, optional): Whether to use iota parameter. Defaults to False.\n        with_alpha (bool, optional): Whether to use alpha parameter. Defaults to False.\n        sampling_wished_num_feasible_starts (int, optional): The number of wished feasible start solutions. Defaults to 3.\n        sampling_max_metarounds (int, optional): Maximum number of meta rounds for sampling. Defaults to 3.\n        sampling_rounds_per_metaround (int, optional): Number of rounds per meta round for sampling. Defaults to 2.\n        sampling_max_deactivated_reactions (int, optional): Maximum number of deactivated reactions allowed. Defaults to 5.\n        sampling_always_deactivated_reactions (list[str], optional): List of reactions that should always be deactivated. Defaults to [].\n        evolution_num_gens (int, optional): Number of generations for the evolutionary algorithm. Defaults to 5.\n        algorithm (Literal[\"genetic\"], optional): Type of optimization algorithm to use. Defaults to \"genetic\", which is also the only algorithm currently available.\n        lp_solver (Solver, optional): The linear programming solver to use. Defaults to SCIP.\n        nlp_solver (Solver, optional): The nonlinear programming solver to use. Defaults to IPOPT.\n        nlp_strict_mode (bool, optional): Whether or not the &lt;= heuristic (True) or not (False; i.e. setting all equations to ==) shall be used. Defaults to False.\n        nlp_single_strict_reacs (list[str], optional): List of single reactions that shall be in strict mode (see ```nlp_strict_mode```argument above).\n            If ```nlp_strict_mode=True```, this has no effect. Defaults to [].\n        objvalue_json_path (str, optional): Path to the JSON file for objective values. Defaults to \"\".\n        max_rounds_same_objvalue (float, optional): Maximum number of rounds with same objective value before stopping. Defaults to float(\"inf\").\n        correction_config (CorrectionConfig, optional): Configuration for corrections during optimization. Defaults to CorrectionConfig().\n        min_abs_objvalue (float, optional): Minimum absolute value of objective function to consider valid. Defaults to 1e-13.\n        pop_size (int | None, optional): Population size for the evolutionary algorithm. Defaults to None.\n        working_results (list[dict[str, float]], optional): List of initial feasible results. Defaults to [].\n        ignore_nonlinear_extra_terms_in_ectfbas: (bool, optional): Whether or not non-linear watches/constraints shall be ignored in ecTFBAs. Defaults to True.\n\n    Returns:\n        dict[float, list[dict[str, float]]]: Dictionary of objective values and corresponding solutions.\n    \"\"\"\n    if variability_dict == {}:\n        variability_dict = perform_lp_variability_analysis(\n            cobrak_model=cobrak_model,\n            with_enzyme_constraints=True,\n            with_thermodynamic_constraints=True,\n            active_reactions=[],\n            solver=lp_solver,\n            ignore_nonlinear_terms=ignore_nonlinear_extra_terms_in_ectfbas,\n        )\n    else:\n        variability_dict = deepcopy(variability_dict)\n\n    # Initial sampling\n    if isinstance(objective_target, str):\n        objective_target = {objective_target: 1.0}\n    objective_target_ids = list(objective_target.keys())  # type: ignore\n\n    deactivatable_reactions = [\n        var_id\n        for var_id in variability_dict\n        if (var_id in cobrak_model.reactions)\n        and (variability_dict[var_id][0] == 0.0)\n        and (var_id not in objective_target_ids)\n        and (var_id not in sampling_always_deactivated_reactions)\n        and (var_id not in correction_config.error_scenario)\n    ]\n    distinct_feasible_start_solutions: dict[tuple[str, ...], dict[str, float]] = {}\n    for current_round in range(sampling_max_metarounds):\n        # Get deactivated reaction lists\n        all_deactivated_reaction_lists = [\n            [\n                sample(\n                    deactivatable_reactions,\n                    randint(1, sampling_max_deactivated_reactions + 1),  # noqa: NPY002\n                )\n                + sampling_always_deactivated_reactions\n                for _ in range(sampling_rounds_per_metaround)\n            ]\n            for _ in range(cpu_count())\n        ]\n        if current_round == 0:\n            all_deactivated_reaction_lists[0][0] = deepcopy(\n                sampling_always_deactivated_reactions\n            )\n\n        # run sampling\n        results = Parallel(n_jobs=-1, verbose=10)(\n            delayed(_sampling_routine)(\n                cobrak_model,\n                objective_target,\n                objective_sense,\n                variability_dict,\n                with_kappa,\n                with_gamma,\n                with_iota,\n                with_alpha,\n                deactivated_reaction_lists,\n                lp_solver,\n                nlp_solver,\n                nlp_strict_mode,\n                nlp_single_strict_reacs,\n                correction_config,\n                min_abs_objvalue,\n                ignore_nonlinear_extra_terms_in_ectfbas,\n            )\n            for deactivated_reaction_lists in all_deactivated_reaction_lists\n        )\n        if len(working_results) &gt; 0:\n            results.append(working_results)\n        best_result = (\n            -float(\"inf\") if is_objsense_maximization(objective_sense) else float(\"inf\")\n        )\n        for result in results:\n            for nlp_dict in result:\n                active_reacs_tuple = tuple(\n                    sorted(\n                        get_active_reacs_from_optimization_dict(cobrak_model, nlp_dict)\n                    )\n                )\n                distinct_feasible_start_solutions[active_reacs_tuple] = deepcopy(\n                    nlp_dict\n                )\n                if is_objsense_maximization(objective_sense):\n                    best_result = max(nlp_dict[OBJECTIVE_VAR_NAME], best_result)\n                else:\n                    best_result = min(nlp_dict[OBJECTIVE_VAR_NAME], best_result)\n\n        if (\n            len(distinct_feasible_start_solutions.keys())\n            &gt;= sampling_wished_num_feasible_starts\n        ):\n            break\n\n    if len(distinct_feasible_start_solutions.keys()) == 0:\n        print(\n            \"ERROR in initial sampling: No feasible sampling solution found! Check feasibility of problem and/or adjust sampling settings.\"\n        )\n        raise ValueError\n    if (\n        len(distinct_feasible_start_solutions.keys())\n        &lt; sampling_wished_num_feasible_starts\n    ):\n        print(\"INFO: Fewer feasible sampling solutions found than wished.\")\n\n    # Evolutionary algorithm\n    problem = COBRAKProblem(\n        cobrak_model=cobrak_model,\n        objective_target=objective_target,  # type: ignore\n        objective_sense=objective_sense,\n        variability_dict=variability_dict,\n        nlp_dict_list=list(distinct_feasible_start_solutions.values()),\n        best_value=best_result,\n        with_kappa=with_kappa,\n        with_gamma=with_gamma,\n        with_iota=with_iota,\n        with_alpha=with_alpha,\n        num_gens=evolution_num_gens,\n        algorithm=algorithm,\n        lp_solver=lp_solver,\n        nlp_solver=nlp_solver,\n        objvalue_json_path=objvalue_json_path,\n        max_rounds_same_objvalue=max_rounds_same_objvalue,\n        correction_config=correction_config,\n        min_abs_objvalue=min_abs_objvalue,\n        pop_size=pop_size,\n        ignore_nonlinear_extra_terms_in_ectfbas=ignore_nonlinear_extra_terms_in_ectfbas,\n        nlp_strict_mode=nlp_strict_mode,\n        nlp_single_strict_reacs=nlp_single_strict_reacs,\n    )\n\n    return problem.optimize()\n</code></pre>"},{"location":"api.html#cobrak.evolution.postprocess","title":"<code>postprocess(cobrak_model, opt_dict, objective_target, objective_sense, variability_data, with_kappa=True, with_gamma=True, with_iota=False, with_alpha=False, lp_solver=SCIP, nlp_solver=IPOPT, nlp_strict_mode=False, nlp_single_strict_reacs=[], verbose=False, correction_config=CorrectionConfig(), onlytested='', ignore_nonlinear_extra_terms_in_ectfbas=True)</code>","text":"<p>Postprocesses the optimization results to find feasible switches.</p> <p>Parameters:</p> Name Type Description Default <code>cobrak_model</code> <code>Model</code> <p>The COBRA-k model to optimize.</p> required <code>opt_dict</code> <code>dict[str, float]</code> <p>Optimization result dictionary.</p> required <code>objective_target</code> <code>str | dict[str, float]</code> <p>Target value(s) for the objective function.</p> required <code>objective_sense</code> <code>int</code> <p>Sense of the objective function (1 for maximization, -1 for minimization).</p> required <code>variability_data</code> <code>dict[str, tuple[float, float]]</code> <p>Variability data for each reaction.</p> required <code>with_kappa</code> <code>bool</code> <p>Whether to use kappa parameter. Defaults to True.</p> <code>True</code> <code>with_gamma</code> <code>bool</code> <p>Whether to use gamma parameter. Defaults to True.</p> <code>True</code> <code>with_iota</code> <code>bool</code> <p>Whether to use iota parameter. Defaults to False.</p> <code>False</code> <code>with_alpha</code> <code>bool</code> <p>Whether to use alpha parameter. Defaults to False.</p> <code>False</code> <code>lp_solver</code> <code>Solver</code> <p>The linear programming solver to use. Defaults to SCIP.</p> <code>SCIP</code> <code>nlp_solver</code> <code>Solver</code> <p>The nonlinear programming solver to use. Defaults to IPOPT.</p> <code>IPOPT</code> <code>nlp_strict_mode</code> <code>bool</code> <p>Whether or not the &lt;= heuristic (True) or not (False; i.e. setting all equations to ==) shall be used. Defaults to False.</p> <code>False</code> <code>nlp_single_strict_reacs</code> <code>list[str]</code> <p>List of single reactions that shall be in strict mode (see <code>nlp_strict_mode</code>argument above). If <code>nlp_strict_mode=True</code>, this has no effect. Defaults to [].</p> <code>[]</code> <code>verbose</code> <code>bool</code> <p>Whether to enable verbose output. Defaults to False.</p> <code>False</code> <code>correction_config</code> <code>CorrectionConfig</code> <p>Configuration for corrections during optimization. Defaults to CorrectionConfig().</p> <code>CorrectionConfig()</code> <code>onlytested</code> <code>str</code> <p>Specific reactions to test during postprocessing. Defaults to \"\".</p> <code>''</code> <code>ignore_nonlinear_extra_terms_in_ectfbas</code> <code>bool</code> <p>(bool, optional): Whether or not non-linear watches/constraints shall be ignored in ecTFBAs.</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple[float, list[float | int]]</code> <p>tuple[float, list[float | int]]: Best result and a list of feasible switches.</p> Source code in <code>cobrak/evolution.py</code> <pre><code>def postprocess(\n    cobrak_model: Model,\n    opt_dict: dict[str, float],\n    objective_target: str | dict[str, float],\n    objective_sense: int,\n    variability_data: dict[str, tuple[float, float]],\n    with_kappa: bool = True,\n    with_gamma: bool = True,\n    with_iota: bool = False,\n    with_alpha: bool = False,\n    lp_solver: Solver = SCIP,\n    nlp_solver: Solver = IPOPT,\n    nlp_strict_mode: bool = False,\n    nlp_single_strict_reacs: list[str] = [],\n    verbose: bool = False,\n    correction_config: CorrectionConfig = CorrectionConfig(),\n    onlytested: str = \"\",\n    ignore_nonlinear_extra_terms_in_ectfbas: bool = True,\n) -&gt; tuple[float, list[float | int]]:\n    \"\"\"Postprocesses the optimization results to find feasible switches.\n\n    Args:\n        cobrak_model (Model): The COBRA-k model to optimize.\n        opt_dict (dict[str, float]): Optimization result dictionary.\n        objective_target (str | dict[str, float]): Target value(s) for the objective function.\n        objective_sense (int): Sense of the objective function (1 for maximization, -1 for minimization).\n        variability_data (dict[str, tuple[float, float]]): Variability data for each reaction.\n        with_kappa (bool, optional): Whether to use kappa parameter. Defaults to True.\n        with_gamma (bool, optional): Whether to use gamma parameter. Defaults to True.\n        with_iota (bool, optional): Whether to use iota parameter. Defaults to False.\n        with_alpha (bool, optional): Whether to use alpha parameter. Defaults to False.\n        lp_solver (Solver, optional): The linear programming solver to use. Defaults to SCIP.\n        nlp_solver (Solver, optional): The nonlinear programming solver to use. Defaults to IPOPT.\n        nlp_strict_mode (bool, optional): Whether or not the &lt;= heuristic (True) or not (False; i.e. setting all equations to ==) shall be used. Defaults to False.\n        nlp_single_strict_reacs (list[str], optional): List of single reactions that shall be in strict mode (see ```nlp_strict_mode```argument above).\n            If ```nlp_strict_mode=True```, this has no effect. Defaults to [].\n        verbose (bool, optional): Whether to enable verbose output. Defaults to False.\n        correction_config (CorrectionConfig, optional): Configuration for corrections during optimization. Defaults to CorrectionConfig().\n        onlytested (str, optional): Specific reactions to test during postprocessing. Defaults to \"\".\n        ignore_nonlinear_extra_terms_in_ectfbas: (bool, optional): Whether or not non-linear watches/constraints shall be ignored in ecTFBAs.\n\n    Returns:\n        tuple[float, list[float | int]]: Best result and a list of feasible switches.\n    \"\"\"\n    if variability_data == {}:\n        variability_data = perform_lp_variability_analysis(\n            cobrak_model=cobrak_model,\n            with_enzyme_constraints=True,\n            with_thermodynamic_constraints=True,\n            active_reactions=[],\n            solver=lp_solver,\n            ignore_nonlinear_terms=ignore_nonlinear_extra_terms_in_ectfbas,\n        )\n    else:\n        variability_data = deepcopy(variability_data)\n\n    pyomo_lp_solver = get_solver(\n        lp_solver.name,\n        lp_solver.solver_options,\n        lp_solver.solver_attrs,\n    )\n\n    cobrak_model = deepcopy(cobrak_model)\n    if type(objective_target) is str:\n        objective_target = {objective_target: 1.0}\n    obj_value = 0.0\n    for obj_target_id, obj_target_multiplier in objective_target.items():\n        obj_value += opt_dict[obj_target_id] * obj_target_multiplier\n    epsilon = 1e-6 if is_objsense_maximization(objective_sense) else -1e-6\n    cobrak_model = add_objective_value_as_extra_linear_constraint(\n        cobrak_model,\n        obj_value + epsilon,\n        objective_target,\n        objective_sense,\n    )\n\n    reac_couples = get_stoichiometrically_coupled_reactions(cobrak_model)\n    active_reacs = [\n        active_reac\n        for active_reac in get_active_reacs_from_optimization_dict(\n            cobrak_model, opt_dict\n        )\n        if (active_reac in [reac_ids[0] for reac_ids in reac_couples])\n        and (active_reac not in objective_target)  # and opt_dict[active_reac] &gt; 1e-8\n    ]\n    active_reac_couples: list[list[str]] = [\n        reac_couple\n        for reac_couple in reac_couples\n        if reac_couple[0] in active_reacs and variability_data[reac_couple[0]][0] == 0.0\n    ]\n    inactive_reac_couples: list[list[str]] = [\n        reac_couple\n        for reac_couple in reac_couples\n        if reac_couple[0] not in active_reacs\n        and variability_data[reac_couple[0]][1] &gt; 0.0\n    ]\n    targets = []\n    for max_target_num in (0, 5):\n        targets += [(\"deac\", x, max_target_num) for x in active_reac_couples]\n        targets += [(\"ac\", x, max_target_num) for x in inactive_reac_couples]\n    all_feasible_switches_metalist = Parallel(n_jobs=-1, verbose=10)(\n        delayed(_postprocess_batch)(\n            reac_couples,\n            targets_batch,\n            active_reacs,\n            cobrak_model,\n            objective_target,\n            objective_sense,\n            variability_data,\n            pyomo_lp_solver,\n            with_kappa,\n            with_gamma,\n            with_iota,\n            with_alpha,\n            lp_solver,\n            nlp_solver,\n            nlp_strict_mode,\n            nlp_single_strict_reacs,\n            verbose,\n            correction_config,\n            onlytested,\n            ignore_nonlinear_extra_terms_in_ectfbas,\n        )\n        for targets_batch in split_list(targets, cpu_count())\n    )\n    all_feasible_switches = []\n    for sublist in all_feasible_switches_metalist:\n        all_feasible_switches.extend(sublist)\n\n    if len(all_feasible_switches) &gt; 0:\n        best_result = all_feasible_switches[0][2]\n        for result in [x[2] for x in all_feasible_switches[1:]]:\n            if is_objsense_maximization(objective_sense):\n                if result[OBJECTIVE_VAR_NAME] &gt; best_result[OBJECTIVE_VAR_NAME]:\n                    best_result = result\n            else:\n                if result[OBJECTIVE_VAR_NAME] &lt; best_result[OBJECTIVE_VAR_NAME]:\n                    best_result = result\n    else:\n        best_result = {}\n\n    return all_feasible_switches, best_result\n</code></pre>"},{"location":"api.html#cobrak.example_models","title":"<code>example_models</code>","text":"<p>Contains the toy model from COBRAk's documentation and publication as example model as well as iCH360_cobrak.</p>"},{"location":"api.html#cobrak.example_models.__getattr__","title":"<code>__getattr__(name)</code>","text":"<p>Called by Python when an attribute that does not yet exist in the module namespace is requested.</p> <p>We use it to load the JSON the first time <code>iCH360_cobrak</code> is asked for, then store the result in <code>globals()</code> so the load happens only once.</p> Source code in <code>cobrak/example_models.py</code> <pre><code>def __getattr__(name: str) -&gt; Any:  # called only for missing attrs  # noqa: ANN401\n    \"\"\"Called by Python when an attribute that does not yet exist in the\n    module namespace is requested.\n\n    We use it to load the JSON the first time ``iCH360_cobrak`` is asked\n    for, then store the result in ``globals()`` so the load happens only\n    once.\n    \"\"\"\n    if name == \"iCH360_cobrak\":\n        data = json_load(\n            str(r.files(\"cobrak\").joinpath(\"data/iCH360_cobrak.json\"))\n        )  # &lt;-load the file now\n        globals()[name] = data  # cache for future accesses\n        return data\n    raise AttributeError(name)\n</code></pre>"},{"location":"api.html#cobrak.expasy_functionality","title":"<code>expasy_functionality</code>","text":"<p>This module provides functionality to parse Expasy enzyme RDF files and extract EC number transfers.</p>"},{"location":"api.html#cobrak.expasy_functionality.get_ec_number_transfers","title":"<code>get_ec_number_transfers(expasy_enzyme_rdf_path)</code>","text":"<p>Parses an Expasy enzyme RDF file to extract enzyme EC number transfers.</p> <p>Parameters:</p> Name Type Description Default <code>expasy_enzyme_rdf_path</code> <code>str</code> <p>Path to the Expasy enzyme RDF file.</p> required <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>dict[str, str]: A dictionary where each key is an EC number, and its corresponding value is the EC number it is transferred to.             The dictionary includes both directions of the transfer (old to new and new to old).</p> Source code in <code>cobrak/expasy_functionality.py</code> <pre><code>@validate_call(validate_return=True)\ndef get_ec_number_transfers(expasy_enzyme_rdf_path: str) -&gt; dict[str, str]:\n    \"\"\"Parses an Expasy enzyme RDF file to extract enzyme EC number transfers.\n\n    Args:\n        expasy_enzyme_rdf_path (str): Path to the Expasy enzyme RDF file.\n\n    Returns:\n        dict[str, str]: A dictionary where each key is an EC number, and its corresponding value is the EC number it is transferred to.\n                        The dictionary includes both directions of the transfer (old to new and new to old).\n    \"\"\"\n    tree = ET.parse(expasy_enzyme_rdf_path)\n    root = tree.getroot()\n\n    ec_number_transfers: dict[str, str] = {}\n    for child in root:\n        for subchild in child:\n            if \"replaces\" not in subchild.tag:\n                continue\n            new_ec_numbers = list(child.attrib.values())\n            old_ec_numbers = list(subchild.attrib.values())\n            for new_ec_number in new_ec_numbers:\n                for old_ec_number in old_ec_numbers:\n                    ec_number_transfers[old_ec_number] = new_ec_number\n                    ec_number_transfers[new_ec_number] = old_ec_number\n    return ec_number_transfers\n</code></pre>"},{"location":"api.html#cobrak.genetic","title":"<code>genetic</code>","text":"<p>Methods for COBRA-k's genetic algorithm used in the COBRA-k evolutionary algorithm</p>"},{"location":"api.html#cobrak.genetic.COBRAKGENETIC","title":"<code>COBRAKGENETIC</code>","text":"<p>A class for performing genetic algorithm optimization.</p> <p>Attributes:</p> Name Type Description <code>fitness_function</code> <code>Callable</code> <p>A function that takes a list of integers/floats and returns a tuple containing the fitness score and a list of integers/floats.</p> <code>xs_dim</code> <code>int</code> <p>The dimensionality of the search space.</p> <code>gen</code> <code>int</code> <p>The number of generations to run the algorithm for.</p> <code>seed</code> <code>int | None</code> <p>The seed for the random number generator.</p> <code>objvalue_json_path</code> <code>str</code> <p>The path to a JSON file to store objective values.</p> <code>max_rounds_same_objvalue</code> <code>float</code> <p>The maximum number of rounds with the same objective value before stopping the algorithm.</p> <code>pop_size</code> <code>int | None</code> <p>The size of the population. If None, defaults to the number of CPUs.</p> Source code in <code>cobrak/genetic.py</code> <pre><code>class COBRAKGENETIC:\n    \"\"\"A class for performing genetic algorithm optimization.\n\n    Attributes:\n        fitness_function (Callable): A function that takes a list of integers/floats\n            and returns a tuple containing the fitness score and a list of integers/floats.\n        xs_dim (int): The dimensionality of the search space.\n        gen (int): The number of generations to run the algorithm for.\n        seed (int | None): The seed for the random number generator.\n        objvalue_json_path (str): The path to a JSON file to store objective values.\n        max_rounds_same_objvalue (float): The maximum number of rounds with the same\n            objective value before stopping the algorithm.\n        pop_size (int | None): The size of the population. If None, defaults to the\n            number of CPUs.\n    \"\"\"\n\n    def __init__(\n        self,\n        fitness_function: Callable[\n            [list[float | int]], tuple[float, list[float | int]]\n        ],\n        xs_dim: int,\n        gen: int,\n        extra_xs: list[list[int]] = [],\n        seed: int | None = None,\n        objvalue_json_path: str = \"\",\n        max_rounds_same_objvalue: float = float(\"inf\"),\n        pop_size: int | None = None,\n    ) -&gt; None:\n        \"\"\"Initializes the COBRAKGENETIC object.\n\n        Args:\n            fitness_function (Callable): The fitness function to evaluate solutions.\n            xs_dim (int): The dimensionality of the search space.\n            gen (int): The number of generations to run.\n            extra_xs (list[list[int]], optional): Extra particles to initialize the population.\n                Defaults to [].\n            seed (int | None, optional): Seed for the random number generator. Defaults to None.\n            objvalue_json_path (str, optional): Path to a JSON file to store objective values.\n                Defaults to \"\".\n            max_rounds_same_objvalue (float, optional): Maximum rounds with the same objective\n                value before stopping. Defaults to infinity.\n            pop_size (int | None, optional): Population size. Defaults to None.\n        \"\"\"\n        # Parameters\n        self.fitness_function = fitness_function\n        self.xs_dim = xs_dim\n        self.gen = gen\n        self.seed = seed\n        if seed is not None:\n            np.random.seed(seed)  # noqa: NPY002\n\n        # Initialization of random particles\n        cpu_count_value = cpu_count() if pop_size is None else pop_size\n        if cpu_count_value is None:\n            self.cpu_count = 1\n        else:\n            self.cpu_count = cpu_count_value\n        self.init_xs = [\n            [randint(0, 1) for _ in range(xs_dim)]\n            for _ in range(self.cpu_count - len(extra_xs))\n        ]\n\n        # Addition of user-defined extra particles\n        if extra_xs != []:\n            self.init_xs.extend(extra_xs)\n\n        self.tested_xs: dict[tuple[int, ...], float] = {}\n        self.all_xs: dict[tuple[int, ...], float] = {}\n        self.objvalue_json_path = objvalue_json_path\n        self.objvalue_json_data: dict[float, list[float]] = {}\n        self.max_rounds_same_objvalue = max_rounds_same_objvalue\n\n    def _get_sorted_list_from_tested_xs(self) -&gt; list[tuple[float, tuple[int, ...]]]:\n        \"\"\"Returns a sorted list of tuples containing fitness scores and solutions.\n\n        Returns:\n            list[tuple[float, tuple[int, ...]]]: A sorted list of (fitness, solution) tuples.\n        \"\"\"\n        return sorted(\n            [(fitness, x) for (x, fitness) in self.tested_xs.items()],\n            key=operator.itemgetter(0),\n        )\n\n    def run(self) -&gt; tuple[float, tuple[int, ...]]:\n        \"\"\"Runs the genetic algorithm optimization.\n\n        Returns:\n            tuple[float, tuple[int, ...]]: A tuple containing the best fitness score and the\n            corresponding solution.\n        \"\"\"\n        init_fitnesses = Parallel(n_jobs=-1)(\n            delayed(self.fitness_function)(x) for x in self.init_xs\n        )\n        if init_fitnesses is not None:\n            self.tested_xs = {}\n            for init_fitness in init_fitnesses:\n                for fitness, xs in init_fitness:\n                    self.tested_xs[tuple(xs)] = fitness\n        else:\n            print(\"ERROR: Something went wrong during initialization\")\n            raise ValueError\n\n        if self.objvalue_json_path:\n            start_time = time()\n            self.objvalue_json_data[0.0] = sorted(self.tested_xs.values())\n            json_write(self.objvalue_json_path, self.objvalue_json_data)\n\n        # Actual algorithm\n        max_objvalues = []\n        for _ in range(self.gen):\n            max_objvalues.append(max(self.tested_xs.values()))\n            if last_n_elements_equal(max_objvalues, self.max_rounds_same_objvalue):  # type: ignore\n                break\n\n            xs_list = self._get_sorted_list_from_tested_xs()\n            xs_list = [xs for xs in xs_list if len(xs) &gt; 0]\n\n            chosen_xs: list[tuple[int, ...]] = []\n            # Choose some of the top 3\n            for _ in range(self.cpu_count // 4):\n                chosen_xs.append(choice([x[1] for x in xs_list if len(x[1]) &gt; 0][:3]))\n\n            # Choose some of the 25% best\n            for _ in range(self.cpu_count // 2):\n                chosen_xs.append(\n                    choice([x[1] for x in xs_list][: round(len(xs_list) * 0.25)])\n                )\n\n            # Choose some other 75% worst\n            for _ in range(self.cpu_count // 4):\n                addlength = 0\n                while not addlength:\n                    added_xs = deepcopy(\n                        choice([x[1] for x in xs_list][round(len(xs_list) * 0.25) :])\n                    )\n                    addlength = len(added_xs)\n                chosen_xs.append(added_xs)\n\n            # Random crossovers\n            for _ in range(round(len(chosen_xs) * 0.2)):\n                target = randint(0, len(chosen_xs) - 1)\n                source = randint(0, len(chosen_xs) - 1)\n                cut = randint(0, self.xs_dim - 1)\n                chosen_xs[target] = deepcopy(chosen_xs[target][:cut]) + deepcopy(\n                    chosen_xs[source][cut:]\n                )\n\n            # Test Xs in parallel\n            results = Parallel(n_jobs=-1, verbose=10)(\n                delayed(self.update_particle)(\n                    chosen_x,\n                    count_last_equal_elements(max_objvalues),\n                )\n                for chosen_x in chosen_xs\n            )\n\n            if results is None:\n                print(\"ERROR: Something went wrong during fitness calculations\")\n                raise ValueError\n\n            # Unpack results\n            for fitnesses_and_active_xs, mutated_x in results:\n                for fitness, active_x in fitnesses_and_active_xs:\n                    if active_x is None or active_x == []:\n                        continue\n                    self.tested_xs[tuple(active_x)] = fitness\n                    self.all_xs[tuple(active_x)] = fitness\n                self.all_xs[tuple(mutated_x)] = max(\n                    fitness for (fitness, _) in fitnesses_and_active_xs\n                )\n\n            if self.objvalue_json_path:\n                self.objvalue_json_data[time() - start_time] = sorted(\n                    self.tested_xs.values()\n                )\n                json_write(self.objvalue_json_path, self.objvalue_json_data)\n\n        best_f_and_x = self._get_sorted_list_from_tested_xs()[0]\n        return best_f_and_x[0], best_f_and_x[1]\n\n    def update_particle(\n        self,\n        chosen_x: list[int],\n        num_rounds_without_best_change: int,\n    ) -&gt; tuple[float, list[int], list[int]]:\n        \"\"\"Updates a single particle by introducing mutations.\n\n        Args:\n            chosen_x (list[int]): The current solution represented as a list of integers.\n            num_rounds_without_best_change (int): The number of rounds without a change in the\n                best fitness score.\n\n        Returns:\n            tuple[list[list[float]], list[int]]: A tuple containing a list of fitness scores\n            and the mutated solution.\n        \"\"\"\n        if not len(chosen_x):\n            return [[1_000_000, []]], []\n\n        min_change_p = 0.1 * 0.95**num_rounds_without_best_change\n        max_change_p = 0.1 * 1.05**num_rounds_without_best_change\n        change_p = uniform(min_change_p, max_change_p)\n        change_p = max(0.001, change_p)\n        change_p = min(0.999, change_p)\n\n        mutation_tries = 0\n        while True:\n            mutated_x: list[float] = []\n            match randint(0, 2):\n                case 0:  # Extend\n                    for x in chosen_x:\n                        if x == 1:\n                            mutated_x.append(1)\n                            continue\n                        if uniform(0.0, 1.0) &lt; change_p:\n                            mutated_x.append(1)\n                        else:\n                            mutated_x.append(x)\n                case 1:  # Decrease\n                    for x in chosen_x:\n                        if x == 0:\n                            mutated_x.append(0)\n                            continue\n                        if uniform(0.0, 1.0) &lt; change_p:\n                            mutated_x.append(0)\n                        else:\n                            mutated_x.append(x)\n                case 2:  # Extend and decrease\n                    for x in chosen_x:\n                        if x == 1:\n                            if uniform(0.0, 1.0) &lt; change_p:\n                                mutated_x.append(0)\n                            else:\n                                mutated_x.append(x)\n                        else:\n                            if uniform(0.0, 1.0) &lt; change_p:\n                                mutated_x.append(1)\n                            else:\n                                mutated_x.append(x)\n                # case 3:  # Random\n                #    mutated_x = [randint(0, 1) for _ in range(len(chosen_x))]\n\n            if mutation_tries &gt; 250:\n                return [[1_000_000, []]], []\n            if tuple(mutated_x) in self.all_xs:\n                mutation_tries += 1\n            else:\n                break\n\n        # Evaluate new position\n        fitnesses_and_active_xs = self.fitness_function(mutated_x)\n\n        return fitnesses_and_active_xs, mutated_x\n</code></pre>"},{"location":"api.html#cobrak.genetic.COBRAKGENETIC.__init__","title":"<code>__init__(fitness_function, xs_dim, gen, extra_xs=[], seed=None, objvalue_json_path='', max_rounds_same_objvalue=float('inf'), pop_size=None)</code>","text":"<p>Initializes the COBRAKGENETIC object.</p> <p>Parameters:</p> Name Type Description Default <code>fitness_function</code> <code>Callable</code> <p>The fitness function to evaluate solutions.</p> required <code>xs_dim</code> <code>int</code> <p>The dimensionality of the search space.</p> required <code>gen</code> <code>int</code> <p>The number of generations to run.</p> required <code>extra_xs</code> <code>list[list[int]]</code> <p>Extra particles to initialize the population. Defaults to [].</p> <code>[]</code> <code>seed</code> <code>int | None</code> <p>Seed for the random number generator. Defaults to None.</p> <code>None</code> <code>objvalue_json_path</code> <code>str</code> <p>Path to a JSON file to store objective values. Defaults to \"\".</p> <code>''</code> <code>max_rounds_same_objvalue</code> <code>float</code> <p>Maximum rounds with the same objective value before stopping. Defaults to infinity.</p> <code>float('inf')</code> <code>pop_size</code> <code>int | None</code> <p>Population size. Defaults to None.</p> <code>None</code> Source code in <code>cobrak/genetic.py</code> <pre><code>def __init__(\n    self,\n    fitness_function: Callable[\n        [list[float | int]], tuple[float, list[float | int]]\n    ],\n    xs_dim: int,\n    gen: int,\n    extra_xs: list[list[int]] = [],\n    seed: int | None = None,\n    objvalue_json_path: str = \"\",\n    max_rounds_same_objvalue: float = float(\"inf\"),\n    pop_size: int | None = None,\n) -&gt; None:\n    \"\"\"Initializes the COBRAKGENETIC object.\n\n    Args:\n        fitness_function (Callable): The fitness function to evaluate solutions.\n        xs_dim (int): The dimensionality of the search space.\n        gen (int): The number of generations to run.\n        extra_xs (list[list[int]], optional): Extra particles to initialize the population.\n            Defaults to [].\n        seed (int | None, optional): Seed for the random number generator. Defaults to None.\n        objvalue_json_path (str, optional): Path to a JSON file to store objective values.\n            Defaults to \"\".\n        max_rounds_same_objvalue (float, optional): Maximum rounds with the same objective\n            value before stopping. Defaults to infinity.\n        pop_size (int | None, optional): Population size. Defaults to None.\n    \"\"\"\n    # Parameters\n    self.fitness_function = fitness_function\n    self.xs_dim = xs_dim\n    self.gen = gen\n    self.seed = seed\n    if seed is not None:\n        np.random.seed(seed)  # noqa: NPY002\n\n    # Initialization of random particles\n    cpu_count_value = cpu_count() if pop_size is None else pop_size\n    if cpu_count_value is None:\n        self.cpu_count = 1\n    else:\n        self.cpu_count = cpu_count_value\n    self.init_xs = [\n        [randint(0, 1) for _ in range(xs_dim)]\n        for _ in range(self.cpu_count - len(extra_xs))\n    ]\n\n    # Addition of user-defined extra particles\n    if extra_xs != []:\n        self.init_xs.extend(extra_xs)\n\n    self.tested_xs: dict[tuple[int, ...], float] = {}\n    self.all_xs: dict[tuple[int, ...], float] = {}\n    self.objvalue_json_path = objvalue_json_path\n    self.objvalue_json_data: dict[float, list[float]] = {}\n    self.max_rounds_same_objvalue = max_rounds_same_objvalue\n</code></pre>"},{"location":"api.html#cobrak.genetic.COBRAKGENETIC.run","title":"<code>run()</code>","text":"<p>Runs the genetic algorithm optimization.</p> <p>Returns:</p> Type Description <code>float</code> <p>tuple[float, tuple[int, ...]]: A tuple containing the best fitness score and the</p> <code>tuple[int, ...]</code> <p>corresponding solution.</p> Source code in <code>cobrak/genetic.py</code> <pre><code>def run(self) -&gt; tuple[float, tuple[int, ...]]:\n    \"\"\"Runs the genetic algorithm optimization.\n\n    Returns:\n        tuple[float, tuple[int, ...]]: A tuple containing the best fitness score and the\n        corresponding solution.\n    \"\"\"\n    init_fitnesses = Parallel(n_jobs=-1)(\n        delayed(self.fitness_function)(x) for x in self.init_xs\n    )\n    if init_fitnesses is not None:\n        self.tested_xs = {}\n        for init_fitness in init_fitnesses:\n            for fitness, xs in init_fitness:\n                self.tested_xs[tuple(xs)] = fitness\n    else:\n        print(\"ERROR: Something went wrong during initialization\")\n        raise ValueError\n\n    if self.objvalue_json_path:\n        start_time = time()\n        self.objvalue_json_data[0.0] = sorted(self.tested_xs.values())\n        json_write(self.objvalue_json_path, self.objvalue_json_data)\n\n    # Actual algorithm\n    max_objvalues = []\n    for _ in range(self.gen):\n        max_objvalues.append(max(self.tested_xs.values()))\n        if last_n_elements_equal(max_objvalues, self.max_rounds_same_objvalue):  # type: ignore\n            break\n\n        xs_list = self._get_sorted_list_from_tested_xs()\n        xs_list = [xs for xs in xs_list if len(xs) &gt; 0]\n\n        chosen_xs: list[tuple[int, ...]] = []\n        # Choose some of the top 3\n        for _ in range(self.cpu_count // 4):\n            chosen_xs.append(choice([x[1] for x in xs_list if len(x[1]) &gt; 0][:3]))\n\n        # Choose some of the 25% best\n        for _ in range(self.cpu_count // 2):\n            chosen_xs.append(\n                choice([x[1] for x in xs_list][: round(len(xs_list) * 0.25)])\n            )\n\n        # Choose some other 75% worst\n        for _ in range(self.cpu_count // 4):\n            addlength = 0\n            while not addlength:\n                added_xs = deepcopy(\n                    choice([x[1] for x in xs_list][round(len(xs_list) * 0.25) :])\n                )\n                addlength = len(added_xs)\n            chosen_xs.append(added_xs)\n\n        # Random crossovers\n        for _ in range(round(len(chosen_xs) * 0.2)):\n            target = randint(0, len(chosen_xs) - 1)\n            source = randint(0, len(chosen_xs) - 1)\n            cut = randint(0, self.xs_dim - 1)\n            chosen_xs[target] = deepcopy(chosen_xs[target][:cut]) + deepcopy(\n                chosen_xs[source][cut:]\n            )\n\n        # Test Xs in parallel\n        results = Parallel(n_jobs=-1, verbose=10)(\n            delayed(self.update_particle)(\n                chosen_x,\n                count_last_equal_elements(max_objvalues),\n            )\n            for chosen_x in chosen_xs\n        )\n\n        if results is None:\n            print(\"ERROR: Something went wrong during fitness calculations\")\n            raise ValueError\n\n        # Unpack results\n        for fitnesses_and_active_xs, mutated_x in results:\n            for fitness, active_x in fitnesses_and_active_xs:\n                if active_x is None or active_x == []:\n                    continue\n                self.tested_xs[tuple(active_x)] = fitness\n                self.all_xs[tuple(active_x)] = fitness\n            self.all_xs[tuple(mutated_x)] = max(\n                fitness for (fitness, _) in fitnesses_and_active_xs\n            )\n\n        if self.objvalue_json_path:\n            self.objvalue_json_data[time() - start_time] = sorted(\n                self.tested_xs.values()\n            )\n            json_write(self.objvalue_json_path, self.objvalue_json_data)\n\n    best_f_and_x = self._get_sorted_list_from_tested_xs()[0]\n    return best_f_and_x[0], best_f_and_x[1]\n</code></pre>"},{"location":"api.html#cobrak.genetic.COBRAKGENETIC.update_particle","title":"<code>update_particle(chosen_x, num_rounds_without_best_change)</code>","text":"<p>Updates a single particle by introducing mutations.</p> <p>Parameters:</p> Name Type Description Default <code>chosen_x</code> <code>list[int]</code> <p>The current solution represented as a list of integers.</p> required <code>num_rounds_without_best_change</code> <code>int</code> <p>The number of rounds without a change in the best fitness score.</p> required <p>Returns:</p> Type Description <code>float</code> <p>tuple[list[list[float]], list[int]]: A tuple containing a list of fitness scores</p> <code>list[int]</code> <p>and the mutated solution.</p> Source code in <code>cobrak/genetic.py</code> <pre><code>def update_particle(\n    self,\n    chosen_x: list[int],\n    num_rounds_without_best_change: int,\n) -&gt; tuple[float, list[int], list[int]]:\n    \"\"\"Updates a single particle by introducing mutations.\n\n    Args:\n        chosen_x (list[int]): The current solution represented as a list of integers.\n        num_rounds_without_best_change (int): The number of rounds without a change in the\n            best fitness score.\n\n    Returns:\n        tuple[list[list[float]], list[int]]: A tuple containing a list of fitness scores\n        and the mutated solution.\n    \"\"\"\n    if not len(chosen_x):\n        return [[1_000_000, []]], []\n\n    min_change_p = 0.1 * 0.95**num_rounds_without_best_change\n    max_change_p = 0.1 * 1.05**num_rounds_without_best_change\n    change_p = uniform(min_change_p, max_change_p)\n    change_p = max(0.001, change_p)\n    change_p = min(0.999, change_p)\n\n    mutation_tries = 0\n    while True:\n        mutated_x: list[float] = []\n        match randint(0, 2):\n            case 0:  # Extend\n                for x in chosen_x:\n                    if x == 1:\n                        mutated_x.append(1)\n                        continue\n                    if uniform(0.0, 1.0) &lt; change_p:\n                        mutated_x.append(1)\n                    else:\n                        mutated_x.append(x)\n            case 1:  # Decrease\n                for x in chosen_x:\n                    if x == 0:\n                        mutated_x.append(0)\n                        continue\n                    if uniform(0.0, 1.0) &lt; change_p:\n                        mutated_x.append(0)\n                    else:\n                        mutated_x.append(x)\n            case 2:  # Extend and decrease\n                for x in chosen_x:\n                    if x == 1:\n                        if uniform(0.0, 1.0) &lt; change_p:\n                            mutated_x.append(0)\n                        else:\n                            mutated_x.append(x)\n                    else:\n                        if uniform(0.0, 1.0) &lt; change_p:\n                            mutated_x.append(1)\n                        else:\n                            mutated_x.append(x)\n            # case 3:  # Random\n            #    mutated_x = [randint(0, 1) for _ in range(len(chosen_x))]\n\n        if mutation_tries &gt; 250:\n            return [[1_000_000, []]], []\n        if tuple(mutated_x) in self.all_xs:\n            mutation_tries += 1\n        else:\n            break\n\n    # Evaluate new position\n    fitnesses_and_active_xs = self.fitness_function(mutated_x)\n\n    return fitnesses_and_active_xs, mutated_x\n</code></pre>"},{"location":"api.html#cobrak.io","title":"<code>io</code>","text":"<p>General (COBRAk-independent) helper functions, primarily for I/O tasks such as pickle and JSON file handlings.</p>"},{"location":"api.html#cobrak.io.convert_cobrak_model_to_annotated_cobrapy_model","title":"<code>convert_cobrak_model_to_annotated_cobrapy_model(cobrak_model, combine_base_reactions=False, add_enzyme_constraints=False)</code>","text":"<p>Converts a COBRAk model to an annotated COBRApy model.</p> <p>This function takes a COBRAk model and converts it to a COBRApy model, adding annotations and constraints as specified by the input parameters.</p> <p>The function adds the following annotation keys to the COBRApy model:</p> <ul> <li><code>cobrak_Cmin</code>: The minimum concentration of a metabolite.</li> <li><code>cobrak_Cmax</code>: The maximum concentration of a metabolite.</li> <li><code>cobrak_id_&lt;version&gt;</code>: The ID of the reaction in the COBRAk model.</li> <li><code>cobrak_dG0_&lt;version&gt;</code>: The standard Gibbs free energy change of a reaction.</li> <li><code>cobrak_dG0_uncertainty_&lt;version&gt;</code>: The uncertainty of the standard Gibbs free energy change of a reaction.</li> <li><code>cobrak_k_cat_&lt;version&gt;</code>: The turnover number of an enzyme.</li> <li><code>cobrak_k_ms_&lt;version&gt;</code>: The Michaelis constant of an enzyme.</li> <li><code>cobrak_k_is_&lt;version&gt;</code>: The inhibition constant of an enzyme.</li> <li><code>cobrak_k_as_&lt;version&gt;</code>: The activation constant of an enzyme.</li> <li><code>cobrak_special_stoichiometries_&lt;version&gt;</code>: Special stoichiometries of a reaction.</li> <li><code>cobrak_max_prot_pool</code>: The maximum protein pool size.</li> <li><code>cobrak_R</code>: The gas constant.</li> <li><code>cobrak_T</code>: The temperature.</li> <li><code>cobrak_kinetic_ignored_metabolites</code>: A list of metabolites that are ignored in kinetic simulations.</li> <li><code>cobrak_extra_linear_constraints</code>: A list of extra linear constraints.</li> <li><code>cobrak_mw</code>: The molecular weight of an enzyme.</li> <li><code>cobrak_min_conc</code>: The minimum concentration of an enzyme.</li> <li><code>cobrak_max_conc</code>: The maximum concentration of an enzyme.</li> </ul> <p>The conversion process also involves the merging of forward and reverse reactions, as well as isomeric alternatives, into a single reaction in the COBRApy model. When the combine_base_reactions parameter is set to True, the function combines these reactions into a single entity, while still preserving the unique characteristics of each original reaction. To achieve this, the function uses a versioning system, denoted by the  suffix, to differentiate between the annotations of the original reactions. For example, the cobrak_id_ annotation key will contain the ID of the original reaction, with  indicating whether it corresponds to the forward or reverse direction, or an isomeric alternative. This versioning system allows the model to retain the distinct properties of each reaction, such as their standard Gibbs free energy changes or enzyme kinetics, while still representing them as a single, unified reaction. The  suffix can take on values such as V0, V1, etc., with each value corresponding to a specific original reaction. <p>The conversion of a COBRAk model to a COBRApy model also includes the optional direct addition of enzyme constraints in the style of GECKO [1] (or expaned sMOMENT [2]), which can be enabled through the add_enzyme_constraints parameter. When this parameter is set to True, the function introduces new pseudo-metabolites and pseudo-reactions to the model, allowing for the simulation of enzyme kinetics and protein expression. Specifically, a protein pool pseudo-metabolite is added, which represents the total amount of protein available in the system. Additionally, pseudo-reactions are created to deliver enzymes to the protein pool, taking into account the molecular weight and concentration of each enzyme. The function also adds pseudo-reactions to form enzyme complexes, which are essential for simulating the k_cat-based kinetics of enzymatic reactions.</p> <p>[1] https://doi.org/10.15252/msb.20167411 [2] https://doi.org/10.1186/s12859-019-3329-9</p>"},{"location":"api.html#cobrak.io.convert_cobrak_model_to_annotated_cobrapy_model--parameters","title":"Parameters","text":"<p>cobrak_model : Model     The COBRAk model to be converted. combine_base_reactions : bool, optional     Whether to combine base reactions into a single reaction (default: False). add_enzyme_constraints : bool, optional     Whether to add enzyme constraints to the model (default: False).</p>"},{"location":"api.html#cobrak.io.convert_cobrak_model_to_annotated_cobrapy_model--returns","title":"Returns","text":"<p>cobra.Model     The converted COBRApy model.</p>"},{"location":"api.html#cobrak.io.convert_cobrak_model_to_annotated_cobrapy_model--raises","title":"Raises","text":"<p>ValueError     If combine_base_reactions and add_enzyme_constraints are both True.</p> Source code in <code>cobrak/io.py</code> <pre><code>@validate_call\ndef convert_cobrak_model_to_annotated_cobrapy_model(\n    cobrak_model: Model,\n    combine_base_reactions: bool = False,\n    add_enzyme_constraints: bool = False,\n) -&gt; cobra.Model:\n    \"\"\"Converts a COBRAk model to an annotated COBRApy model.\n\n    This function takes a COBRAk model and converts it to a COBRApy model,\n    adding annotations and constraints as specified by the input parameters.\n\n    The function adds the following annotation keys to the COBRApy model:\n\n    * `cobrak_Cmin`: The minimum concentration of a metabolite.\n    * `cobrak_Cmax`: The maximum concentration of a metabolite.\n    * `cobrak_id_&lt;version&gt;`: The ID of the reaction in the COBRAk model.\n    * `cobrak_dG0_&lt;version&gt;`: The standard Gibbs free energy change of a reaction.\n    * `cobrak_dG0_uncertainty_&lt;version&gt;`: The uncertainty of the standard Gibbs free energy change of a reaction.\n    * `cobrak_k_cat_&lt;version&gt;`: The turnover number of an enzyme.\n    * `cobrak_k_ms_&lt;version&gt;`: The Michaelis constant of an enzyme.\n    * `cobrak_k_is_&lt;version&gt;`: The inhibition constant of an enzyme.\n    * `cobrak_k_as_&lt;version&gt;`: The activation constant of an enzyme.\n    * `cobrak_special_stoichiometries_&lt;version&gt;`: Special stoichiometries of a reaction.\n    * `cobrak_max_prot_pool`: The maximum protein pool size.\n    * `cobrak_R`: The gas constant.\n    * `cobrak_T`: The temperature.\n    * `cobrak_kinetic_ignored_metabolites`: A list of metabolites that are ignored in kinetic simulations.\n    * `cobrak_extra_linear_constraints`: A list of extra linear constraints.\n    * `cobrak_mw`: The molecular weight of an enzyme.\n    * `cobrak_min_conc`: The minimum concentration of an enzyme.\n    * `cobrak_max_conc`: The maximum concentration of an enzyme.\n\n    The conversion process also involves the merging of forward and reverse reactions, as well as isomeric alternatives,\n    into a single reaction in the COBRApy model. When the combine_base_reactions parameter is set to True,\n    the function combines these reactions into a single entity, while still preserving the unique characteristics\n    of each original reaction. To achieve this, the function uses a versioning system, denoted by the &lt;version&gt; suffix,\n    to differentiate between the annotations of the original reactions. For example, the cobrak_id_&lt;version&gt; annotation\n    key will contain the ID of the original reaction, with &lt;version&gt; indicating whether it corresponds to the forward or\n    reverse direction, or an isomeric alternative. This versioning system allows the model to retain the distinct properties\n    of each reaction, such as their standard Gibbs free energy changes or enzyme kinetics, while still representing them as\n    a single, unified reaction. The &lt;version&gt; suffix can take on values such as V0, V1, etc., with each value corresponding\n    to a specific original reaction.\n\n    The conversion of a COBRAk model to a COBRApy model also includes the optional direct addition of enzyme constraints\n    in the style of GECKO [1] (or expaned sMOMENT [2]),\n    which can be enabled through the add_enzyme_constraints parameter. When this parameter is set to True,\n    the function introduces new pseudo-metabolites and pseudo-reactions to the model, allowing for the simulation\n    of enzyme kinetics and protein expression. Specifically, a protein pool pseudo-metabolite is added, which\n    represents the total amount of protein available in the system. Additionally, pseudo-reactions are created\n    to deliver enzymes to the protein pool, taking into account the molecular weight and concentration of each enzyme.\n    The function also adds pseudo-reactions to form enzyme complexes, which are essential for simulating the k_cat-based kinetics\n    of enzymatic reactions.\n\n    [1] https://doi.org/10.15252/msb.20167411\n    [2] https://doi.org/10.1186/s12859-019-3329-9\n\n    Parameters\n    ----------\n    cobrak_model : Model\n        The COBRAk model to be converted.\n    combine_base_reactions : bool, optional\n        Whether to combine base reactions into a single reaction (default: False).\n    add_enzyme_constraints : bool, optional\n        Whether to add enzyme constraints to the model (default: False).\n\n    Returns\n    -------\n    cobra.Model\n        The converted COBRApy model.\n\n    Raises\n    ------\n    ValueError\n        If combine_base_reactions and add_enzyme_constraints are both True.\n    \"\"\"\n    if combine_base_reactions and add_enzyme_constraints:\n        print(\n            \"ERROR: Stoichiometric enzyme constraints do not work with combined base reactions\\n\"\n            \"       as for these enzyme constraints, reactions must remain irreversible.\"\n        )\n        raise ValueError\n\n    cobra_model = cobra.Model()\n\n    # Add metabolites\n    added_metabolites: list[cobra.Metabolite] = []\n    for met_id, met_data in cobrak_model.metabolites.items():\n        cobra_metabolite: cobra.Metabolite = cobra.Metabolite(\n            id=met_id,\n            compartment=met_id.split(\"_\")[-1] if \"_\" in met_id else \"c\",\n            name=met_data.name,\n            formula=met_data.formula,\n            charge=met_data.charge,\n        )\n        cobra_metabolite.annotation = met_data.annotation\n\n        # Add full annotation\n        cobra_metabolite.annotation[\"cobrak_Cmin\"] = exp(met_data.log_min_conc)\n        cobra_metabolite.annotation[\"cobrak_Cmax\"] = exp(met_data.log_max_conc)\n\n        added_metabolites.append(cobra_metabolite)\n    cobra_model.add_metabolites(added_metabolites)\n\n    if add_enzyme_constraints:\n        enzyme_reacs: list[cobra.Reaction] = []\n\n        # If set: Add protein pool reaction (flux in g\u22c5gDW\u207b\u00b9)\n        prot_pool_met = cobra.Metabolite(id=\"prot_pool\", compartment=\"c\")\n        cobra_model.add_metabolites([prot_pool_met])\n\n        prot_pool_reac = cobra.Reaction(\n            \"prot_pool_delivery\",\n            lower_bound=0.0,\n            upper_bound=cobrak_model.max_prot_pool,\n        )\n        prot_pool_reac.add_metabolites(\n            {\n                prot_pool_met: 1.0,\n            }\n        )\n        enzyme_reacs.append(prot_pool_reac)\n\n        # If set: Add enzyme concentration delivery reactions (flux in mmol\u22c5gDW\u207b\u00b9)\n        for enzyme_id, enzyme_data in cobrak_model.enzymes.items():\n            enzyme_met = cobra.Metabolite(id=enzyme_id, compartment=\"c\")\n\n            lower_bound = (\n                enzyme_data.min_conc if enzyme_data.min_conc is not None else 0.0\n            )\n            upper_bound = (\n                enzyme_data.max_conc if enzyme_data.max_conc is not None else 100_000.0\n            )\n            enzyme_reac = cobra.Reaction(\n                id=\"enzyme_delivery_\" + enzyme_id,\n                lower_bound=lower_bound,\n                upper_bound=upper_bound,\n            )\n            enzyme_reac.add_metabolites(\n                {\n                    prot_pool_met: -enzyme_data.molecular_weight,\n                    enzyme_met: 1.0,\n                }\n            )\n            enzyme_reacs.append(enzyme_reac)\n\n        cobra_model.add_reactions(enzyme_reacs)\n\n    # If set: Add enzyme complex metabolites and delivery reactions\n    if add_enzyme_constraints:\n        enzyme_complexes: set[tuple[str, ...]] = {\n            tuple(\n                enzyme_id\n                for enzyme_id in reaction_data.enzyme_reaction_data.identifiers\n            )\n            for reaction_data in cobrak_model.reactions.values()\n            if reaction_data.enzyme_reaction_data is not None\n        }\n        complex_reacs: list[cobra.Reaction] = []\n        for enzyme_complex in enzyme_complexes:\n            if len(enzyme_complex) &lt;= 1:\n                continue\n            if enzyme_complex == (\"\",):\n                continue\n            complex_met = cobra.Metabolite(id=\"_\".join(enzyme_complex), compartment=\"c\")\n            complex_reac = cobra.Reaction(\n                id=\"complex_delivery_\" + \"_\".join(enzyme_complex),\n                lower_bound=0.0,\n                upper_bound=10_000.0,\n            )\n            complex_reac.add_metabolites(\n                {\n                    cobra_model.metabolites.get_by_id(enzyme_id): -1\n                    for enzyme_id in enzyme_complex\n                    if enzyme_id\n                }\n            )\n            complex_reac.add_metabolites(\n                {\n                    complex_met: 1.0,\n                }\n            )\n            complex_reacs.append(complex_reac)\n        cobra_model.add_reactions(complex_reacs)\n\n    # Add reactions\n    added_reactions: list[cobra.Reaction] = []\n    if not combine_base_reactions:\n        for reac_id, reac_data in cobrak_model.reactions.items():\n            cobra_reaction = cobra.Reaction(\n                id=reac_id,\n                lower_bound=reac_data.min_flux,\n                upper_bound=reac_data.max_flux,\n                name=reac_data.name,\n            )\n            cobra_reaction.add_metabolites(\n                {\n                    cobra_model.metabolites.get_by_id(met_id): stoich\n                    for met_id, stoich in reac_data.stoichiometries.items()\n                }\n            )\n\n            # Add full annotation\n            _add_annotation_to_cobra_reaction(cobra_reaction, reac_id, reac_data, \"V0\")\n\n            if (\n                reac_data.enzyme_reaction_data is not None\n                and add_enzyme_constraints\n                and reac_data.enzyme_reaction_data.identifiers != []\n            ):\n                complex_met_id = \"_\".join(reac_data.enzyme_reaction_data.identifiers)\n                if complex_met_id:\n                    cobra_reaction.add_metabolites(\n                        {\n                            cobra_model.metabolites.get_by_id(complex_met_id): -1\n                            / reac_data.enzyme_reaction_data.k_cat\n                        }\n                    )\n            added_reactions.append(cobra_reaction)\n    else:\n        base_id_to_reac_ids: dict[str, list[str]] = {}\n        for reac_id in cobrak_model.reactions:\n            base_id = get_base_id(\n                reac_id,\n                cobrak_model.fwd_suffix,\n                cobrak_model.rev_suffix,\n                cobrak_model.reac_enz_separator,\n            )\n            if base_id not in base_id_to_reac_ids:\n                base_id_to_reac_ids[base_id] = []\n            base_id_to_reac_ids[base_id].append(reac_id)\n\n        for base_id, reac_ids in base_id_to_reac_ids.items():\n            rev_ids = [\n                reac_id\n                for reac_id in reac_ids\n                if reac_id.endswith(cobrak_model.rev_suffix)\n            ]\n            fwd_ids = [\n                reac_id\n                for reac_id in reac_ids\n                if not reac_id.endswith(cobrak_model.rev_suffix)\n            ]\n\n            if len(rev_ids) &gt; 0:\n                min_flux = -max(\n                    cobrak_model.reactions[rev_id].max_flux for rev_id in rev_ids\n                )\n                name = cobrak_model.reactions[rev_ids[0]].name\n            else:\n                min_flux = max(\n                    cobrak_model.reactions[fwd_id].min_flux for fwd_id in fwd_ids\n                )\n            if len(fwd_ids) &gt; 0:\n                max_flux = max(\n                    cobrak_model.reactions[fwd_id].max_flux for fwd_id in fwd_ids\n                )\n                met_stoichiometries = {\n                    cobra_model.metabolites.get_by_id(met_id): stoich\n                    for met_id, stoich in cobrak_model.reactions[\n                        fwd_ids[0]\n                    ].stoichiometries.items()\n                }\n                name = cobrak_model.reactions[fwd_ids[0]].name\n            else:\n                max_flux = min(\n                    cobrak_model.reactions[rev_id].max_flux for rev_id in rev_ids\n                )\n                met_stoichiometries = {\n                    cobra_model.metabolites.get_by_id(met_id): -stoich\n                    for met_id, stoich in cobrak_model.reactions[\n                        rev_ids[0]\n                    ].stoichiometries.items()\n                }\n\n            cobra_reaction = cobra.Reaction(\n                id=base_id,\n                lower_bound=min_flux,\n                upper_bound=max_flux,\n                name=name,\n            )\n            cobra_reaction.add_metabolites(met_stoichiometries)\n            for number, reac_id in enumerate(reac_ids):\n                version = f\"V{number}\"\n                reac_data = cobrak_model.reactions[reac_id]\n                _add_annotation_to_cobra_reaction(\n                    cobra_reaction, reac_id, reac_data, version\n                )\n\n            added_reactions.append(cobra_reaction)\n\n    # Add global information reaction\n    added_reactions.append(\n        cobra.Reaction(\n            id=\"cobrak_global_settings\",\n            lower_bound=0.0,\n            upper_bound=0.0,\n        )\n    )\n    added_reactions[-1].annotation[\"cobrak_max_prot_pool\"] = cobrak_model.max_prot_pool\n    added_reactions[-1].annotation[\"cobrak_R\"] = cobrak_model.R\n    added_reactions[-1].annotation[\"cobrak_T\"] = cobrak_model.T\n    added_reactions[-1].annotation[\"cobrak_kinetic_ignored_metabolites\"] = str(\n        cobrak_model.kinetic_ignored_metabolites\n    )\n    added_reactions[-1].annotation[\"cobrak_reac_rev_suffix\"] = cobrak_model.rev_suffix\n    added_reactions[-1].annotation[\"cobrak_reac_fwd_suffix\"] = cobrak_model.fwd_suffix\n    added_reactions[-1].annotation[\"cobrak_reac_enz_separator\"] = (\n        cobrak_model.reac_enz_separator\n    )\n    added_reactions[-1].annotation[\"cobrak_extra_linear_constraints\"] = str(\n        [asdict(x) for x in cobrak_model.extra_linear_constraints]\n    )\n\n    cobra_model.add_reactions(added_reactions)\n\n    gene_ids = [x.id for x in cobra_model.genes]\n    for enzyme_id, enzyme_data in cobrak_model.enzymes.items():\n        if enzyme_id not in gene_ids:\n            cobra_model.genes.append(cobra.Gene(enzyme_id, name=enzyme_data.name))\n        gene = cobra_model.genes.get_by_id(enzyme_id)\n        gene.annotation[\"cobrak_mw\"] = enzyme_data.molecular_weight\n        if enzyme_data.min_conc is not None:\n            gene.annotation[\"cobrak_min_conc\"] = enzyme_data.min_conc\n        if enzyme_data.max_conc is not None:\n            gene.annotation[\"cobrak_max_conc\"] = enzyme_data.max_conc\n\n    return cobra_model\n</code></pre>"},{"location":"api.html#cobrak.io.ensure_folder_existence","title":"<code>ensure_folder_existence(folder)</code>","text":"<p>Checks if the given folder exists. If not, the folder is created.</p>"},{"location":"api.html#cobrak.io.ensure_folder_existence--argument","title":"Argument","text":"<ul> <li>folder: str ~ The folder whose existence shall be enforced.</li> </ul> Source code in <code>cobrak/io.py</code> <pre><code>@validate_call\ndef ensure_folder_existence(folder: str) -&gt; None:\n    \"\"\"Checks if the given folder exists. If not, the folder is created.\n\n    Argument\n    ----------\n    * folder: str ~ The folder whose existence shall be enforced.\n    \"\"\"\n    if os.path.isdir(folder):\n        return\n    with contextlib.suppress(FileExistsError):\n        os.makedirs(folder)\n</code></pre>"},{"location":"api.html#cobrak.io.ensure_json_existence","title":"<code>ensure_json_existence(path)</code>","text":"<p>Ensures that a JSON file exists at the specified path.</p> <p>If the file does not exist, it creates an empty JSON file with \"{}\" as its content.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The file path where the JSON file should exist.</p> required Source code in <code>cobrak/io.py</code> <pre><code>@validate_call\ndef ensure_json_existence(path: str) -&gt; None:\n    \"\"\"Ensures that a JSON file exists at the specified path.\n\n    If the file does not exist, it creates an empty JSON file with \"{}\" as its content.\n\n    Args:\n        path (str): The file path where the JSON file should exist.\n    \"\"\"\n    if os.path.isfile(path):\n        return\n    with open(path, \"w\", encoding=\"utf-8\") as f:  # noqa: FURB103\n        f.write(\"{}\")\n</code></pre>"},{"location":"api.html#cobrak.io.get_base_id","title":"<code>get_base_id(reac_id, fwd_suffix=REAC_FWD_SUFFIX, rev_suffix=REAC_REV_SUFFIX, reac_enz_separator=REAC_ENZ_SEPARATOR)</code>","text":"<p>Extract the base ID from a reaction ID by removing specified suffixes and separators.</p> <p>Processes a reaction ID to remove forward and reverse suffixes as well as any enzyme separators, to obtain the base reaction ID.</p> <p>Parameters:</p> Name Type Description Default <code>reac_id</code> <code>str</code> <p>The reaction ID to be processed.</p> required <code>fwd_suffix</code> <code>str</code> <p>The suffix indicating forward reactions. Defaults to REAC_FWD_SUFFIX.</p> <code>REAC_FWD_SUFFIX</code> <code>rev_suffix</code> <code>str</code> <p>The suffix indicating reverse reactions. Defaults to REAC_REV_SUFFIX.</p> <code>REAC_REV_SUFFIX</code> <code>reac_enz_separator</code> <code>str</code> <p>The separator used between reaction and enzyme identifiers. Defaults to REAC_ENZ_SEPARATOR.</p> <code>REAC_ENZ_SEPARATOR</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The base reaction ID with specified suffixes and separators removed.</p> Source code in <code>cobrak/io.py</code> <pre><code>@validate_call\ndef get_base_id(\n    reac_id: str,\n    fwd_suffix: str = REAC_FWD_SUFFIX,\n    rev_suffix: str = REAC_REV_SUFFIX,\n    reac_enz_separator: str = REAC_ENZ_SEPARATOR,\n) -&gt; str:\n    \"\"\"Extract the base ID from a reaction ID by removing specified suffixes and separators.\n\n    Processes a reaction ID to remove forward and reverse suffixes\n    as well as any enzyme separators, to obtain the base reaction ID.\n\n    Args:\n        reac_id (str): The reaction ID to be processed.\n        fwd_suffix (str, optional): The suffix indicating forward reactions. Defaults to REAC_FWD_SUFFIX.\n        rev_suffix (str, optional): The suffix indicating reverse reactions. Defaults to REAC_REV_SUFFIX.\n        reac_enz_separator (str, optional): The separator used between reaction and enzyme identifiers. Defaults to REAC_ENZ_SEPARATOR.\n\n    Returns:\n        str: The base reaction ID with specified suffixes and separators removed.\n    \"\"\"\n    reac_id_split = reac_id.split(reac_enz_separator)\n    return (\n        (reac_id_split[0] + \"\\b\")\n        .replace(f\"{fwd_suffix}\\b\", \"\")\n        .replace(f\"{rev_suffix}\\b\", \"\")\n        .replace(\"\\b\", \"\")\n    )\n</code></pre>"},{"location":"api.html#cobrak.io.get_files","title":"<code>get_files(path)</code>","text":"<p>Returns the names of the files in the given folder as a list of strings.</p>"},{"location":"api.html#cobrak.io.get_files--arguments","title":"Arguments","text":"<ul> <li>path: str ~ The path to the folder of which the file names shall be returned</li> </ul> Source code in <code>cobrak/io.py</code> <pre><code>@validate_call\ndef get_files(path: str) -&gt; list[str]:\n    \"\"\"Returns the names of the files in the given folder as a list of strings.\n\n    Arguments\n    ----------\n    * path: str ~ The path to the folder of which the file names shall be returned\n    \"\"\"\n    files: list[str] = []\n    for _, _, filenames in os.walk(path):\n        files.extend(filenames)\n    return files\n</code></pre>"},{"location":"api.html#cobrak.io.get_folders","title":"<code>get_folders(path)</code>","text":"<p>Returns the names of the folders in the given folder as a list of strings.</p>"},{"location":"api.html#cobrak.io.get_folders--arguments","title":"Arguments","text":"<ul> <li>path: str ~ The path to the folder whose folders shall be returned</li> </ul> Source code in <code>cobrak/io.py</code> <pre><code>@validate_call\ndef get_folders(path: str) -&gt; list[str]:\n    \"\"\"Returns the names of the folders in the given folder as a list of strings.\n\n    Arguments\n    ----------\n    * path: str ~ The path to the folder whose folders shall be returned\n    \"\"\"\n    return [\n        folder\n        for folder in os.listdir(path)\n        if os.path.isdir(os.path.join(path, folder))\n    ]\n</code></pre>"},{"location":"api.html#cobrak.io.json_load","title":"<code>json_load(path, dataclass_type=Any)</code>","text":"<p>Load JSON data from a file and validate it against a specified dataclass type.</p> <p>This function reads the content of a JSON file located at the given <code>path</code>, parses it, and validates the parsed data against the provided <code>dataclass_type</code>. If the data is valid according to the dataclass schema, it returns an instance of the dataclass populated with the data. Otherwise, it raises an exception.</p>"},{"location":"api.html#cobrak.io.json_load--parameters","title":"Parameters:","text":"<p>path : str     The file path to the JSON file that needs to be loaded.</p> Type[T] <p>A dataclass type against which the JSON data should be validated and deserialized.</p>"},{"location":"api.html#cobrak.io.json_load--returns","title":"Returns:","text":"<p>T     An instance of the specified <code>dataclass_type</code> populated with the data from the JSON file.</p>"},{"location":"api.html#cobrak.io.json_load--raises","title":"Raises:","text":"<p>JSONDecodeError     If the content of the file is not a valid JSON string.</p> <p>ValidationError     If the parsed JSON data does not conform to the schema defined by <code>dataclass_type</code>.</p>"},{"location":"api.html#cobrak.io.json_load--examples","title":"Examples:","text":"<p>@dataclass ... class Person: ...     name: str ...     age: int</p> <p>person = json_load('person.json', Person) print(person.name, person.age) John Doe 30</p> Source code in <code>cobrak/io.py</code> <pre><code>@validate_call(config=ConfigDict(arbitrary_types_allowed=True))\ndef json_load(path: str, dataclass_type: T = Any) -&gt; T:\n    \"\"\"Load JSON data from a file and validate it against a specified dataclass type.\n\n    This function reads the content of a JSON file located at the given `path`, parses it,\n    and validates the parsed data against the provided `dataclass_type`. If the data is valid\n    according to the dataclass schema, it returns an instance of the dataclass populated with\n    the data. Otherwise, it raises an exception.\n\n    Parameters:\n    ----------\n    path : str\n        The file path to the JSON file that needs to be loaded.\n\n    dataclass_type : Type[T]\n        A dataclass type against which the JSON data should be validated and deserialized.\n\n    Returns:\n    -------\n    T\n        An instance of the specified `dataclass_type` populated with the data from the JSON file.\n\n    Raises:\n    ------\n    JSONDecodeError\n        If the content of the file is not a valid JSON string.\n\n    ValidationError\n        If the parsed JSON data does not conform to the schema defined by `dataclass_type`.\n\n    Examples:\n    --------\n    &gt;&gt;&gt; @dataclass\n    ... class Person:\n    ...     name: str\n    ...     age: int\n\n    &gt;&gt;&gt; person = json_load('person.json', Person)\n    &gt;&gt;&gt; print(person.name, person.age)\n    John Doe 30\n    \"\"\"\n    with open(path, encoding=\"utf-8\") as f:  # noqa: FURB101\n        data = f.read()\n\n    return TypeAdapter(dataclass_type).validate_json(data)\n</code></pre>"},{"location":"api.html#cobrak.io.json_write","title":"<code>json_write(path, json_data)</code>","text":"<p>Writes a JSON file at the given path with the given data as content.</p> <p>Can be also used for any of COBRAk's dataclasses as well as any dictionary of the form dict[str, dict[str, T] | None] where T stands for a COBRAk dataclass or any other JSON-compatible object type.</p>"},{"location":"api.html#cobrak.io.json_write--arguments","title":"Arguments","text":"<ul> <li>path: str ~  The path of the JSON file that shall be written</li> <li>json_data: Any ~ The dictionary or list which shalll be the content of   the created JSON file</li> </ul> Source code in <code>cobrak/io.py</code> <pre><code>@validate_call(config=ConfigDict(arbitrary_types_allowed=True))\ndef json_write(path: str, json_data: Any) -&gt; None:  # noqa: ANN401\n    \"\"\"Writes a JSON file at the given path with the given data as content.\n\n    Can be also used for any of COBRAk's dataclasses as well as any\n    dictionary of the form dict[str, dict[str, T] | None] where\n    T stands for a COBRAk dataclass or any other JSON-compatible\n    object type.\n\n    Arguments\n    ----------\n    * path: str ~  The path of the JSON file that shall be written\n    * json_data: Any ~ The dictionary or list which shalll be the content of\n      the created JSON file\n    \"\"\"\n    if is_dataclass(json_data):\n        json_write(path, asdict(json_data))\n    elif isinstance(json_data, BaseModel):\n        json_output = json_data.model_dump_json(indent=2)\n        with open(path, \"w+\", encoding=\"utf-8\") as f:\n            f.write(json_output)\n    elif isinstance(json_data, dict) and sum(\n        is_dataclass(value) for value in json_data.values()\n    ):\n        json_dict: dict[str, dict[str, Any] | None] = {}\n        for key, data in json_data.items():\n            if data is None:\n                json_dict[key] = None\n            elif is_dataclass(data):\n                json_dict[key] = asdict(data)\n            else:\n                json_dict[key] = data\n        json_write(path, json_dict)\n    else:\n        json_output = json.dumps(json_data, indent=4)\n        with open(path, \"w+\", encoding=\"utf-8\") as f:\n            f.write(json_output)\n</code></pre>"},{"location":"api.html#cobrak.io.json_zip_load","title":"<code>json_zip_load(path)</code>","text":"<p>Loads the given zipped JSON file and returns it as json_data (a list or a dictionary).</p>"},{"location":"api.html#cobrak.io.json_zip_load--arguments","title":"Arguments","text":"<ul> <li>path: str ~ The path of the JSON file without \".zip\" at the end</li> </ul>"},{"location":"api.html#cobrak.io.json_zip_load--returns","title":"Returns","text":"<p>dict or list ~ The loaded JSON data</p> Source code in <code>cobrak/io.py</code> <pre><code>@validate_call\ndef json_zip_load(path: str) -&gt; dict:\n    \"\"\"Loads the given zipped JSON file and returns it as json_data (a list\n    or a dictionary).\n\n    Arguments\n    ----------\n    * path: str ~ The path of the JSON file without \".zip\" at the end\n\n    Returns\n    -------\n    dict or list ~ The loaded JSON data\n    \"\"\"\n    # Create a temporary directory to extract the zip file contents\n    with tempfile.TemporaryDirectory() as temp_dir:\n        # Construct the full path to the zip file\n        zip_path = f\"{path}.zip\"\n\n        # Open the zip file and extract its contents to the temporary directory\n        with zipfile.ZipFile(zip_path, \"r\") as zip_file:\n            zip_file.extractall(temp_dir)\n\n        # Construct the full path to the JSON file in the temporary directory\n        json_path = os.path.join(temp_dir, os.path.basename(path))\n\n        # Open and load the JSON file\n        with open(json_path, encoding=\"utf-8\") as json_file:\n            json_data = json.load(json_file)\n\n    return json_data\n</code></pre>"},{"location":"api.html#cobrak.io.json_zip_write","title":"<code>json_zip_write(path, json_data, zip_method=zipfile.ZIP_LZMA)</code>","text":"<p>Writes a zipped JSON file at the given path with the given dictionary as content.</p>"},{"location":"api.html#cobrak.io.json_zip_write--arguments","title":"Arguments","text":"<ul> <li>path: str ~  The path of the JSON file that shall be written without \".zip\" at the end</li> <li>json_data: Any ~ The dictionary or list which shalll be the content of   the created JSON file</li> </ul> Source code in <code>cobrak/io.py</code> <pre><code>@validate_call(config=ConfigDict(arbitrary_types_allowed=True))\ndef json_zip_write(\n    path: str,\n    json_data: Any,  # noqa: ANN401\n    zip_method: int = zipfile.ZIP_LZMA,  # noqa: ANN401\n) -&gt; None:\n    \"\"\"Writes a zipped JSON file at the given path with the given dictionary as content.\n\n    Arguments\n    ----------\n    * path: str ~  The path of the JSON file that shall be written without \".zip\" at the end\n    * json_data: Any ~ The dictionary or list which shalll be the content of\n      the created JSON file\n    \"\"\"\n    json_output = json.dumps(json_data, indent=4).encode(\"utf-8\")\n    with ZipFile(path + \".zip\", \"w\", compression=zip_method) as zip_file:\n        zip_file.writestr(os.path.basename(path), json_output)\n</code></pre>"},{"location":"api.html#cobrak.io.load_annotated_cobrapy_model_as_cobrak_model","title":"<code>load_annotated_cobrapy_model_as_cobrak_model(cobra_model, exclude_enzyme_constraints=True)</code>","text":"<p>Converts a COBRApy model with (and also without :-) annotations into a COBRAk Model.</p> <p>This function takes a COBRApy model, which may contain specific annotations for metabolites, reactions, and genes, and converts it into a COBRAk model. The conversion involves extracting relevant annotations and constructing COBRAk-specific data structures for metabolites, reactions, and enzymes.</p> <ul> <li>cobra_model (cobra.Model): The COBRApy model to be converted. This model should contain   annotations that are compatible with the COBRAk model structure.</li> <li>exclude_enzyme_constraints (bool): Whether or not to exclude all stoichiometric enzyme constraint additions.   Defaults to True.</li> </ul> <ul> <li>Model: A COBRAk model constructed from the annotated COBRApy model, including metabolites,   reactions, and enzymes with their respective parameters and constraints.</li> </ul> <p>Notes: - The function assumes that certain annotations (e.g., \"cobrak_Cmin\", \"cobrak_dG0\") are present   in the COBRApy model. Missing annotations will result in default values being used. - Reactions with IDs like \"prot_pool_delivery\" and those starting with \"enzyme_delivery_\" are ignored. - Ensure that the COBRApy model is correctly annotated to fully leverage the conversion process.</p> Source code in <code>cobrak/io.py</code> <pre><code>@validate_call(config=ConfigDict(arbitrary_types_allowed=True))\ndef load_annotated_cobrapy_model_as_cobrak_model(\n    cobra_model: cobra.Model,\n    exclude_enzyme_constraints: bool = True,\n) -&gt; Model:\n    \"\"\"Converts a COBRApy model with (and also without :-) annotations into a COBRAk Model.\n\n    This function takes a COBRApy model, which may contain specific annotations for metabolites,\n    reactions, and genes, and converts it into a COBRAk model. The conversion involves extracting\n    relevant annotations and constructing COBRAk-specific data structures for metabolites, reactions,\n    and enzymes.\n\n    Parameters:\n    - cobra_model (cobra.Model): The COBRApy model to be converted. This model should contain\n      annotations that are compatible with the COBRAk model structure.\n    - exclude_enzyme_constraints (bool): Whether or not to exclude all stoichiometric enzyme constraint additions.\n      Defaults to True.\n\n    Returns:\n    - Model: A COBRAk model constructed from the annotated COBRApy model, including metabolites,\n      reactions, and enzymes with their respective parameters and constraints.\n\n    Notes:\n    - The function assumes that certain annotations (e.g., \"cobrak_Cmin\", \"cobrak_dG0\") are present\n      in the COBRApy model. Missing annotations will result in default values being used.\n    - Reactions with IDs like \"prot_pool_delivery\" and those starting with \"enzyme_delivery_\" are ignored.\n    - Ensure that the COBRApy model is correctly annotated to fully leverage the conversion process.\n    \"\"\"\n    if exclude_enzyme_constraints:\n        gene_ids = [gene.id for gene in cobra_model.genes]\n\n    if \"cobrak_global_settings\" in [x.id for x in cobra_model.reactions]:\n        global_settings_reac = cobra_model.reactions.get_by_id(\"cobrak_global_settings\")\n        max_prot_pool = float(global_settings_reac.annotation[\"cobrak_max_prot_pool\"])\n        kinetic_ignored_metabolites = literal_eval(\n            global_settings_reac.annotation[\"cobrak_kinetic_ignored_metabolites\"]\n        )\n        extra_linear_constraints = [\n            ExtraLinearConstraint(**x)\n            for x in literal_eval(\n                global_settings_reac.annotation[\"cobrak_extra_linear_constraints\"]\n            )\n        ]\n        R = float(global_settings_reac.annotation[\"cobrak_R\"])\n        T = float(global_settings_reac.annotation[\"cobrak_T\"])\n        reac_fwd_suffix = global_settings_reac.annotation[\"cobrak_reac_fwd_suffix\"]\n        reac_rev_suffix = global_settings_reac.annotation[\"cobrak_reac_rev_suffix\"]\n        reac_enz_separator = global_settings_reac.annotation[\n            \"cobrak_reac_enz_separator\"\n        ]\n    else:\n        max_prot_pool = 1_000.0\n        extra_linear_constraints = []\n        kinetic_ignored_metabolites = []\n        R = STANDARD_R\n        T = STANDARD_T\n        reac_fwd_suffix = REAC_FWD_SUFFIX\n        reac_rev_suffix = REAC_REV_SUFFIX\n        reac_enz_separator = REAC_ENZ_SEPARATOR\n\n    cobrak_metabolites: dict[str, Metabolite] = {}\n    for metabolite in cobra_model.metabolites:\n        if exclude_enzyme_constraints and sum(\n            met_split in gene_ids for met_split in metabolite.id.split(\"_\")\n        ):\n            continue\n\n        if \"cobrak_Cmin\" in metabolite.annotation:\n            log_min_conc = log(float(metabolite.annotation[\"cobrak_Cmin\"]))\n        else:\n            log_min_conc = log(1e-6)\n        if \"cobrak_Cmax\" in metabolite.annotation:\n            log_max_conc = log(float(metabolite.annotation[\"cobrak_Cmax\"]))\n        else:\n            log_max_conc = log(0.02)\n\n        cobrak_metabolites[metabolite.id] = Metabolite(\n            log_min_conc=log_min_conc,\n            log_max_conc=log_max_conc,\n            annotation={\n                key: literal_eval(value) if \"[\" in value else value\n                for key, value in metabolite.annotation.items()\n                if not key.startswith(\"cobrak_\")\n            },\n            formula=str(metabolite.formula),\n            charge=metabolite.charge,\n        )\n\n    cobrak_reactions: dict[str, Reaction] = {}\n    for reaction in cobra_model.reactions:\n        if (\n            reaction.id == \"prot_pool_delivery\"\n            or reaction.id.startswith(\"enzyme_delivery_\")\n            or reaction.id.startswith(\"complex_delivery_\")\n            or reaction.id.startswith(\"cobrak_global_settings\")\n        ):\n            continue\n\n        version_data = [\n            (key.replace(\"cobrak_id_\", \"\"), reaction.annotation[key])\n            for key in reaction.annotation\n            if key.startswith(\"cobrak_id_\")\n        ]\n        if version_data == []:\n            version_data = [(\"0\", reaction.id)]\n        for version, version_reac_id in version_data:\n            if f\"cobrak_dG0_{version}\" in reaction.annotation:\n                dG0 = float(reaction.annotation[f\"cobrak_dG0_{version}\"])\n            else:\n                dG0 = None\n            if f\"cobrak_dG0_uncertainty_{version}\" in reaction.annotation:\n                dG0_uncertainty = float(\n                    reaction.annotation[f\"cobrak_dG0_uncertainty_{version}\"]\n                )\n            else:\n                dG0_uncertainty = None\n\n            if f\"cobrak_k_cat_{version}\" in reaction.annotation:\n                if reac_enz_separator in version_reac_id:\n                    identifiers = (\n                        (\n                            version_reac_id.replace(\"_and\", \"\").split(\n                                reac_enz_separator\n                            )[1]\n                            + \"\\b\"\n                        )\n                        .replace(f\"{reac_fwd_suffix}\\b\", \"\")\n                        .replace(f\"{reac_rev_suffix}\\b\", \"\")\n                        .replace(\"\\b\", \"\")\n                        .split(\"_\")\n                    )\n                else:\n                    identifiers = reaction.gene_reaction_rule.split(\" and \")\n\n                k_cat = float(reaction.annotation[f\"cobrak_k_cat_{version}\"])\n                if f\"cobrak_k_ms_{version}\" in reaction.annotation:\n                    k_ms = literal_eval(reaction.annotation[f\"cobrak_k_ms_{version}\"])\n                else:\n                    k_ms = None\n                if f\"cobrak_k_is_{version}\" in reaction.annotation:\n                    k_is = literal_eval(reaction.annotation[f\"cobrak_k_is_{version}\"])\n                else:\n                    k_is = None\n                if f\"cobrak_k_as_{version}\" in reaction.annotation:\n                    k_as = literal_eval(reaction.annotation[f\"cobrak_k_as_{version}\"])\n                else:\n                    k_as = None\n                if f\"cobrak_special_stoichiometries_{version}\" in reaction.annotation:\n                    special_stoichiometries = literal_eval(\n                        reaction.annotation[f\"cobrak_special_stoichiometries_{version}\"]\n                    )\n                else:\n                    special_stoichiometries = {}\n                enzyme_reaction_data = EnzymeReactionData(\n                    identifiers=identifiers,\n                    k_cat=k_cat,\n                    k_ms=k_ms,\n                    k_is=k_is,\n                    k_as=k_as,\n                    special_stoichiometries=special_stoichiometries,\n                )\n            else:\n                enzyme_reaction_data = None\n\n            if len(version_data) &gt; 1:\n                if version_reac_id.endswith(reac_rev_suffix):\n                    stoich_multiplier = -1\n                    min_flux = 0.0\n                    max_flux = -reaction.lower_bound\n                else:\n                    stoich_multiplier = +1\n                    min_flux = 0.0\n                    max_flux = reaction.upper_bound\n            else:\n                min_flux = reaction.lower_bound\n                max_flux = reaction.upper_bound\n                stoich_multiplier = +1\n\n            cobrak_reactions[version_reac_id] = Reaction(\n                min_flux=min_flux,\n                max_flux=max_flux,\n                stoichiometries={\n                    metabolite.id: stoich_multiplier * value\n                    for (metabolite, value) in reaction.metabolites.items()\n                    if (not exclude_enzyme_constraints)\n                    or (\n                        not sum(\n                            met_split in gene_ids\n                            for met_split in metabolite.id.split(\"_\")\n                        )\n                    )\n                },\n                dG0=dG0,\n                dG0_uncertainty=dG0_uncertainty,\n                enzyme_reaction_data=enzyme_reaction_data,\n                annotation={\n                    key: literal_eval(value) if \"[\" in value else value\n                    for key, value in reaction.annotation.items()\n                    if not key.startswith(\"cobrak_\")\n                },\n            )\n\n    cobrak_enzymes: dict[str, Enzyme] = {}\n    for gene in cobra_model.genes:\n        if \"cobrak_mw\" in gene.annotation:\n            if \"cobrak_min_conc\" in gene.annotation:\n                min_conc = float(gene.annotation[\"cobrak_min_conc\"])\n            else:\n                min_conc = None\n            if \"cobrak_max_conc\" in gene.annotation:\n                max_conc = float(gene.annotation[\"cobrak_max_conc\"])\n            else:\n                max_conc = None\n            cobrak_enzymes[gene.id] = Enzyme(\n                molecular_weight=float(gene.annotation[\"cobrak_mw\"]),\n                min_conc=min_conc,\n                max_conc=max_conc,\n                name=gene.name,\n            )\n\n    return Model(\n        reactions=cobrak_reactions,\n        metabolites=cobrak_metabolites,\n        enzymes=cobrak_enzymes,\n        max_prot_pool=max_prot_pool,\n        extra_linear_constraints=extra_linear_constraints,\n        kinetic_ignored_metabolites=kinetic_ignored_metabolites,\n        R=R,\n        T=T,\n        fwd_suffix=reac_fwd_suffix,\n        rev_suffix=reac_rev_suffix,\n        reac_enz_separator=reac_enz_separator,\n    )\n</code></pre>"},{"location":"api.html#cobrak.io.load_annotated_sbml_model_as_cobrak_model","title":"<code>load_annotated_sbml_model_as_cobrak_model(filepath)</code>","text":"<p>Load an annotated (and also un-annotated :-) SBML model from a file and convert it into a COBRAk Model.</p> <p>This function reads an SBML file containing a metabolic model with specific annotations and converts it into a COBRAk Model. It uses the COBRApy library to read the SBML file and then uses the <code>load_annotated_cobrapy_model_as_cobrak_model</code> function to perform the conversion.</p> <p>Parameters: - filepath (str): The path to the SBML file containing the annotated metabolic model.</p> <ul> <li>Model: A COBRAk Model constructed from the annotated SBML model, ready for further   kinetic and thermodynamic analyses.</li> </ul> Source code in <code>cobrak/io.py</code> <pre><code>@validate_call\ndef load_annotated_sbml_model_as_cobrak_model(\n    filepath: str,\n) -&gt; Model:\n    \"\"\"\n    Load an annotated (and also un-annotated :-) SBML model from a file and convert it into a COBRAk Model.\n\n    This function reads an SBML file containing a metabolic model with specific annotations\n    and converts it into a COBRAk Model. It uses the COBRApy library to read the SBML\n    file and then uses the `load_annotated_cobrapy_model_as_cobrak_model` function to perform\n    the conversion.\n\n    Parameters:\n    - filepath (str): The path to the SBML file containing the annotated metabolic model.\n\n    Returns:\n    - Model: A COBRAk Model constructed from the annotated SBML model, ready for further\n      kinetic and thermodynamic analyses.\n    \"\"\"\n    return load_annotated_cobrapy_model_as_cobrak_model(\n        cobra.io.read_sbml_model(filepath)\n    )\n</code></pre>"},{"location":"api.html#cobrak.io.load_unannotated_sbml_as_cobrapy_model","title":"<code>load_unannotated_sbml_as_cobrapy_model(path)</code>","text":"<p>Loads an unannotated SBML model from a file into a COBRApy model.</p> <p>This function reads an SBML file that contains a metabolic model without specific annotations and loads it into a COBRApy model object. It utilizes the COBRApy library's <code>read_sbml_model</code> function to perform the loading.</p> <p>Parameters: - path (str): The file path to the SBML file containing the metabolic model.</p> <p>Returns: - cobra.Model: A COBRApy model object representing the metabolic network described in the SBML file.</p> Source code in <code>cobrak/io.py</code> <pre><code>@validate_call\ndef load_unannotated_sbml_as_cobrapy_model(path: str) -&gt; cobra.Model:\n    \"\"\"Loads an unannotated SBML model from a file into a COBRApy model.\n\n    This function reads an SBML file that contains a metabolic model without specific annotations\n    and loads it into a COBRApy model object. It utilizes the COBRApy library's `read_sbml_model`\n    function to perform the loading.\n\n    Parameters:\n    - path (str): The file path to the SBML file containing the metabolic model.\n\n    Returns:\n    - cobra.Model: A COBRApy model object representing the metabolic network described in the SBML file.\n    \"\"\"\n    return cobra.io.read_sbml_model(path)\n</code></pre>"},{"location":"api.html#cobrak.io.pickle_load","title":"<code>pickle_load(path)</code>","text":"<p>Returns the value of the given pickle file.</p>"},{"location":"api.html#cobrak.io.pickle_load--arguments","title":"Arguments","text":"<ul> <li>path: str ~ The path to the pickle file.</li> </ul> Source code in <code>cobrak/io.py</code> <pre><code>@validate_call\ndef pickle_load(path: str) -&gt; Any:  # noqa: ANN401\n    \"\"\"Returns the value of the given pickle file.\n\n    Arguments\n    ----------\n    * path: str ~ The path to the pickle file.\n    \"\"\"\n    with open(path, \"rb\") as pickle_file:\n        return pickle.load(pickle_file)\n</code></pre>"},{"location":"api.html#cobrak.io.pickle_write","title":"<code>pickle_write(path, pickled_object)</code>","text":"<p>Writes the given object as pickled file with the given path</p>"},{"location":"api.html#cobrak.io.pickle_write--arguments","title":"Arguments","text":"<ul> <li>path: str ~ The path of the pickled file that shall be created</li> <li>pickled_object: Any ~ The object which shall be saved in the pickle file</li> </ul> Source code in <code>cobrak/io.py</code> <pre><code>@validate_call(config=ConfigDict(arbitrary_types_allowed=True))\ndef pickle_write(path: str, pickled_object: Any) -&gt; None:  # noqa: ANN401\n    \"\"\"Writes the given object as pickled file with the given path\n\n    Arguments\n    ----------\n    * path: str ~ The path of the pickled file that shall be created\n    * pickled_object: Any ~ The object which shall be saved in the pickle file\n    \"\"\"\n    with open(path, \"wb\") as pickle_file:\n        pickle.dump(pickled_object, pickle_file)\n</code></pre>"},{"location":"api.html#cobrak.io.save_cobrak_model_as_annotated_sbml_model","title":"<code>save_cobrak_model_as_annotated_sbml_model(cobrak_model, filepath, combine_base_reactions=False, add_enzyme_constraints=False)</code>","text":"<p>Exports a COBRAk model to an annotated SBML file.</p> <p>This function converts a <code>Model</code> to a COBRApy model and writes it to an SBML file at the specified file path. Optionally, stoichiometric GECKO [1]-like enzyme constraints can be added during the conversion.</p> <p>[1] S\u00e1nchez et al. Molecular systems biology, 13(8), 935. https://doi.org/10.15252/msb.20167411</p> <p>Parameters:</p> Name Type Description Default <code>cobrak_model</code> <code>Model</code> <p>The <code>Model</code> to be exported.</p> required <code>filepath</code> <code>str</code> <p>The file path where the SBML file will be saved.</p> required <code>add_enzyme_constraints</code> <code>bool</code> <p>Whether to add enzyme constraints during the conversion. Defaults to False.</p> <code>False</code> Source code in <code>cobrak/io.py</code> <pre><code>@validate_call\ndef save_cobrak_model_as_annotated_sbml_model(\n    cobrak_model: Model,\n    filepath: str,\n    combine_base_reactions: bool = False,\n    add_enzyme_constraints: bool = False,\n) -&gt; None:\n    \"\"\"Exports a COBRAk model to an annotated SBML file.\n\n    This function converts a `Model` to a COBRApy model and writes it to an SBML file at the specified file path.\n    Optionally, stoichiometric GECKO [1]-like enzyme constraints can be added during the conversion.\n\n    [1] S\u00e1nchez et al. Molecular systems biology, 13(8), 935. https://doi.org/10.15252/msb.20167411\n\n    Args:\n        cobrak_model (Model): The `Model` to be exported.\n        filepath (str): The file path where the SBML file will be saved.\n        add_enzyme_constraints (bool, optional): Whether to add enzyme constraints during the conversion. Defaults to False.\n    \"\"\"\n    cobra.io.write_sbml_model(\n        convert_cobrak_model_to_annotated_cobrapy_model(\n            cobrak_model,\n            combine_base_reactions,\n            add_enzyme_constraints,\n        ),\n        filepath,\n    )\n</code></pre>"},{"location":"api.html#cobrak.io.standardize_folder","title":"<code>standardize_folder(folder)</code>","text":"<p>Returns for the given folder path is returned in a more standardized way.</p> <p>I.e., folder paths with potential \\ are replaced with /. In addition, if a path does not end with / will get an added /. If the given folder path is empty (''), it returns just ''.</p>"},{"location":"api.html#cobrak.io.standardize_folder--argument","title":"Argument","text":"<ul> <li>folder: str ~ The folder path that shall be standardized.</li> </ul> Source code in <code>cobrak/io.py</code> <pre><code>@validate_call\ndef standardize_folder(folder: str) -&gt; str:\n    \"\"\"Returns for the given folder path is returned in a more standardized way.\n\n    I.e., folder paths with potential \\\\ are replaced with /. In addition, if\n    a path does not end with / will get an added /.\n    If the given folder path is empty (''), it returns just ''.\n\n    Argument\n    ----------\n    * folder: str ~ The folder path that shall be standardized.\n    \"\"\"\n    # Catch empty folders as they don't need to be standardized\n    if not folder:\n        return \"\"\n\n    # Standardize for \\ or / as path separator character.\n    folder = folder.replace(\"\\\\\", \"/\")\n\n    # If the last character is not a path separator, it is\n    # added so that all standardized folder path strings\n    # contain it.\n    if folder[-1] != \"/\":\n        folder += \"/\"\n\n    return folder\n</code></pre>"},{"location":"api.html#cobrak.lps","title":"<code>lps</code>","text":"<p>COBRAk LPs and MILPs.</p> <p>This file contains all linear program (LP) and mixed-integer linear program (MILP) functions that can be used with COBRAk models. With LP, one can integrate stoichiometric and enzymatic constraints. With MILP, one can additionally integrate thermodynamic constraints. For non-linear-programs (NLP), see nlps.py in the same folder.</p>"},{"location":"api.html#cobrak.lps.add_flux_sum_var","title":"<code>add_flux_sum_var(model, cobrak_model)</code>","text":"<p>Add a flux sum variable to a (N/MI)LP model.</p> <p>This function introduces a flux sum variable to a given (N/MI)LP Pyomo model, which represents the total sum of absolute fluxes across all reactions in the COBRAk model. The methodology is based on the pFBA (Parsimonious Flux Balance Analysis) approach [1].</p> <p>[1] Lewis et al. Molecular systems biology 6.1 (2010): 390. https://doi.org/10.1038/msb.2010.47</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>ConcreteModel</code> <p>The Pyomo instance of the (N/MI)LP model.</p> required <code>cobrak_model</code> <code>Model</code> <p>The associated metabolic model containing reaction data.</p> required <p>Returns:</p> Name Type Description <code>ConcreteModel</code> <code>ConcreteModel</code> <p>The modified Pyomo model with the added flux sum variable and constraint.</p> Source code in <code>cobrak/lps.py</code> <pre><code>@validate_call(config=ConfigDict(arbitrary_types_allowed=True))\ndef add_flux_sum_var(model: ConcreteModel, cobrak_model: Model) -&gt; ConcreteModel:\n    \"\"\"Add a flux sum variable to a (N/MI)LP model.\n\n    This function introduces a flux sum variable to a given (N/MI)LP Pyomo model, which represents\n    the total sum of absolute fluxes across all reactions in the COBRAk model. The methodology is based on\n    the pFBA (Parsimonious Flux Balance Analysis) approach [1].\n\n    [1] Lewis et al. Molecular systems biology 6.1 (2010): 390. https://doi.org/10.1038/msb.2010.47\n\n    Args:\n        model (ConcreteModel): The Pyomo instance of the (N/MI)LP model.\n        cobrak_model (Model): The associated metabolic model containing reaction data.\n\n    Returns:\n        ConcreteModel: The modified Pyomo model with the added flux sum variable and constraint.\n    \"\"\"\n    flux_sum_expr = 0.0\n    for reac_id in cobrak_model.reactions:\n        try:\n            flux_sum_expr += getattr(model, reac_id)\n        except AttributeError:\n            continue\n\n    setattr(model, FLUX_SUM_VAR_ID, Var(within=Reals, bounds=(0.0, 1e9)))\n    setattr(\n        model,\n        \"FLUX_SUM_CONSTRAINT\",\n        Constraint(rule=getattr(model, FLUX_SUM_VAR_ID) == flux_sum_expr),\n    )\n\n    return model\n</code></pre>"},{"location":"api.html#cobrak.lps.add_loop_constraints_to_lp","title":"<code>add_loop_constraints_to_lp(model, cobrak_model, only_nonthermodynamic, ignored_reacs=[])</code>","text":"<p>Add mixed-integer loop constraints to a (N/MI)LP model to prevent thermodynamically infeasible cycles.</p> <p>This function incorporates loop constraints into a given (N/MI)LP Pyomo model based on the COBRAk model's reaction data. It follows the ll-COBRA methodology described in [1] to prevent the formation of thermodynamically infeasible cycles in metabolic networks.</p> <p>[1] Schellenberger et al. (2011). Biophysical journal, 100(3), 544-553. https://doi.org/10.1016/j.bpj.2010.12.3707</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>ConcreteModel</code> <p>The Pyomo instance of the (N/MI)LP model.</p> required <code>cobrak_model</code> <code>Model</code> <p>The associated metabolic model containing reaction data.</p> required <code>only_nonthermodynamic</code> <code>bool</code> <p>If True, only add constraints to reactions without thermodynamic data.</p> required <p>Returns:</p> Name Type Description <code>ConcreteModel</code> <code>ConcreteModel</code> <p>The modified Pyomo model with added loop constraints.</p> Source code in <code>cobrak/lps.py</code> <pre><code>@validate_call(config=ConfigDict(arbitrary_types_allowed=True))\ndef add_loop_constraints_to_lp(\n    model: ConcreteModel,\n    cobrak_model: Model,\n    only_nonthermodynamic: bool,\n    ignored_reacs: list[str] = [],\n) -&gt; ConcreteModel:\n    \"\"\"Add mixed-integer loop constraints to a (N/MI)LP model to prevent thermodynamically infeasible cycles.\n\n    This function incorporates loop constraints into a given (N/MI)LP Pyomo model based on the COBRAk model's\n    reaction data. It follows the ll-COBRA methodology described in [1] to prevent the formation\n    of thermodynamically infeasible cycles in metabolic networks.\n\n    [1] Schellenberger et al. (2011). Biophysical journal, 100(3), 544-553. https://doi.org/10.1016/j.bpj.2010.12.3707\n\n    Args:\n        model (ConcreteModel): The Pyomo instance of the (N/MI)LP model.\n        cobrak_model (Model): The associated metabolic model containing reaction data.\n        only_nonthermodynamic (bool): If True, only add constraints to reactions without thermodynamic data.\n\n    Returns:\n        ConcreteModel: The modified Pyomo model with added loop constraints.\n    \"\"\"\n    base_id_constraints: dict[str, Expression] = {}\n    num_elements_per_constraint = {}\n    for reac_id, reaction in cobrak_model.reactions.items():\n        if reac_id in ignored_reacs:\n            continue\n        if (only_nonthermodynamic) and (reaction.dG0 is not None):\n            continue\n\n        base_id = get_base_id(reac_id, cobrak_model.fwd_suffix, cobrak_model.rev_suffix)\n        if base_id not in base_id_constraints:\n            base_id_constraints[base_id] = 0.0\n            num_elements_per_constraint[base_id] = 0\n\n        zv_var_id = \"zV_var_\" + reac_id\n        setattr(model, zv_var_id, Var(within=Binary))\n        setattr(\n            model,\n            reac_id + \"_base\",\n            Constraint(\n                rule=getattr(model, reac_id) &lt;= BIG_M * getattr(model, zv_var_id)\n            ),\n        )\n\n        base_id_constraints[base_id] += getattr(model, zv_var_id)\n        num_elements_per_constraint[base_id] += 1\n\n    for base_id, constraint_lhs in base_id_constraints.items():\n        if num_elements_per_constraint[base_id] &gt; 1:\n            setattr(\n                model,\n                base_id + \"_base_constraint\",\n                Constraint(rule=constraint_lhs &lt;= 1.0),\n            )\n\n    return model\n</code></pre>"},{"location":"api.html#cobrak.lps.get_lp_from_cobrak_model","title":"<code>get_lp_from_cobrak_model(cobrak_model, with_enzyme_constraints, with_thermodynamic_constraints, with_loop_constraints, with_flux_sum_var=False, ignored_reacs=[], min_mdf=STANDARD_MIN_MDF, add_thermobottleneck_analysis_vars=False, strict_kappa_products_equality=False, add_extra_linear_constraints=True, correction_config=CorrectionConfig(), ignore_nonlinear_terms=False)</code>","text":"<p>Construct a linear programming (LP) model from a COBRAk model with various constraints and configurations.</p> <p>This function creates a steady-state LP model from the provided COBRAk Model and enhances it with different types of constraints and variables based on the specified parameters. It allows for the inclusion of enzyme constraints, thermodynamic constraints, loop constraints, and additional linear constraints. Furthermore, it supports the addition of flux sum variables and error handling configurations.</p> <p>See the following chapters of COBRAk's documentation for more on these constraints:</p> <ul> <li>Steady-state and extra linear constraints \u21d2 Chapter \"Linear Programs\"</li> <li>Enzyme constraints \u21d2 Chapter \"Linear Programs\"</li> <li>Thermodynamic constraints \u21d2 Chapter \"Mixed-Integer Linear Programs\"</li> </ul>"},{"location":"api.html#cobrak.lps.get_lp_from_cobrak_model--parameters","title":"Parameters","text":"<p>cobrak_model : Model     The COBRAk Model from which to construct the LP model. with_enzyme_constraints : bool     If True, adds enzyme-pool constraints to the model. with_thermodynamic_constraints : bool     If True, adds thermodynamic MILP constraints to the model, ensuring that reaction fluxes are     thermodynamically feasible by considering Gibbs free energy changes. with_loop_constraints : bool     If True, adds loop constraints to prevent or control flux loops in the metabolic network.     This constraint makes the LP a MILP as a binary variable controls whether either the     forward or the reverse reaction is running. with_flux_sum_var : bool, optional     If True, adds a flux sum variable to the model, which aggregates the total flux through     all reactions for optimization or analysis purposes. Defaults to False. ignored_reacs : list[str], optional     List of reaction IDs to ignore in the model, which will be excluded. Defaults to []. min_mdf : float, optional     Minimum value for Max-Min Driving Force (MDF). Only relevant with thermodynamic     constraints. Defaults to STANDARD_MIN_MDF. add_thermobottleneck_analysis_vars : bool, optional     If True, adds variables for thermodynamic bottleneck analysis, helping to identify     potential bottlenecks in the metabolic network where thermodynamic constraints might limit     flux. Defaults to False. strict_kappa_products_equality : bool, optional     If True, enforces strict equality for kappa products, ensuring consistency in     thermodynamic parameters related to reaction products. Defaults to False. add_extra_linear_constraints : bool, optional     If True, adds extra linear constraints from the COBRAk Mmodel, allowing for additional     linear constraints. Defaults to True. correction_config : CorrectionConfig, optional     Configuration for parameter correction handling in the model, allowing for the inclusion of error terms     in constraints related to enzyme activity, thermodynamics, etc. Defaults to CorrectionConfig(). ignore_nonlinear_terms: bool, optional     Whether or not non-linear extra watches and constraints shall not be included. Defaults to False.     Note: If such non-linear values exist and are included, the whole problem becomes non-linear, making it     incompatible with any purely linear solver!</p>"},{"location":"api.html#cobrak.lps.get_lp_from_cobrak_model--returns","title":"Returns","text":"<p>ConcreteModel     The constructed LP model with the specified constraints and configurations.</p> Source code in <code>cobrak/lps.py</code> <pre><code>@validate_call\ndef get_lp_from_cobrak_model(\n    cobrak_model: Model,\n    with_enzyme_constraints: bool,\n    with_thermodynamic_constraints: bool,\n    with_loop_constraints: bool,\n    with_flux_sum_var: bool = False,\n    ignored_reacs: list[str] = [],\n    min_mdf: float = STANDARD_MIN_MDF,\n    add_thermobottleneck_analysis_vars: bool = False,\n    strict_kappa_products_equality: bool = False,\n    add_extra_linear_constraints: bool = True,\n    correction_config: CorrectionConfig = CorrectionConfig(),\n    ignore_nonlinear_terms: bool = False,\n) -&gt; ConcreteModel:\n    \"\"\"Construct a linear programming (LP) model from a COBRAk model with various constraints and configurations.\n\n    This function creates a steady-state LP model from the provided COBRAk Model and enhances it with\n    different types of constraints and variables based on the specified parameters. It allows for the\n    inclusion of enzyme constraints, thermodynamic constraints, loop constraints, and additional\n    linear constraints. Furthermore, it supports the addition of flux sum variables and error handling\n    configurations.\n\n    See the following chapters of COBRAk's documentation for more on these constraints:\n\n    * Steady-state and extra linear constraints \u21d2 Chapter \"Linear Programs\"\n    * Enzyme constraints \u21d2 Chapter \"Linear Programs\"\n    * Thermodynamic constraints \u21d2 Chapter \"Mixed-Integer Linear Programs\"\n\n    Parameters\n    ----------\n    cobrak_model : Model\n        The COBRAk Model from which to construct the LP model.\n    with_enzyme_constraints : bool\n        If True, adds enzyme-pool constraints to the model.\n    with_thermodynamic_constraints : bool\n        If True, adds thermodynamic MILP constraints to the model, ensuring that reaction fluxes are\n        thermodynamically feasible by considering Gibbs free energy changes.\n    with_loop_constraints : bool\n        If True, adds loop constraints to prevent or control flux loops in the metabolic network.\n        This constraint makes the LP a MILP as a binary variable controls whether either the\n        forward or the reverse reaction is running.\n    with_flux_sum_var : bool, optional\n        If True, adds a flux sum variable to the model, which aggregates the total flux through\n        all reactions for optimization or analysis purposes. Defaults to False.\n    ignored_reacs : list[str], optional\n        List of reaction IDs to ignore in the model, which will be excluded. Defaults to [].\n    min_mdf : float, optional\n        Minimum value for Max-Min Driving Force (MDF). Only relevant with thermodynamic\n        constraints. Defaults to STANDARD_MIN_MDF.\n    add_thermobottleneck_analysis_vars : bool, optional\n        If True, adds variables for thermodynamic bottleneck analysis, helping to identify\n        potential bottlenecks in the metabolic network where thermodynamic constraints might limit\n        flux. Defaults to False.\n    strict_kappa_products_equality : bool, optional\n        If True, enforces strict equality for kappa products, ensuring consistency in\n        thermodynamic parameters related to reaction products. Defaults to False.\n    add_extra_linear_constraints : bool, optional\n        If True, adds extra linear constraints from the COBRAk Mmodel, allowing for additional\n        linear constraints. Defaults to True.\n    correction_config : CorrectionConfig, optional\n        Configuration for parameter correction handling in the model, allowing for the inclusion of error terms\n        in constraints related to enzyme activity, thermodynamics, etc. Defaults to CorrectionConfig().\n    ignore_nonlinear_terms: bool, optional\n        Whether or not non-linear extra watches and constraints shall *not* be included. Defaults to False.\n        Note: If such non-linear values exist and are included, the whole problem becomes *non-linear*, making it\n        incompatible with any purely linear solver!\n\n    Returns\n    -------\n    ConcreteModel\n        The constructed LP model with the specified constraints and configurations.\n    \"\"\"\n    # Initialize the steady-state LP model from the COBRA model, ignoring specified reactions\n    model: ConcreteModel = _get_steady_state_lp_from_cobrak_model(\n        cobrak_model=cobrak_model,\n        ignored_reacs=ignored_reacs,\n    )\n\n    # Add enzyme constraints if enabled\n    if with_enzyme_constraints:\n        model = _add_enzyme_constraints_to_lp(\n            model=model,\n            cobrak_model=cobrak_model,\n            ignored_reacs=ignored_reacs,\n            add_error_term=correction_config.add_kcat_times_e_error_term,\n            error_cutoff=correction_config.kcat_times_e_error_cutoff,\n            max_rel_correction=correction_config.max_rel_kcat_times_e_correction,\n        )\n\n    # Add thermodynamic constraints if enabled\n    if with_thermodynamic_constraints:\n        model = _add_thermodynamic_constraints_to_lp(\n            model=model,\n            cobrak_model=cobrak_model,\n            add_thermobottleneck_analysis_vars=add_thermobottleneck_analysis_vars,\n            min_mdf=min_mdf,\n            strict_kappa_products_equality=strict_kappa_products_equality,\n            add_dG0_error_term=correction_config.add_dG0_error_term,\n            dG0_error_cutoff=correction_config.dG0_error_cutoff,\n            max_abs_dG0_correction=correction_config.max_abs_dG0_correction,\n            add_km_error_term=correction_config.add_km_error_term,\n            km_error_cutoff=correction_config.km_error_cutoff,\n            max_rel_km_correction=correction_config.max_rel_km_correction,\n            ignored_reacs=ignored_reacs,\n        )\n\n        if cobrak_model.max_conc_sum &lt; float(\"inf\"):\n            model = _add_conc_sum_constraints(cobrak_model, model)\n\n    # Add loop constraints if enabled\n    if with_loop_constraints:\n        model = add_loop_constraints_to_lp(\n            model,\n            cobrak_model,\n            only_nonthermodynamic=with_thermodynamic_constraints,\n            ignored_reacs=ignored_reacs,\n        )\n\n    # Add flux sum variable if enabled\n    if with_flux_sum_var:\n        model = add_flux_sum_var(\n            model,\n            cobrak_model,\n        )\n\n    # Apply error scenarios and add error sum term if error handling is configured\n    if is_any_error_term_active(correction_config):\n        if correction_config.error_scenario != {}:\n            _apply_error_scenario(\n                model,\n                cobrak_model,\n                correction_config,\n            )\n\n        if correction_config.add_error_sum_term:\n            model = _add_error_sum_to_model(\n                model,\n                cobrak_model,\n                correction_config,\n            )\n\n    # Add extra linear constraints if enabled\n    if add_extra_linear_constraints:\n        model = _add_extra_watches_and_constraints_to_lp(\n            model=model,\n            cobrak_model=cobrak_model,\n            ignore_nonlinear_terms=ignore_nonlinear_terms,\n        )\n\n    return model\n</code></pre>"},{"location":"api.html#cobrak.lps.perform_lp_min_active_reactions_analysis","title":"<code>perform_lp_min_active_reactions_analysis(cobrak_model, with_enzyme_constraints, variability_dict, min_mdf=0.0, verbose=False, solver=SCIP, ignore_nonlinear_terms=False)</code>","text":"<p>Run a mixed-integer linear program to determine the minimum number of active reactions.</p> <p>This function constructs and solves a mixed-integer linear programming model to find the minimum number of reactions that need to be active to satisfy the given variability constraints. It uses a binary variable for each reaction to indicate whether it is active, and the objective is to minimize the sum of these binary variables. The model includes constraints based on enzyme data, thermodynamic feasibility, and loop prevention, depending on the specified parameters.</p>"},{"location":"api.html#cobrak.lps.perform_lp_min_active_reactions_analysis--parameters","title":"Parameters","text":"<p>cobrak_model : Model     The COBRA model containing the metabolic network and reaction data. with_enzyme_constraints : bool     If True, includes enzyme-pool constraints in the model. variability_dict : dict[str, tuple[float, float]]     A dictionary where keys are reaction IDs and values are tuples specifying (lower bound,     upper bound) for reaction fluxes. min_mdf : float, optional     Minimum value for Min-Max Driving Force (MDF), setting a lower bound on fluxes.     Defaults to 0.0. verbose : bool, optional     If True, enables solver output. Defaults to False. solver: Solver     The MILP solver used for this analysis. Defaults to SCIP. ignore_nonlinear_terms: bool, optional     Whether or not non-linear extra watches and constraints shall not be included. Defaults to False.     Note: If such non-linear values exist and are included, the whole problem becomes non-linear, making it     incompatible with any purely linear solver!</p>"},{"location":"api.html#cobrak.lps.perform_lp_min_active_reactions_analysis--returns","title":"Returns","text":"<p>float     The minimum number of active reactions required to satisfy the constraints.</p> Source code in <code>cobrak/lps.py</code> <pre><code>@validate_call(validate_return=True)\ndef perform_lp_min_active_reactions_analysis(\n    cobrak_model: Model,\n    with_enzyme_constraints: bool,\n    variability_dict: dict[str, tuple[float, float]],\n    min_mdf: float = 0.0,\n    verbose: bool = False,\n    solver: Solver = SCIP,\n    ignore_nonlinear_terms: bool = False,\n) -&gt; float:\n    \"\"\"Run a mixed-integer linear program to determine the minimum number of active reactions.\n\n    This function constructs and solves a mixed-integer linear programming model to find the minimum number of\n    reactions that need to be active to satisfy the given variability constraints. It uses a binary\n    variable for each reaction to indicate whether it is active, and the objective is to minimize\n    the sum of these binary variables. The model includes constraints based on enzyme data,\n    thermodynamic feasibility, and loop prevention, depending on the specified parameters.\n\n    Parameters\n    ----------\n    cobrak_model : Model\n        The COBRA model containing the metabolic network and reaction data.\n    with_enzyme_constraints : bool\n        If True, includes enzyme-pool constraints in the model.\n    variability_dict : dict[str, tuple[float, float]]\n        A dictionary where keys are reaction IDs and values are tuples specifying (lower bound,\n        upper bound) for reaction fluxes.\n    min_mdf : float, optional\n        Minimum value for Min-Max Driving Force (MDF), setting a lower bound on fluxes.\n        Defaults to 0.0.\n    verbose : bool, optional\n        If True, enables solver output. Defaults to False.\n    solver: Solver\n        The MILP solver used for this analysis. Defaults to SCIP.\n    ignore_nonlinear_terms: bool, optional\n        Whether or not non-linear extra watches and constraints shall *not* be included. Defaults to False.\n        Note: If such non-linear values exist and are included, the whole problem becomes *non-linear*, making it\n        incompatible with any purely linear solver!\n\n    Returns\n    -------\n    float\n        The minimum number of active reactions required to satisfy the constraints.\n    \"\"\"\n    # Create a deep copy of the COBRAk model to avoid modifying the original model\n    cobrak_model = deepcopy(cobrak_model)\n\n    # Remove reactions that are not present in the variability dictionary\n    minz_cobrak_model = delete_unused_reactions_in_variability_dict(\n        cobrak_model, variability_dict\n    )\n\n    # Construct the LP model with the specified constraints\n    minz_model, _ = get_lp_from_cobrak_model(\n        minz_cobrak_model,\n        with_enzyme_constraints=with_enzyme_constraints,\n        with_thermodynamic_constraints=True,\n        with_loop_constraints=False,\n        min_mdf=min_mdf,\n        ignore_nonlinear_terms=ignore_nonlinear_terms,\n    )\n\n    # Initialize the sum of binary variables to zero\n    extrazsum_expression = 0.0\n\n    # Iterate over all potentially active reactions\n    for reac_id in get_potentially_active_reactions_in_variability_dict(\n        cobrak_model, variability_dict\n    ):\n        # Create a binary variable for each reaction to indicate activity\n        extraz_varname = f\"extraz_var_{reac_id}\"\n        setattr(minz_model, extraz_varname, Var(within=Binary))\n\n        # Add a constraint to relate reaction flux to the binary variable\n        setattr(\n            minz_model,\n            f\"extraz_const_{reac_id}\",\n            Constraint(\n                rule=getattr(minz_model, reac_id)\n                &lt;= BIG_M * getattr(minz_model, extraz_varname)\n            ),\n        )\n\n        # Accumulate the binary variables in the sum expression\n        extrazsum_expression += getattr(minz_model, extraz_varname)\n\n    # Add a variable to represent the total sum of active reactions\n    setattr(minz_model, \"extrazsum\", Var(within=Reals))\n\n    # Add a constraint to equate the sum variable to the sum expression\n    setattr(\n        minz_model,\n        \"extrazsum_const\",\n        Constraint(rule=getattr(minz_model, \"extrazsum\") == extrazsum_expression),\n    )\n\n    # Set the objective function to minimize the number of active reactions\n    minz_model.obj = get_objective(minz_model, \"extrazsum\", minimize)\n\n    # Initialize the solver with the specified options and attributes\n    solver = get_solver(solver.name, solver.solver_options, solver.solver_attrs)\n\n    # Solve the LP model\n    solver.solve(minz_model, tee=verbose, **solver.solve_extra_options)\n\n    # Retrieve the solution as a dictionary\n    minz_dict = get_pyomo_solution_as_dict(minz_model)\n\n    # Return the minimum number of active reactions\n    return minz_dict[\"extrazsum\"]\n</code></pre>"},{"location":"api.html#cobrak.lps.perform_lp_optimization","title":"<code>perform_lp_optimization(cobrak_model, objective_target, objective_sense, with_enzyme_constraints=False, with_thermodynamic_constraints=False, with_loop_constraints=False, variability_dict={}, ignored_reacs=[], min_mdf=STANDARD_MIN_MDF, verbose=False, with_flux_sum_var=False, solver=SCIP, ignore_nonlinear_terms=False, correction_config=CorrectionConfig(), var_data_abs_epsilon=1e-05)</code>","text":"<p>Perform linear programming optimization on a COBRAk model to determine flux distributions.</p> <p>This function constructs and solves an LP problem for the given metabolic model using specified constraints, variables, and solver options. It supports various types of constraints such as enzyme constraints, thermodynamic constraints, and loop constraints. Additionally, it can handle variability dictionaries and ignored reactions.</p> <p>Parameters:</p> Name Type Description Default <code>cobrak_model</code> <code>Model</code> <p>A COBRAk Model object representing the metabolic network.</p> required <code>objective_target</code> <code>str | dict[str, float]</code> <p>The target for optimization. Can be a reaction ID if optimizing a single reaction or a dictionary specifying flux values for multiple reactions.</p> required <code>objective_sense</code> <code>int</code> <p>The sense of the optimization problem (+1: maximize, -1: minimize).</p> required <code>with_enzyme_constraints</code> <code>bool</code> <p>Whether to include enzyme constraints in the model. Defaults to False.</p> <code>False</code> <code>with_thermodynamic_constraints</code> <code>bool</code> <p>Whether to include thermodynamic constraints in the model. Defaults to False.</p> <code>False</code> <code>with_loop_constraints</code> <code>bool</code> <p>Whether to include loop closure constraints in the model. Defaults to False.</p> <code>False</code> <code>variability_dict</code> <code>dict[str, tuple[float, float]]</code> <p>A dictionary specifying variable bounds for reactions or metabolites. Defaults to an empty dict.</p> <code>{}</code> <code>ignored_reacs</code> <code>list[str]</code> <p>List of reaction IDs to deactivate during optimization. Defaults to an empty list.</p> <code>[]</code> <code>min_mdf</code> <code>float</code> <p>Minimum metabolic distance factor threshold for thermodynamic constraints. Defaults to STANDARD_MIN_MDF.</p> <code>STANDARD_MIN_MDF</code> <code>verbose</code> <code>bool</code> <p>Whether to print solver output information. Defaults to False.</p> <code>False</code> <code>with_flux_sum_var</code> <code>bool</code> <p>Whether to include flux sum variable in the model. Defaults to False.</p> <code>False</code> <code>solver</code> <code>Solver</code> <p>Solver used for LP. Default is SCIP.</p> <code>SCIP</code> <code>ignore_nonlinear_terms</code> <code>bool</code> <p>(bool): Whether or not non-linear watches/constraints shall be ignored in ecTFBAs. Defaults to True. Note: If such non-linear values exist and are included, the whole problem becomes non-linear, making it incompatible with any purely linear solver!</p> <code>False</code> <code>correction_config</code> <code>CorrectionConfig</code> <p>Configuration for handling prameter corrections and scenarios during optimization.</p> <code>CorrectionConfig()</code> <code>var_data_abs_epsilon</code> <code>float</code> <p>(float, optional): Under this value, any data given by the variability dict is considered to be 0. Defaults to 1e-5.</p> <code>1e-05</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>dict[str, float]: A dictionary containing the flux distribution results for each reaction in the model.</p> Source code in <code>cobrak/lps.py</code> <pre><code>@validate_call\ndef perform_lp_optimization(\n    cobrak_model: Model,\n    objective_target: str | dict[str, float],\n    objective_sense: int,\n    with_enzyme_constraints: bool = False,\n    with_thermodynamic_constraints: bool = False,\n    with_loop_constraints: bool = False,\n    variability_dict: dict[str, tuple[float, float]] = {},\n    ignored_reacs: list[str] = [],\n    min_mdf: float = STANDARD_MIN_MDF,\n    verbose: bool = False,\n    with_flux_sum_var: bool = False,\n    solver: Solver = SCIP,\n    ignore_nonlinear_terms: bool = False,\n    correction_config: CorrectionConfig = CorrectionConfig(),\n    var_data_abs_epsilon: float = 1e-5,\n) -&gt; dict[str, float]:\n    \"\"\"Perform linear programming optimization on a COBRAk model to determine flux distributions.\n\n    This function constructs and solves an LP problem for the given metabolic model using specified constraints,\n    variables, and solver options. It supports various types of constraints such as enzyme constraints, thermodynamic\n    constraints, and loop constraints. Additionally, it can handle variability dictionaries and ignored reactions.\n\n    Parameters:\n        cobrak_model (Model): A COBRAk Model object representing the metabolic network.\n        objective_target (str | dict[str, float]): The target for optimization. Can be a reaction ID if optimizing a single\n            reaction or a dictionary specifying flux values for multiple reactions.\n        objective_sense (int): The sense of the optimization problem (+1: maximize, -1: minimize).\n        with_enzyme_constraints (bool, optional): Whether to include enzyme constraints in the model. Defaults to False.\n        with_thermodynamic_constraints (bool, optional): Whether to include thermodynamic constraints in the model.\n            Defaults to False.\n        with_loop_constraints (bool, optional): Whether to include loop closure constraints in the model. Defaults to False.\n        variability_dict (dict[str, tuple[float, float]], optional): A dictionary specifying variable bounds for reactions\n            or metabolites. Defaults to an empty dict.\n        ignored_reacs (list[str], optional): List of reaction IDs to deactivate during optimization. Defaults to an empty list.\n        min_mdf (float, optional): Minimum metabolic distance factor threshold for thermodynamic constraints. Defaults to STANDARD_MIN_MDF.\n        verbose (bool, optional): Whether to print solver output information. Defaults to False.\n        with_flux_sum_var (bool, optional): Whether to include flux sum variable in the model. Defaults to False.\n        solver (Solver, optional): Solver used for LP. Default is SCIP.\n        ignore_nonlinear_terms: (bool): Whether or not non-linear watches/constraints shall be ignored in ecTFBAs. Defaults to True.\n            Note: If such non-linear values exist and are included, the whole problem becomes *non-linear*, making it incompatible with any\n            purely linear solver!\n        correction_config (CorrectionConfig, optional): Configuration for handling prameter corrections and scenarios during optimization.\n        var_data_abs_epsilon: (float, optional): Under this value, any data given by the variability dict is considered to be 0. Defaults to 1e-5.\n\n    Returns:\n        dict[str, float]: A dictionary containing the flux distribution results for each reaction in the model.\n    \"\"\"\n    optimization_cobrak_model = deepcopy(cobrak_model)\n    if variability_dict != {}:\n        optimization_cobrak_model = delete_unused_reactions_in_variability_dict(\n            cobrak_model,\n            variability_dict,\n        )\n    optimization_model = get_lp_from_cobrak_model(\n        cobrak_model=optimization_cobrak_model,\n        with_enzyme_constraints=with_enzyme_constraints,\n        with_thermodynamic_constraints=with_thermodynamic_constraints,\n        with_loop_constraints=with_loop_constraints,\n        with_flux_sum_var=with_flux_sum_var,\n        min_mdf=min_mdf,\n        ignore_nonlinear_terms=ignore_nonlinear_terms,\n        correction_config=correction_config,\n    )\n\n    for deactivated_reaction in set(ignored_reacs):\n        try:\n            setattr(\n                optimization_model,\n                f\"DEACTIVATE_{deactivated_reaction}\",\n                Constraint(\n                    expr=getattr(optimization_model, deactivated_reaction) == 0.0\n                ),\n            )\n        except AttributeError:\n            continue\n\n    optimization_model = apply_variability_dict(\n        optimization_model,\n        cobrak_model,\n        variability_dict,\n        correction_config.error_scenario,\n        abs_epsilon=var_data_abs_epsilon,\n    )\n    optimization_model.obj = get_objective(\n        optimization_model, objective_target, objective_sense\n    )\n\n    pyomo_solver = get_solver(solver.name, solver.solver_options, solver.solver_attrs)\n    results = pyomo_solver.solve(\n        optimization_model, tee=verbose, **solver.solve_extra_options\n    )\n\n    fba_dict = get_pyomo_solution_as_dict(optimization_model)\n\n    return add_statuses_to_optimziation_dict(fba_dict, results)\n</code></pre>"},{"location":"api.html#cobrak.lps.perform_lp_thermodynamic_bottleneck_analysis","title":"<code>perform_lp_thermodynamic_bottleneck_analysis(cobrak_model, with_enzyme_constraints=False, min_mdf=STANDARD_MIN_MDF, verbose=False, solver=SCIP, ignore_nonlinear_terms=False)</code>","text":"<p>Perform thermodynamic bottleneck analysis on a COBRAk model using mixed-integer linear programming.</p> <p>This function identifies a minimal set of thermodynamic bottlenecks in a COBRAk model by minimizing the sum of newly introduced binary variables that indicate bottleneck reactions, i.e. reactions that do not allow the max-min driving force (MDF) to become at least the set min_mdf. This methology was first described in [1]. Keep in mind that results from this function are optimal, but not neccessarily unique!</p> <p>[1] Bekiaris et al. (2023). Nature Communications, 14(1), 4660.  https://doi.org/10.1038/s41467-023-40297-8</p> <p>Parameters:</p> Name Type Description Default <code>cobrak_model</code> <code>Model</code> <p>The COBRAk model to analyze for thermodynamic bottlenecks.</p> required <code>with_enzyme_constraints</code> <code>bool</code> <p>Whether to include enzyme constraints in the analysis.</p> <code>False</code> <code>min_mdf</code> <code>float</code> <p>Minimum max-min driving force (MDF) to be enforced. Defaults to STANDARD_MIN_MDF.</p> <code>STANDARD_MIN_MDF</code> <code>verbose</code> <code>bool</code> <p>If True, print detailed information about identified bottlenecks. Defaults to False.</p> <code>False</code> <code>solver_name</code> <code>str</code> <p>Name of the solver to use for optimization. Defaults to \"scip\".</p> required <code>solver_options</code> <code>dict[str, float | int | str]</code> <p>Options for the solver, such as number of threads                                                      and LP method. Defaults to an empty dictionary.</p> required <code>ignore_nonlinear_terms</code> <code>bool</code> <p>bool, optional Whether or not non-linear extra watches and constraints shall not be included. Defaults to False. Note: If such non-linear values exist and are included, the whole problem becomes non-linear, making it incompatible with any purely linear solver!</p> <code>False</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: A list of reaction IDs identified as thermodynamic bottlenecks.</p> Source code in <code>cobrak/lps.py</code> <pre><code>@validate_call(validate_return=True)\ndef perform_lp_thermodynamic_bottleneck_analysis(\n    cobrak_model: Model,\n    with_enzyme_constraints: bool = False,\n    min_mdf: float = STANDARD_MIN_MDF,\n    verbose: bool = False,\n    solver: Solver = SCIP,\n    ignore_nonlinear_terms: bool = False,\n) -&gt; list[str]:\n    \"\"\"Perform thermodynamic bottleneck analysis on a COBRAk model using mixed-integer linear programming.\n\n    This function identifies a minimal set of thermodynamic bottlenecks in a COBRAk model by minimizing the sum of\n    newly introduced binary variables that indicate bottleneck reactions, i.e. reactions that do not allow the\n    max-min driving force (MDF) to become at least the set min_mdf.\n    This methology was first described in [1]. Keep in mind that results from this function are optimal, but not\n    neccessarily unique!\n\n    [1] Bekiaris et al. (2023). Nature Communications, 14(1), 4660.  https://doi.org/10.1038/s41467-023-40297-8\n\n    Args:\n        cobrak_model (Model): The COBRAk model to analyze for thermodynamic bottlenecks.\n        with_enzyme_constraints (bool): Whether to include enzyme constraints in the analysis.\n        min_mdf (float, optional): Minimum max-min driving force (MDF) to be enforced. Defaults to STANDARD_MIN_MDF.\n        verbose (bool, optional): If True, print detailed information about identified bottlenecks. Defaults to False.\n        solver_name (str, optional): Name of the solver to use for optimization. Defaults to \"scip\".\n        solver_options (dict[str, float | int | str], optional): Options for the solver, such as number of threads\n                                                                 and LP method. Defaults to an empty dictionary.\n        ignore_nonlinear_terms: bool, optional\n            Whether or not non-linear extra watches and constraints shall *not* be included. Defaults to False.\n            Note: If such non-linear values exist and are included, the whole problem becomes *non-linear*, making it\n            incompatible with any purely linear solver!\n\n    Returns:\n        list[str]: A list of reaction IDs identified as thermodynamic bottlenecks.\n    \"\"\"\n    cobrak_model = deepcopy(cobrak_model)\n    thermo_constraint_lp = get_lp_from_cobrak_model(\n        cobrak_model,\n        with_enzyme_constraints=with_enzyme_constraints,\n        with_thermodynamic_constraints=True,\n        with_loop_constraints=False,\n        add_thermobottleneck_analysis_vars=True,\n        min_mdf=min_mdf,\n        ignore_nonlinear_terms=ignore_nonlinear_terms,\n    )\n\n    thermo_constraint_lp.obj = get_objective(\n        thermo_constraint_lp,\n        \"zb_sum\",\n        objective_sense=-1,\n    )\n    pyomo_solver = get_solver(solver.name, solver.solver_options, solver.solver_attrs)\n    pyomo_solver.solve(thermo_constraint_lp, tee=verbose, **solver.solve_extra_options)\n    solution_dict = get_pyomo_solution_as_dict(thermo_constraint_lp)\n\n    bottleneck_counter = 1\n    bottleneck_reactions = []\n    for var_id, var_value in solution_dict.items():\n        if not var_id.startswith(\"zb_var_\"):\n            continue\n        if var_value &lt;= 0.01:\n            continue\n        bottleneck_reac_id = var_id.replace(\"zb_var_\", \"\")\n        bottleneck_reactions.append(bottleneck_reac_id)\n        if verbose:\n            bottleneck_dG0 = cobrak_model.reactions[bottleneck_reac_id].dG0\n            if bottleneck_dG0 is not None:\n                printed_dG0 = round(bottleneck_dG0, 3)\n            printed_string = get_reaction_string(cobrak_model, bottleneck_reac_id)\n            print(\n                f\"#{bottleneck_counter}: {bottleneck_reac_id} with \u0394G'\u00b0 of {printed_dG0} kJ/mol, {printed_string}\"\n            )\n        bottleneck_counter += 1\n\n    return bottleneck_reactions\n</code></pre>"},{"location":"api.html#cobrak.lps.perform_lp_variability_analysis","title":"<code>perform_lp_variability_analysis(cobrak_model, with_enzyme_constraints=False, with_thermodynamic_constraints=False, active_reactions=[], min_active_flux=0.001, calculate_reacs=True, calculate_concs=True, calculate_rest=True, further_tested_vars=[], min_mdf=STANDARD_MIN_MDF, min_flux_cutoff=1e-05, abs_df_cutoff=1e-05, min_enzyme_cutoff=1e-05, max_active_enzyme_cutoff=0.0001, solver=SCIP, parallel_verbosity_level=0, ignore_nonlinear_terms=False)</code>","text":"<p>Perform linear programming variability analysis on a COBRAk model.</p> <p>This function conducts a variability analysis on a COBRAk model using linear programming (LP). It evaluates the range of possible flux values for each reaction and all other occuring variables in the model, considering optional enzyme and thermodynamic constraints. The methodology is based on the approach described by [1] and parallelized as outlined in [2].</p> <p>[1] Mahadevan &amp; Schilling. (2003). Metabolic engineering, 5(4), 264-276. https://doi.org/10.1016/j.ymben.2003.09.002 [2] Gudmundsson &amp; Thiele. BMC Bioinformatics 11, 489 (2010). https://doi.org/10.1186/1471-2105-11-489</p> <p>Parameters:</p> Name Type Description Default <code>cobrak_model</code> <code>Model</code> <p>The COBRAk model to analyze.</p> required <code>with_enzyme_constraints</code> <code>bool</code> <p>Whether to include enzyme constraints in the analysis.</p> <code>False</code> <code>with_thermodynamic_constraints</code> <code>bool</code> <p>Whether to include thermodynamic constraints in the analysis.</p> <code>False</code> <code>active_reactions</code> <code>list[str]</code> <p>List of reactions to be set as active with a minimum flux.                                     Defaults to an empty list.</p> <code>[]</code> <code>min_active_flux</code> <code>float</code> <p>Minimum flux value for active reactions. Defaults to 1e-5.</p> <code>0.001</code> <code>calculate_reacs</code> <code>bool</code> <p>If True, analyze reaction fluxes. Default: True.</p> <code>True</code> <code>calculate_concs</code> <code>bool</code> <p>If True, analyze concentrations. Default: True.</p> <code>True</code> <code>calculate_rest</code> <code>bool</code> <p>If True, analyze all other parameters (e.g. kappa values and driving forces). Default: True.</p> <code>True</code> <code>min_mdf</code> <code>float</code> <p>Minimum metabolic driving force (MDF) to be enforced. Defaults to 0.0.</p> <code>STANDARD_MIN_MDF</code> <code>min_flux_cutoff</code> <code>float</code> <p>Minimum flux cutoff for considering a reaction active. Defaults to 1e-8.</p> <code>1e-05</code> <code>solver</code> <code>Solver</code> <p>MILP solver used for variability analysis. Default is SCIP, recommended is CPLEX_FOR_VARIABILITY_ANALYSIS                        or GUROBI_FOR_VARIABILITY_ANALYSIS if you have a CPLEX or Gurobi license.</p> <code>SCIP</code> <code>parallel_verbosity_level</code> <code>int</code> <p>Sets the verbosity level for the analysis parallelization. The higher,                                       the value, the more is printed. Default: 0.</p> <code>0</code> <code>ignore_nonlinear_terms</code> <code>bool</code> <p>(bool): Whether or not non-linear watches/constraints shall be ignored in ecTFBAs. Defaults to True. Note: If such non-linear values exist and are included, the whole problem becomes non-linear, making it incompatible with any purely linear solver!</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, tuple[float, float]]</code> <p>dict[str, tuple[float, float]]: A dictionary mapping variable IDs to their minimum and maximum values                             determined by the variability analysis.</p> Source code in <code>cobrak/lps.py</code> <pre><code>@validate_call\ndef perform_lp_variability_analysis(\n    cobrak_model: Model,\n    with_enzyme_constraints: bool = False,\n    with_thermodynamic_constraints: bool = False,\n    active_reactions: list[str] = [],\n    min_active_flux: float = 1e-3,\n    calculate_reacs: bool = True,\n    calculate_concs: bool = True,\n    calculate_rest: bool = True,\n    further_tested_vars: list[str] = [],\n    min_mdf: float = STANDARD_MIN_MDF,\n    min_flux_cutoff: float = 1e-5,\n    abs_df_cutoff: float = 1e-5,\n    min_enzyme_cutoff: float = 1e-5,\n    max_active_enzyme_cutoff: float = 1e-4,\n    solver: Solver = SCIP,\n    parallel_verbosity_level: int = 0,\n    ignore_nonlinear_terms: bool = False,\n) -&gt; dict[str, tuple[float, float]]:\n    \"\"\"Perform linear programming variability analysis on a COBRAk model.\n\n    This function conducts a variability analysis on a COBRAk model using linear programming (LP).\n    It evaluates the range of possible flux values for each reaction and all other occuring variables in the model,\n    considering optional enzyme and thermodynamic constraints. The methodology is based on the approach\n    described by [1] and parallelized as outlined in [2].\n\n    [1] Mahadevan &amp; Schilling. (2003). Metabolic engineering, 5(4), 264-276. https://doi.org/10.1016/j.ymben.2003.09.002\n    [2] Gudmundsson &amp; Thiele. BMC Bioinformatics 11, 489 (2010). https://doi.org/10.1186/1471-2105-11-489\n\n    Args:\n        cobrak_model (Model): The COBRAk model to analyze.\n        with_enzyme_constraints (bool): Whether to include enzyme constraints in the analysis.\n        with_thermodynamic_constraints (bool): Whether to include thermodynamic constraints in the analysis.\n        active_reactions (list[str], optional): List of reactions to be set as active with a minimum flux.\n                                                Defaults to an empty list.\n        min_active_flux (float, optional): Minimum flux value for active reactions. Defaults to 1e-5.\n        calculate_reacs (bool, optional): If True, analyze reaction fluxes. Default: True.\n        calculate_concs (bool, optional): If True, analyze concentrations. Default: True.\n        calculate_rest (bool, optional): If True, analyze all other parameters (e.g. kappa values and driving forces). Default: True.\n        min_mdf (float, optional): Minimum metabolic driving force (MDF) to be enforced. Defaults to 0.0.\n        min_flux_cutoff (float, optional): Minimum flux cutoff for considering a reaction active. Defaults to 1e-8.\n        solver (Solver, optional): MILP solver used for variability analysis. Default is SCIP, recommended is CPLEX_FOR_VARIABILITY_ANALYSIS\n                                   or GUROBI_FOR_VARIABILITY_ANALYSIS if you have a CPLEX or Gurobi license.\n        parallel_verbosity_level (int, optional): Sets the verbosity level for the analysis parallelization. The higher,\n                                                  the value, the more is printed. Default: 0.\n        ignore_nonlinear_terms: (bool): Whether or not non-linear watches/constraints shall be ignored in ecTFBAs. Defaults to True.\n            Note: If such non-linear values exist and are included, the whole problem becomes *non-linear*, making it incompatible with any\n            purely linear solver!\n\n    Returns:\n        dict[str, tuple[float, float]]: A dictionary mapping variable IDs to their minimum and maximum values\n                                        determined by the variability analysis.\n    \"\"\"\n    cobrak_model = deepcopy(cobrak_model)\n    for active_reaction in active_reactions:\n        cobrak_model.reactions[active_reaction].min_flux = min_active_flux\n\n    model = get_lp_from_cobrak_model(\n        cobrak_model=cobrak_model,\n        with_enzyme_constraints=with_enzyme_constraints,\n        with_thermodynamic_constraints=with_thermodynamic_constraints,\n        with_loop_constraints=True,\n        min_mdf=min_mdf,\n        strict_kappa_products_equality=True,\n        ignore_nonlinear_terms=False,\n    )\n    model_var_names = get_model_var_names(model)\n\n    min_values: dict[str, float] = {}\n    max_values: dict[str, float] = {}\n    objective_targets: list[tuple[int, str]] = []\n\n    max_flux_sum_result = perform_lp_optimization(\n        cobrak_model,\n        objective_target=FLUX_SUM_VAR_ID,\n        objective_sense=+1,\n        with_enzyme_constraints=with_enzyme_constraints,\n        with_thermodynamic_constraints=True,\n        with_loop_constraints=True,\n        with_flux_sum_var=True,\n        solver=solver,\n        ignore_nonlinear_terms=False,\n    )\n    min_flux_sum_result = perform_lp_optimization(\n        cobrak_model,\n        objective_target=FLUX_SUM_VAR_ID,\n        objective_sense=-1,\n        with_enzyme_constraints=with_enzyme_constraints,\n        with_thermodynamic_constraints=True,\n        with_loop_constraints=True,\n        with_flux_sum_var=True,\n        solver=solver,\n        ignore_nonlinear_terms=ignore_nonlinear_terms,\n    )\n\n    if (calculate_concs or calculate_rest) and with_thermodynamic_constraints:\n        min_mdf_result = perform_lp_optimization(\n            cobrak_model,\n            objective_target=MDF_VAR_ID,\n            objective_sense=-1,\n            with_enzyme_constraints=with_enzyme_constraints,\n            with_thermodynamic_constraints=True,\n            with_loop_constraints=True,\n            solver=solver,\n            ignore_nonlinear_terms=ignore_nonlinear_terms,\n        )\n        max_mdf_result = perform_lp_optimization(\n            cobrak_model,\n            objective_target=MDF_VAR_ID,\n            objective_sense=+1,\n            with_enzyme_constraints=with_enzyme_constraints,\n            with_thermodynamic_constraints=True,\n            with_loop_constraints=True,\n            solver=solver,\n            ignore_nonlinear_terms=ignore_nonlinear_terms,\n        )\n\n    if calculate_concs:\n        for met_id, metabolite in cobrak_model.metabolites.items():\n            met_var_name = f\"{LNCONC_VAR_PREFIX}{met_id}\"\n            if met_var_name in model_var_names:\n                min_mdf_conc = min_mdf_result[met_var_name]\n                max_mdf_conc = min_mdf_result[met_var_name]\n                if metabolite.log_min_conc in (min_mdf_conc, max_mdf_conc):\n                    min_values[met_var_name] = metabolite.log_min_conc\n                else:\n                    objective_targets.append((-1, met_var_name))\n                if metabolite.log_max_conc in (min_mdf_conc, max_mdf_conc):\n                    max_values[met_var_name] = metabolite.log_max_conc\n                else:\n                    objective_targets.append((+1, met_var_name))\n\n    for reac_id, reaction in cobrak_model.reactions.items():\n        min_flux_sum_flux = min_flux_sum_result[reac_id]\n        max_flux_sum_flux = max_flux_sum_result[reac_id]\n\n        if calculate_reacs:\n            if reaction.min_flux in (min_flux_sum_flux, max_flux_sum_flux):\n                min_values[reac_id] = (\n                    reaction.min_flux if reaction.min_flux &gt;= min_flux_cutoff else 0.0\n                )\n            else:\n                objective_targets.append((-1, reac_id))\n            if reaction.max_flux in (min_flux_sum_flux, max_flux_sum_flux):\n                max_values[reac_id] = reaction.max_flux\n            else:\n                objective_targets.append((+1, reac_id))\n\n        if not calculate_rest:\n            continue\n\n        f_var_name = f\"{DF_VAR_PREFIX}{reac_id}\"\n        kappa_substrates_var_name = f\"{KAPPA_SUBSTRATES_VAR_PREFIX}{reac_id}\"\n        kappa_products_var_name = f\"{KAPPA_PRODUCTS_VAR_PREFIX}{reac_id}\"\n        if f_var_name in model_var_names:\n            if min_mdf in (min_mdf_result[f_var_name], max_mdf_result[f_var_name]):\n                min_values[f_var_name] = min_mdf\n            else:\n                objective_targets.append((-1, f_var_name))\n            objective_targets.append((+1, f_var_name))\n        if kappa_substrates_var_name in model_var_names:\n            objective_targets.extend(\n                ((-1, kappa_substrates_var_name), (+1, kappa_substrates_var_name))\n            )\n        if kappa_products_var_name in model_var_names:\n            objective_targets.extend(\n                ((-1, kappa_products_var_name), (+1, kappa_products_var_name))\n            )\n        if reaction.enzyme_reaction_data is not None and with_enzyme_constraints:\n            full_enzyme_id = get_full_enzyme_id(\n                reaction.enzyme_reaction_data.identifiers\n            )\n            if full_enzyme_id:\n                enzyme_delivery_var_name = get_reaction_enzyme_var_id(reac_id, reaction)\n                if 0.0 in (min_flux_sum_flux, max_flux_sum_flux):\n                    min_values[enzyme_delivery_var_name] = 0.0\n                else:\n                    objective_targets.append((-1, enzyme_delivery_var_name))\n                objective_targets.append((+1, enzyme_delivery_var_name))\n\n    for further_tested_var in further_tested_vars:\n        objective_targets.extend(((+1, further_tested_var), (-1, further_tested_var)))\n\n    objectives_data: list[tuple[str, str]] = []\n    for obj_sense, target_id in objective_targets:\n        if obj_sense == -1:\n            objective_name = f\"MIN_OBJ_{target_id}\"\n            pyomo_sense = minimize\n        else:\n            objective_name = f\"MAX_OBJ_{target_id}\"\n            pyomo_sense = maximize\n        setattr(\n            model,\n            objective_name,\n            Objective(expr=getattr(model, target_id), sense=pyomo_sense),\n        )\n        getattr(model, objective_name).deactivate()\n        objectives_data.append((objective_name, target_id))\n\n    objectives_data_batches = split_list(objectives_data, cpu_count())\n    pyomo_solver = get_solver(solver.name, solver.solver_options, solver.solver_attrs)\n\n    results_list = Parallel(n_jobs=-1, verbose=parallel_verbosity_level)(\n        delayed(_batch_variability_optimization)(\n            pyomo_solver, model, batch, solver.solve_extra_options\n        )\n        for batch in objectives_data_batches\n    )\n    for result in chain(*results_list):\n        is_minimization = result[0]\n        target_id = result[1]\n        result_value = result[2]\n        if is_minimization:\n            min_values[target_id] = result_value\n        else:\n            max_values[target_id] = result_value\n\n    for key, min_value in min_values.items():\n        if key in cobrak_model.reactions:\n            min_values[key] = min_value if min_value &gt;= min_flux_cutoff else 0.0\n        if key.startswith(ENZYME_VAR_PREFIX):\n            min_values[key] = min_value if min_value &gt;= min_enzyme_cutoff else 0.0\n        if key.startswith(DF_VAR_PREFIX):\n            min_values[key] = min_value if abs(min_value) &gt;= abs_df_cutoff else 0.0\n\n    enzyme_var_to_reac_id = {\n        get_reaction_enzyme_var_id(reac_id, reaction): reac_id\n        for reac_id, reaction in cobrak_model.reactions.items()\n    }\n    for key, max_value in max_values.items():\n        if key.startswith(ENZYME_VAR_PREFIX) and (\n            (max_values[key] != 0.0) or (max_values[enzyme_var_to_reac_id[key]] &gt; 0.0)\n        ):\n            max_values[key] = max(max_value, max_active_enzyme_cutoff)\n        if key.startswith(DF_VAR_PREFIX):\n            max_values[key] = max_value if abs(max_value) &gt;= abs_df_cutoff else 0.0\n\n    all_target_ids = sorted(\n        set(\n            list(min_values.keys())\n            + list(max_values.keys())\n            + [obj_target[1] for obj_target in objective_targets]\n        )\n    )\n    variability_dict: dict[str, tuple[float, float]] = {\n        target_id: (min_values[target_id], max_values[target_id])\n        for target_id in all_target_ids\n    }\n\n    return variability_dict\n</code></pre>"},{"location":"api.html#cobrak.model_instantiation","title":"<code>model_instantiation</code>","text":"<p>This module contains the most convenient ways to create new Model instances from COBRApy models.</p>"},{"location":"api.html#cobrak.model_instantiation.delete_enzymatically_suboptimal_reactions_in_cobrak_model","title":"<code>delete_enzymatically_suboptimal_reactions_in_cobrak_model(cobrak_model)</code>","text":"<p>Delete enzymatically suboptimal reactions in a COBRA-k model, similar to the idea in sMOMENT/AutoPACMEN [1].</p> <p>This function processes each reaction in the provided COBRA-k model to determine if it is enzymatically suboptimal based on Molecular Weight by k_cat (MW/kcat). Suboptimal reactions are identified by comparing their MW/kcat value with that of other reactions sharing the same base identifier, retaining only those with the lowest MW/kcat. The function then removes these suboptimal reactions from the model and cleans up orphaned metabolites.</p> <ul> <li>The function assumes that the 'enzyme_reaction_data' attribute of each reaction includes   identifiers and k_cat information for enzyme-catalyzed reactions. If not, those reactions are skipped.</li> <li>Reactions with identical base IDs (but different directional suffixes) are considered as variants of the same reaction.</li> <li>After removing suboptimal reactions, the function calls <code>delete_orphaned_metabolites_and_enzymes</code> to clean up any orphaned metabolites and enzymes that may have been left behind.</li> </ul> <p>[1] https://doi.org/10.1186/s12859-019-3329-9</p> <p>Parameters:</p> Name Type Description Default <code>cobrak_model</code> <code>Model</code> <p>A COBRA-k model containing biochemical reactions.</p> required <p>Returns:</p> Type Description <code>Model</code> <p>cobra.Model: The updated COBRA-k model after removing enzymatically suboptimal reactions.</p> Source code in <code>cobrak/model_instantiation.py</code> <pre><code>def delete_enzymatically_suboptimal_reactions_in_cobrak_model(\n    cobrak_model: Model,\n) -&gt; Model:\n    \"\"\"Delete enzymatically suboptimal reactions in a COBRA-k model, similar to the idea in sMOMENT/AutoPACMEN [1].\n\n    This function processes each reaction in the provided COBRA-k model to\n    determine if it is enzymatically suboptimal based on Molecular Weight by k_cat (MW/kcat).\n    Suboptimal reactions are identified by comparing their MW/kcat value with that of other reactions\n    sharing the same base identifier, retaining only those with the lowest MW/kcat.\n    The function then removes these suboptimal reactions from the model and cleans up orphaned metabolites.\n\n    - The function assumes that the 'enzyme_reaction_data' attribute of each reaction includes\n      identifiers and k_cat information for enzyme-catalyzed reactions. If not, those reactions are skipped.\n    - Reactions with identical base IDs (but different directional suffixes) are considered as variants of the same reaction.\n    - After removing suboptimal reactions, the function calls `delete_orphaned_metabolites_and_enzymes` to clean up any orphaned metabolites and enzymes that may have been left behind.\n\n    [1] https://doi.org/10.1186/s12859-019-3329-9\n\n    Parameters:\n        cobrak_model (cobra.Model): A COBRA-k model containing biochemical reactions.\n\n    Returns:\n        cobra.Model: The updated COBRA-k model after removing enzymatically suboptimal reactions.\n    \"\"\"\n    reac_id_to_mw_by_kcat: dict[str, float] = {}\n    reac_id_to_base_id: dict[str, str] = {}\n    base_id_to_min_mw_by_kcat: dict[str, float] = {}\n    for reac_id, reac_data in cobrak_model.reactions.items():\n        if reac_data.enzyme_reaction_data is None:\n            continue\n        if reac_data.enzyme_reaction_data.identifiers == []:\n            continue\n        if reac_data.enzyme_reaction_data.identifiers == [\"\"]:\n            continue\n\n        mw_by_kcat = (\n            get_full_enzyme_mw(cobrak_model, reac_data)\n            / reac_data.enzyme_reaction_data.k_cat\n        )\n\n        reac_id_to_mw_by_kcat[reac_id] = mw_by_kcat\n\n        if reac_id.endswith(cobrak_model.fwd_suffix):\n            direction_addition = cobrak_model.fwd_suffix\n        elif reac_id.endswith(cobrak_model.rev_suffix):\n            direction_addition = cobrak_model.rev_suffix\n        else:\n            direction_addition = \"\"\n        base_id = reac_id.split(cobrak_model.reac_enz_separator)[0] + direction_addition\n\n        reac_id_to_base_id[reac_id] = base_id\n        if base_id not in base_id_to_min_mw_by_kcat:\n            base_id_to_min_mw_by_kcat[base_id] = mw_by_kcat\n        else:\n            base_id_to_min_mw_by_kcat[base_id] = min(\n                base_id_to_min_mw_by_kcat[base_id], mw_by_kcat\n            )\n\n    reacs_to_delete = [\n        reac_id\n        for reac_id, base_id in reac_id_to_base_id.items()\n        if reac_id_to_mw_by_kcat[reac_id] != base_id_to_min_mw_by_kcat[base_id]\n    ]\n    for reac_to_delete in reacs_to_delete:\n        del cobrak_model.reactions[reac_to_delete]\n\n    return delete_orphaned_metabolites_and_enzymes(cobrak_model)\n</code></pre>"},{"location":"api.html#cobrak.model_instantiation.delete_enzymatically_suboptimal_reactions_in_fullsplit_cobrapy_model","title":"<code>delete_enzymatically_suboptimal_reactions_in_fullsplit_cobrapy_model(cobra_model, enzyme_reaction_data, enzyme_molecular_weights, fwd_suffix=REAC_FWD_SUFFIX, rev_suffix=REAC_REV_SUFFIX, reac_enz_separator=REAC_ENZ_SEPARATOR, special_enzyme_stoichiometries={})</code>","text":"<p>Removes enzymatically suboptimal reactions from a fullsplit COBRApy model.</p> <p>This function identifies and deletes reactions in a COBRApy model that are enzymatically suboptimal based on enzyme reaction data and molecular weights. I.e., it retains only the reactions with the minimum molecular weight to k_cat (MW/k_cat) ratio for each base reaction. \"base\" reaction stands for any originally identical reaction, e.g., if there are somehow now multiple phosphoglucokinase (PGK) reactions due to an enzyme fullsplit, only one of these PGK variants will be retained in the returned model.</p> <p>Parameters:</p> Name Type Description Default <code>cobra_model</code> <code>Model</code> <p>The COBRA-k model from which suboptimal reactions will be removed.</p> required <code>enzyme_reaction_data</code> <code>dict[str, EnzymeReactionData | None]</code> <p>A dictionary mapping reaction IDs to <code>EnzymeReactionData</code> objects or <code>None</code> if the data is missing.</p> required <code>enzyme_molecular_weights</code> <code>dict[str, float]</code> <p>A dictionary mapping enzyme identifiers to their molecular weights.</p> required <p>Returns:</p> Type Description <code>Model</code> <p>cobra.Model: The modified COBRA-k model with suboptimal reactions removed.</p> Source code in <code>cobrak/model_instantiation.py</code> <pre><code>def delete_enzymatically_suboptimal_reactions_in_fullsplit_cobrapy_model(\n    cobra_model: cobra.Model,\n    enzyme_reaction_data: dict[str, EnzymeReactionData | None],\n    enzyme_molecular_weights: dict[str, float],\n    fwd_suffix: str = REAC_FWD_SUFFIX,\n    rev_suffix: str = REAC_REV_SUFFIX,\n    reac_enz_separator: str = REAC_ENZ_SEPARATOR,\n    special_enzyme_stoichiometries: dict[str, dict[str, float]] = {},\n) -&gt; cobra.Model:\n    \"\"\"Removes enzymatically suboptimal reactions from a fullsplit COBRApy model.\n\n    This function identifies and deletes reactions in a COBRApy model that are enzymatically suboptimal based on\n    enzyme reaction data and molecular weights. I.e., it retains only the reactions with the minimum molecular weight\n    to k_cat (MW/k_cat) ratio for each base reaction. \"base\" reaction stands for any originally identical reaction, e.g.,\n    if there are somehow now multiple phosphoglucokinase (PGK) reactions due to an enzyme fullsplit, only one of these\n    PGK variants will be retained in the returned model.\n\n    Args:\n        cobra_model (cobra.Model): The COBRA-k model from which suboptimal reactions will be removed.\n        enzyme_reaction_data (dict[str, EnzymeReactionData | None]): A dictionary mapping reaction IDs to\n            ```EnzymeReactionData``` objects or ```None``` if the data is missing.\n        enzyme_molecular_weights (dict[str, float]): A dictionary mapping enzyme identifiers to their molecular weights.\n\n    Returns:\n        cobra.Model: The modified COBRA-k model with suboptimal reactions removed.\n    \"\"\"\n    reac_ids: list[str] = [reaction.id for reaction in cobra_model.reactions]\n    ignored_reac_ids: list[str] = []\n    base_reacs_to_min_mw_by_k_cat: dict[str, tuple[str, float]] = {}\n    for reac_id in reac_ids:\n        if reac_enz_separator not in reac_id:\n            continue\n        if reac_id not in enzyme_reaction_data:\n            ignored_reac_ids.append(reac_id)\n            continue\n\n        current_enzyme_reaction_data = enzyme_reaction_data[reac_id]\n        if current_enzyme_reaction_data is None:\n            ignored_reac_ids.append(reac_id)\n            continue\n\n        mw = 0.0\n        for identifier in current_enzyme_reaction_data.identifiers:\n            if reac_id in special_enzyme_stoichiometries:\n                if identifier in special_enzyme_stoichiometries[reac_id]:\n                    stoichiometry = special_enzyme_stoichiometries[reac_id][identifier]\n                else:\n                    stoichiometry = 1.0\n            else:\n                stoichiometry = 1.0\n            mw += stoichiometry * enzyme_molecular_weights[identifier]\n        k_cat = current_enzyme_reaction_data.k_cat\n        mw_by_k_cat = mw / k_cat\n\n        if reac_id.endswith(fwd_suffix):\n            direction_addition = fwd_suffix\n        elif reac_id.endswith(rev_suffix):\n            direction_addition = rev_suffix\n        else:\n            direction_addition = \"\"\n        base_id = reac_id.split(reac_enz_separator)[0] + direction_addition\n\n        if (\n            base_id not in base_reacs_to_min_mw_by_k_cat\n            or mw_by_k_cat &lt; base_reacs_to_min_mw_by_k_cat[base_id][1]\n        ):\n            base_reacs_to_min_mw_by_k_cat[base_id] = (reac_id, mw_by_k_cat)\n    enz_reacs_to_keep = [entry[0] for entry in base_reacs_to_min_mw_by_k_cat.values()]\n    reacs_to_delete = [\n        reac_id\n        for reac_id in reac_ids\n        if (reac_enz_separator in reac_id)\n        and (reac_id not in enz_reacs_to_keep)\n        and (reac_id not in ignored_reac_ids)\n    ]\n    cobra_model.remove_reactions(reacs_to_delete)\n    return cobra_model\n</code></pre>"},{"location":"api.html#cobrak.model_instantiation.get_cobrak_model_from_sbml_and_thermokinetic_data","title":"<code>get_cobrak_model_from_sbml_and_thermokinetic_data(sbml_path, extra_linear_constraints, dG0s, dG0_uncertainties, conc_ranges, enzyme_molecular_weights, enzyme_reaction_data, max_prot_pool, kinetic_ignored_metabolites, enzyme_conc_ranges={}, do_model_fullsplit=False, do_delete_enzymatically_suboptimal_reactions=True, R=STANDARD_R, T=STANDARD_T, fwd_suffix=REAC_FWD_SUFFIX, rev_suffix=REAC_REV_SUFFIX, reac_enz_separator=REAC_ENZ_SEPARATOR, omitted_metabolites=[], keep_parameter_refs=False)</code>","text":"<p>Creates a COBRAk model from an SBML and given further thermokinetic (thermodynamic and enzymatic) data.</p> <p>This function constructs a <code>Model</code> by integrating thermokinetic data and additional constraints into an existing COBRA-k model. It allows for the specification of concentration ranges, enzyme molecular weights, and reaction data, among other parameters.</p> <p>Parameters:</p> Name Type Description Default <code>sbml_path</code> <code>str</code> <p>The SBML model to be converted.</p> required <code>extra_linear_constraints</code> <code>list[ExtraLinearConstraint]</code> <p>Additional linear constraints to be applied to the model.</p> required <code>dG0s</code> <code>dict[str, float]</code> <p>Standard Gibbs free energy changes for reactions.</p> required <code>dG0_uncertainties</code> <code>dict[str, float]</code> <p>Uncertainties in the standard Gibbs free energy changes.</p> required <code>conc_ranges</code> <code>dict[str, tuple[float, float]]</code> <p>Concentration ranges for metabolites.</p> required <code>enzyme_molecular_weights</code> <code>dict[str, float]</code> <p>Molecular weights of enzymes.</p> required <code>enzyme_reaction_data</code> <code>dict[str, EnzymeReactionData | None]</code> <p>Enzyme reaction data for reactions.</p> required <code>max_prot_pool</code> <code>float</code> <p>Maximum protein pool constraint.</p> required <code>kinetic_ignored_metabolites</code> <code>list[str]</code> <p>Metabolites to be ignored in kinetic calculations.</p> required <code>enzyme_conc_ranges</code> <code>dict[str, tuple[float, float] | None]</code> <p>Concentration ranges for enzymes. Defaults to {}.</p> <code>{}</code> <code>do_model_fullsplit</code> <code>bool</code> <p>Whether to perform a full split of the model. Defaults to True.</p> <code>False</code> <code>do_delete_enzymatically_suboptimal_reactions</code> <code>bool</code> <p>Whether to delete enzymatically suboptimal reactions. Defaults to True.</p> <code>True</code> <code>R</code> <code>float</code> <p>Universal gas constant. Defaults to STANDARD_R.</p> <code>STANDARD_R</code> <code>T</code> <code>float</code> <p>Temperature in Kelvin. Defaults to STANDARD_T.</p> <code>STANDARD_T</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a concentration range for a metabolite is not provided and no default is set.</p> <p>Returns:</p> Name Type Description <code>Model</code> <code>Model</code> <p>The constructed <code>Model</code> with integrated thermokinetic data and constraints.</p> Source code in <code>cobrak/model_instantiation.py</code> <pre><code>def get_cobrak_model_from_sbml_and_thermokinetic_data(\n    sbml_path: str,\n    extra_linear_constraints: list[ExtraLinearConstraint],\n    dG0s: dict[str, float],\n    dG0_uncertainties: dict[str, float],\n    conc_ranges: dict[str, tuple[float, float]],\n    enzyme_molecular_weights: dict[str, float],\n    enzyme_reaction_data: dict[str, EnzymeReactionData | None],\n    max_prot_pool: float,\n    kinetic_ignored_metabolites: list[str],\n    enzyme_conc_ranges: dict[str, tuple[float, float] | None] = {},\n    do_model_fullsplit: bool = False,\n    do_delete_enzymatically_suboptimal_reactions: bool = True,\n    R: float = STANDARD_R,\n    T: float = STANDARD_T,\n    fwd_suffix: str = REAC_FWD_SUFFIX,\n    rev_suffix: str = REAC_REV_SUFFIX,\n    reac_enz_separator: str = REAC_ENZ_SEPARATOR,\n    omitted_metabolites: list[str] = [],\n    keep_parameter_refs: bool = False,\n) -&gt; Model:\n    \"\"\"Creates a COBRAk model from an SBML and given further thermokinetic (thermodynamic and enzymatic) data.\n\n    This function constructs a `Model` by integrating thermokinetic data and additional constraints\n    into an existing COBRA-k model. It allows for the specification of concentration ranges, enzyme molecular weights, and\n    reaction data, among other parameters.\n\n    Args:\n        sbml_path (str): The SBML model to be converted.\n        extra_linear_constraints (list[ExtraLinearConstraint]): Additional linear constraints to be applied to the model.\n        dG0s (dict[str, float]): Standard Gibbs free energy changes for reactions.\n        dG0_uncertainties (dict[str, float]): Uncertainties in the standard Gibbs free energy changes.\n        conc_ranges (dict[str, tuple[float, float]]): Concentration ranges for metabolites.\n        enzyme_molecular_weights (dict[str, float]): Molecular weights of enzymes.\n        enzyme_reaction_data (dict[str, EnzymeReactionData | None]): Enzyme reaction data for reactions.\n        max_prot_pool (float): Maximum protein pool constraint.\n        kinetic_ignored_metabolites (list[str]): Metabolites to be ignored in kinetic calculations.\n        enzyme_conc_ranges (dict[str, tuple[float, float] | None], optional): Concentration ranges for enzymes. Defaults to {}.\n        do_model_fullsplit (bool, optional): Whether to perform a full split of the model. Defaults to True.\n        do_delete_enzymatically_suboptimal_reactions (bool, optional): Whether to delete enzymatically suboptimal reactions. Defaults to True.\n        R (float, optional): Universal gas constant. Defaults to STANDARD_R.\n        T (float, optional): Temperature in Kelvin. Defaults to STANDARD_T.\n\n    Raises:\n        ValueError: If a concentration range for a metabolite is not provided and no default is set.\n\n    Returns:\n        Model: The constructed `Model` with integrated thermokinetic data and constraints.\n    \"\"\"\n    cobra_model = cobra.io.read_sbml_model(sbml_path)\n\n    if do_model_fullsplit:\n        cobra_model = get_fullsplit_cobra_model(cobra_model)\n\n    cobrak_model = Model(\n        reactions={},\n        metabolites={},\n        enzymes={},\n        max_prot_pool=max_prot_pool,\n        extra_linear_constraints=extra_linear_constraints,\n        kinetic_ignored_metabolites=kinetic_ignored_metabolites,\n        R=R,\n        T=T,\n        fwd_suffix=fwd_suffix,\n        rev_suffix=rev_suffix,\n        reac_enz_separator=reac_enz_separator,\n    )\n\n    for metabolite in cobra_model.metabolites:\n        if metabolite.id in omitted_metabolites:\n            continue\n\n        if metabolite.id in conc_ranges:\n            min_conc = conc_ranges[metabolite.id][0]\n            max_conc = conc_ranges[metabolite.id][1]\n        elif \"DEFAULT\" in conc_ranges:\n            min_conc = conc_ranges[\"DEFAULT\"][0]\n            max_conc = conc_ranges[\"DEFAULT\"][1]\n        else:\n            print(f\"ERROR: No concentration range for metabolite {metabolite.id}.\")\n            print(\"Fixes: 1) Set its specific range; 2) Set a 'DEFAULT' range.\")\n            raise ValueError\n\n        cobrak_model.metabolites[metabolite.id] = Metabolite(\n            log_min_conc=log(min_conc),\n            log_max_conc=log(max_conc),\n            annotation=metabolite.annotation,\n            name=metabolite.name,\n            formula=\"\" if not metabolite.formula else metabolite.formula,\n            charge=metabolite.charge,\n        )\n\n    for reaction in cobra_model.reactions:\n        dG0 = dG0s.get(reaction.id)\n\n        dG0_uncertainty = dG0_uncertainties.get(reaction.id)\n\n        if reaction.id in enzyme_reaction_data:\n            used_enzyme_reaction_data = enzyme_reaction_data[reaction.id]\n            if (used_enzyme_reaction_data is not None) and (not keep_parameter_refs):\n                used_enzyme_reaction_data.k_cat_references = []\n                used_enzyme_reaction_data.k_m_references = {}\n                used_enzyme_reaction_data.k_i_references = {}\n                used_enzyme_reaction_data.k_a_references = {}\n        else:\n            used_enzyme_reaction_data = None\n\n        cobrak_model.reactions[reaction.id] = Reaction(\n            min_flux=reaction.lower_bound,\n            max_flux=reaction.upper_bound,\n            stoichiometries={\n                metabolite.id: value\n                for (metabolite, value) in reaction.metabolites.items()\n                if metabolite.id not in omitted_metabolites\n            },\n            dG0=dG0,\n            dG0_uncertainty=dG0_uncertainty,\n            enzyme_reaction_data=used_enzyme_reaction_data,\n            annotation=reaction.annotation,\n            name=reaction.name,\n        )\n\n    cobra_gene_ids = [gene.id for gene in cobra_model.genes]\n    for enzyme_id, molecular_weight in enzyme_molecular_weights.items():\n        min_enzyme_conc = None\n        max_enzyme_conc = None\n        if enzyme_id in enzyme_conc_ranges:\n            conc_range = enzyme_conc_ranges[enzyme_id]\n            if conc_range is not None:\n                min_enzyme_conc = conc_range[0]\n                max_enzyme_conc = conc_range[1]\n        if enzyme_id in cobra_gene_ids:\n            name = cobra_model.genes.get_by_id(enzyme_id).id\n            annotation = cobra_model.genes.get_by_id(enzyme_id).annotation\n        else:\n            name = \"\"\n            annotation = {}\n        cobrak_model.enzymes[enzyme_id] = Enzyme(\n            molecular_weight=molecular_weight,\n            min_conc=min_enzyme_conc,\n            max_conc=max_enzyme_conc,\n            name=name,\n            annotation=annotation,\n        )\n\n    if do_delete_enzymatically_suboptimal_reactions:\n        cobrak_model = delete_enzymatically_suboptimal_reactions_in_cobrak_model(\n            cobrak_model\n        )\n\n    return cobrak_model\n</code></pre>"},{"location":"api.html#cobrak.model_instantiation.get_cobrak_model_with_kinetic_data_from_sbml_model_alone","title":"<code>get_cobrak_model_with_kinetic_data_from_sbml_model_alone(sbml_path, path_to_external_resources, folder_of_sabio_database, brenda_version, prefer_brenda, base_species, max_prot_pool, conc_ranges, inner_to_outer_compartments, phs, pmgs, ionic_strenghts, potential_differences, kinetic_ignored_enzymes, custom_kms_and_kcats, kinetic_ignored_metabolites, do_model_fullsplit=True, do_delete_enzymatically_suboptimal_reactions=True, ignore_dG0_uncertainty=True, enzyme_conc_ranges={}, dG0_exclusion_prefixes=[], dG0_exclusion_inner_parts=[], dG0_corrections={}, extra_linear_constraints=[], data_cache_folder='', R=STANDARD_R, T=STANDARD_T, keep_parameter_refs=False, enzymes_to_delete=[], max_taxonomy_level=float('inf'), add_hill_coefficients=True)</code>","text":"<p>This functions creates a Model out of an SBML model and automatically collects kinetic and thermodynamic data.</p> <p>To make this function work, the functions needs in the COBRApy model... ...for the reactions: An EC number annotation [for enzymatic constraints] ...for the metabolites: BiGG IDs ...and all the other non-optional data in its arguments</p> <p>Parameters:</p> Name Type Description Default <code>sbml_path</code> <code>str</code> <p>The SBML model file path from which the Model and associated data retrieval shall be made</p> required <code>path_to_external_resources</code> <code>str</code> <p>description</p> required <code>brenda_version</code> <code>str</code> <p>description</p> required <code>base_species</code> <code>str</code> <p>description</p> required <code>max_prot_pool</code> <code>float</code> <p>description</p> required <code>conc_ranges</code> <code>dict[str, tuple[float, float]]</code> <p>description</p> required <code>inner_to_outer_compartments</code> <code>list[str]</code> <p>description</p> required <code>phs</code> <code>dict[str, float]</code> <p>description</p> required <code>pmgs</code> <code>dict[str, float]</code> <p>description</p> required <code>ionic_strenghts</code> <code>dict[str, float]</code> <p>description</p> required <code>potential_differences</code> <code>dict[tuple[str, str], float]</code> <p>description</p> required <code>kinetic_ignored_enzymes</code> <code>list[str]</code> <p>description</p> required <code>custom_kms_and_kcats</code> <code>dict[str, EnzymeReactionData | None]</code> <p>description</p> required <code>kinetic_ignored_metabolites</code> <code>list[str]</code> <p>description</p> required <code>do_model_fullsplit</code> <code>bool</code> <p>description. Defaults to True.</p> <code>True</code> <code>do_delete_enzymatically_suboptimal_reactions</code> <code>bool</code> <p>description. Defaults to True.</p> <code>True</code> <code>ignore_dG0_uncertainty</code> <code>bool</code> <p>description. Defaults to True.</p> <code>True</code> <code>enzyme_conc_ranges</code> <code>dict[str, tuple[float, float] | None]</code> <p>description. Defaults to {}.</p> <code>{}</code> <code>dG0_exclusion_prefixes</code> <code>list[str]</code> <p>description. Defaults to [].</p> <code>[]</code> <code>dG0_exclusion_inner_parts</code> <code>list[str]</code> <p>description. Defaults to [].</p> <code>[]</code> <code>extra_linear_constraints</code> <code>list[ExtraLinearConstraint]</code> <p>description. Defaults to [].</p> <code>[]</code> <code>data_cache_folder</code> <code>str</code> <p>description. Defaults to \"\".</p> <code>''</code> <code>R</code> <code>float</code> <p>description. Defaults to STANDARD_R.</p> <code>STANDARD_R</code> <code>T</code> <code>float</code> <p>description. Defaults to STANDARD_T.</p> <code>STANDARD_T</code> <code>add_hill_coefficients</code> <code>bool</code> <p>Whether Hill coefficeints shall be collected (True) or not (False). They are added (as they cannot be separated for \u03ba, \u03b9 and \u03b1 as HilLCoefficient instances). Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>Model</code> <code>Model</code> <p>description</p> Source code in <code>cobrak/model_instantiation.py</code> <pre><code>def get_cobrak_model_with_kinetic_data_from_sbml_model_alone(\n    sbml_path: str,\n    path_to_external_resources: str,\n    folder_of_sabio_database: str,\n    brenda_version: str,\n    prefer_brenda: bool,\n    base_species: str,\n    max_prot_pool: float,\n    conc_ranges: dict[str, tuple[float, float]],\n    inner_to_outer_compartments: list[str],\n    phs: dict[str, float],\n    pmgs: dict[str, float],\n    ionic_strenghts: dict[str, float],\n    potential_differences: dict[tuple[str, str], float],\n    kinetic_ignored_enzymes: list[str],\n    custom_kms_and_kcats: dict[str, EnzymeReactionData | None],\n    kinetic_ignored_metabolites: list[str],\n    do_model_fullsplit: bool = True,\n    do_delete_enzymatically_suboptimal_reactions: bool = True,\n    ignore_dG0_uncertainty: bool = True,\n    enzyme_conc_ranges: dict[str, tuple[float, float] | None] = {},\n    dG0_exclusion_prefixes: list[str] = [],\n    dG0_exclusion_inner_parts: list[str] = [],\n    dG0_corrections: dict[str, float] = {},\n    extra_linear_constraints: list[ExtraLinearConstraint] = [],\n    data_cache_folder: str = \"\",\n    R: float = STANDARD_R,\n    T: float = STANDARD_T,\n    keep_parameter_refs: bool = False,\n    enzymes_to_delete: list[str] = [],\n    max_taxonomy_level: float = float(\"inf\"),\n    add_hill_coefficients: bool = True,\n) -&gt; Model:\n    \"\"\"This functions creates a Model out of an SBML model and automatically collects kinetic and thermodynamic data.\n\n    To make this function work, the functions needs in the COBRApy model...\n    ...for the reactions: An EC number annotation [for enzymatic constraints]\n    ...for the metabolites: BiGG IDs\n    ...and all the other non-optional data in its arguments\n\n    Args:\n        sbml_path (str): The SBML model file path from which the Model and associated data retrieval shall be made\n        path_to_external_resources (str): _description_\n        brenda_version (str): _description_\n        base_species (str): _description_\n        max_prot_pool (float): _description_\n        conc_ranges (dict[str, tuple[float, float]]): _description_\n        inner_to_outer_compartments (list[str]): _description_\n        phs (dict[str, float]): _description_\n        pmgs (dict[str, float]): _description_\n        ionic_strenghts (dict[str, float]): _description_\n        potential_differences (dict[tuple[str, str], float]): _description_\n        kinetic_ignored_enzymes (list[str]): _description_\n        custom_kms_and_kcats (dict[str, EnzymeReactionData  |  None]): _description_\n        kinetic_ignored_metabolites (list[str]): _description_\n        do_model_fullsplit (bool, optional): _description_. Defaults to True.\n        do_delete_enzymatically_suboptimal_reactions (bool, optional): _description_. Defaults to True.\n        ignore_dG0_uncertainty (bool, optional): _description_. Defaults to True.\n        enzyme_conc_ranges (dict[str, tuple[float, float]  |  None], optional): _description_. Defaults to {}.\n        dG0_exclusion_prefixes (list[str], optional): _description_. Defaults to [].\n        dG0_exclusion_inner_parts (list[str], optional): _description_. Defaults to [].\n        extra_linear_constraints (list[ExtraLinearConstraint], optional): _description_. Defaults to [].\n        data_cache_folder (str, optional): _description_. Defaults to \"\".\n        R (float, optional): _description_. Defaults to STANDARD_R.\n        T (float, optional): _description_. Defaults to STANDARD_T.\n        add_hill_coefficients (bool, optional): Whether Hill coefficeints shall be collected (True) or not (False).\n            They are added (as they cannot be separated for \u03ba, \u03b9 *and* \u03b1 as HilLCoefficient instances). Defaults to True.\n\n    Returns:\n        Model: _description_\n    \"\"\"\n    cobra_model = load_unannotated_sbml_as_cobrapy_model(sbml_path)\n    remove_genes(\n        model=cobra_model,\n        gene_list=enzymes_to_delete,\n        remove_reactions=False,\n    )\n\n    path_to_external_resources = standardize_folder(path_to_external_resources)\n    if data_cache_folder:\n        data_cache_folder = standardize_folder(data_cache_folder)\n        data_cache_files = get_files(data_cache_folder)\n\n    parse_external_resources(path_to_external_resources, brenda_version)\n\n    if do_model_fullsplit:\n        fullsplit_model = get_fullsplit_cobra_model(cobra_model)\n    else:\n        fullsplit_model = deepcopy(cobra_model)\n\n    enzyme_reaction_data: dict[str, EnzymeReactionData | None] = {}\n    if (not data_cache_folder) or (\n        (data_cache_folder)\n        and (\n            (\"_cache_dG0.json\" not in data_cache_files)\n            or (\"_cache_dG0_uncertainties.json\" not in data_cache_files)\n        )\n    ):\n        brenda_enzyme_reaction_data = brenda_select_enzyme_kinetic_data_for_model(\n            cobra_model=fullsplit_model,\n            brenda_json_targz_file_path=f\"{path_to_external_resources}brenda_2024_1.json.tar.gz\",\n            bigg_metabolites_json_path=f\"{path_to_external_resources}bigg_models_metabolites.json\",\n            brenda_version=brenda_version,\n            base_species=base_species,\n            ncbi_parsed_json_path=f\"{path_to_external_resources}parsed_taxdmp.json\",\n            kinetic_ignored_metabolites=kinetic_ignored_metabolites,\n            kinetic_ignored_enzyme_ids=kinetic_ignored_enzymes,\n            custom_enzyme_kinetic_data=custom_kms_and_kcats,\n            max_taxonomy_level=max_taxonomy_level,\n        )\n        sabio_enzyme_reaction_data = sabio_select_enzyme_kinetic_data_for_model(\n            cobra_model=fullsplit_model,\n            sabio_target_folder=folder_of_sabio_database,\n            base_species=base_species,\n            ncbi_parsed_json_path=f\"{path_to_external_resources}parsed_taxdmp.json\",\n            bigg_metabolites_json_path=f\"{path_to_external_resources}bigg_models_metabolites.json\",\n            kinetic_ignored_metabolites=kinetic_ignored_metabolites,\n            kinetic_ignored_enzyme_ids=kinetic_ignored_enzymes,\n            custom_enzyme_kinetic_data=custom_kms_and_kcats,\n            max_taxonomy_level=max_taxonomy_level,\n            add_hill_coefficients=add_hill_coefficients,\n        )\n\n        enzyme_reaction_data = combine_enzyme_reaction_datasets(\n            [\n                (\n                    brenda_enzyme_reaction_data\n                    if prefer_brenda\n                    else sabio_enzyme_reaction_data\n                ),\n                (\n                    sabio_enzyme_reaction_data\n                    if prefer_brenda\n                    else brenda_enzyme_reaction_data\n                ),\n            ]\n        )\n\n        if data_cache_folder:\n            json_write(\n                f\"{data_cache_folder}_cache_enzyme_reaction_data.json\",\n                enzyme_reaction_data,\n            )\n    else:\n        enzyme_reaction_data = json_load(\n            f\"{data_cache_folder}_cache_enzyme_reaction_data.json\",\n            dict[str, EnzymeReactionData | None],\n        )\n\n    enzyme_molecular_weights = uniprot_get_enzyme_molecular_weights(\n        model=fullsplit_model,\n        cache_basepath=data_cache_folder,\n    )\n\n    if do_delete_enzymatically_suboptimal_reactions:\n        fullsplit_model = (\n            delete_enzymatically_suboptimal_reactions_in_fullsplit_cobrapy_model(\n                fullsplit_model,\n                enzyme_reaction_data,\n                enzyme_molecular_weights,\n            )\n        )\n\n    if (not data_cache_folder) or (\n        (data_cache_folder)\n        and (\n            (\"_cache_dG0.json\" not in data_cache_files)\n            or (\"_cache_dG0_uncertainties.json\" not in data_cache_files)\n        )\n    ):\n        with tempfile.TemporaryDirectory() as tmpdict:\n            cobra.io.write_sbml_model(fullsplit_model, tmpdict + \"temp.xml\")\n        dG0s, dG0_uncertainties = equilibrator_get_model_dG0_and_uncertainty_values(\n            tmpdict + \"temp.xml\",\n            inner_to_outer_compartments,\n            phs,\n            pmgs,\n            ionic_strenghts,\n            potential_differences,\n            dG0_exclusion_prefixes,\n            dG0_exclusion_inner_parts,\n            ignore_dG0_uncertainty,\n        )\n        if data_cache_folder:\n            json_write(f\"{data_cache_folder}_cache_dG0.json\", dG0s)\n            json_write(\n                f\"{data_cache_folder}_cache_dG0_uncertainties.json\", dG0_uncertainties\n            )\n    else:\n        dG0s = json_load(f\"{data_cache_folder}_cache_dG0.json\", dict[str, float])\n        dG0_uncertainties = json_load(\n            f\"{data_cache_folder}_cache_dG0_uncertainties.json\",\n            dict[str, float],\n        )\n\n        dG0_keys = list(dG0s.keys())\n        for dG0_key in dG0_keys:\n            if any(\n                dG0_key.startswith(dG0_exclusion_prefix)\n                for dG0_exclusion_prefix in dG0_exclusion_prefixes\n            ) or any(\n                dG0_exclusion_inner_part in dG0_key\n                for dG0_exclusion_inner_part in dG0_exclusion_inner_parts\n            ):\n                del dG0s[dG0_key]\n                if dG0_key in dG0_uncertainties:\n                    del dG0_uncertainties[dG0_key]\n\n    for key, value in dG0_corrections.items():\n        dG0s[key] += value\n\n    with tempfile.TemporaryDirectory() as tmpdict:\n        cobra.io.write_sbml_model(fullsplit_model, tmpdict + \"temp.xml\")\n        return get_cobrak_model_from_sbml_and_thermokinetic_data(\n            sbml_path=tmpdict + \"temp.xml\",\n            extra_linear_constraints=extra_linear_constraints,\n            dG0s=dG0s,\n            dG0_uncertainties=dG0_uncertainties,\n            conc_ranges=conc_ranges,\n            enzyme_molecular_weights=enzyme_molecular_weights,\n            enzyme_reaction_data=enzyme_reaction_data,\n            max_prot_pool=max_prot_pool,\n            kinetic_ignored_metabolites=kinetic_ignored_metabolites,\n            enzyme_conc_ranges=enzyme_conc_ranges,\n            R=R,\n            T=T,\n            keep_parameter_refs=keep_parameter_refs,\n            do_delete_enzymatically_suboptimal_reactions=False,\n        )\n</code></pre>"},{"location":"api.html#cobrak.ncbi_taxonomy_functionality","title":"<code>ncbi_taxonomy_functionality</code>","text":"<p>ncbi_taxonomy.py</p> <p>This module contains functions which can access NCBI TAXONOMY.</p>"},{"location":"api.html#cobrak.ncbi_taxonomy_functionality.get_taxonomy_dict_from_nbci_taxonomy","title":"<code>get_taxonomy_dict_from_nbci_taxonomy(organisms, parsed_json_data)</code>","text":"<p>Generates a taxonomy dictionary from NCBI taxonomy data.</p> <p>This function constructs a dictionary mapping each organism to its taxonomy path based on the provided NCBI taxonomy data.</p> <p>Parameters:</p> Name Type Description Default <code>organisms</code> <code>list[str]</code> <p>A list of organism names for which taxonomy paths are to be retrieved.</p> required <code>parsed_json_data</code> <code>dict[str, Any]</code> <p>Parsed JSON data containing taxonomy information, including: - \"number_to_names_dict\": A dictionary mapping taxonomy numbers to names. - \"names_to_number_dict\": A dictionary mapping organism names to taxonomy numbers. - \"nodes_dict\": A dictionary representing the taxonomy tree structure.</p> required <p>Returns:</p> Type Description <code>dict[str, list[str]]</code> <p>dict[str, list[str]]: A dictionary where each key is an organism name and the value is a list of taxonomy names</p> <code>dict[str, list[str]]</code> <p>representing the path from the organism to the root of the taxonomy tree.</p> Source code in <code>cobrak/ncbi_taxonomy_functionality.py</code> <pre><code>@validate_call(validate_return=True)\ndef get_taxonomy_dict_from_nbci_taxonomy(\n    organisms: list[str],\n    parsed_json_data: dict[str, Any],\n) -&gt; dict[str, list[str]]:\n    \"\"\"Generates a taxonomy dictionary from NCBI taxonomy data.\n\n    This function constructs a dictionary mapping each organism to its taxonomy path based on the provided NCBI taxonomy data.\n\n    Args:\n        organisms (list[str]): A list of organism names for which taxonomy paths are to be retrieved.\n        parsed_json_data (dict[str, Any]): Parsed JSON data containing taxonomy information, including:\n            - \"number_to_names_dict\": A dictionary mapping taxonomy numbers to names.\n            - \"names_to_number_dict\": A dictionary mapping organism names to taxonomy numbers.\n            - \"nodes_dict\": A dictionary representing the taxonomy tree structure.\n\n    Returns:\n        dict[str, list[str]]: A dictionary where each key is an organism name and the value is a list of taxonomy names\n        representing the path from the organism to the root of the taxonomy tree.\n    \"\"\"\n    number_to_names_dict = parsed_json_data[\"number_to_names_dict\"]\n    names_to_number_dict = parsed_json_data[\"names_to_number_dict\"]\n    nodes_dict = parsed_json_data[\"nodes_dict\"]\n\n    organism_to_taxonomy_dicts: dict[str, list[str]] = {}\n    for organism in organisms:\n        try:\n            node_train = [names_to_number_dict[organism]]\n        except KeyError:\n            organism_to_taxonomy_dicts[organism] = [organism, \"all\"]\n            continue\n        current_number = names_to_number_dict[organism]\n        while True:\n            next_number = nodes_dict[current_number]\n            if next_number == \"END\":\n                break\n            node_train.append(next_number)\n            current_number = next_number\n        node_train_names = [number_to_names_dict[x][0] for x in node_train]\n        organism_to_taxonomy_dicts[organism] = node_train_names\n    return organism_to_taxonomy_dicts\n</code></pre>"},{"location":"api.html#cobrak.ncbi_taxonomy_functionality.get_taxonomy_scores","title":"<code>get_taxonomy_scores(base_species, taxonomy_dict)</code>","text":"<p>Returns a dictionary with a taxonomic distance from the given organism.</p> <p>e.g. if base_species is \"Escherichia coli\" and taxonomy_dict is</p> <pre>\n{\n    \"Escherichia coli\": [\"Escherichia\", \"Bacteria\", \"Organism\"],\n    \"Pseudomonas\": [\"Pseudomonas\", \"Bacteria\", \"Organism\"],\n    \"Homo sapiens\": [\"Homo\", \"Mammalia\", \"Animalia\", \"Organism\"],\n}\n</pre> <p>this function would return</p> <pre>\n{\n    \"Escherichia coli\": 0,\n    \"Pseudomonas\": 1,\n    \"Homo sapiens\": 4,\n}\n</pre>"},{"location":"api.html#cobrak.ncbi_taxonomy_functionality.get_taxonomy_scores--arguments","title":"Arguments","text":"<ul> <li>base_species: str ~ The species to which a relation is made.</li> <li>taxonomy_dict: dict[str, list[str]] ~ A dictionary with organism names as keys and   their taxonomic levels (sorted from nearest to farthest) as string list.</li> </ul> Source code in <code>cobrak/ncbi_taxonomy_functionality.py</code> <pre><code>@validate_call(validate_return=True)\ndef get_taxonomy_scores(\n    base_species: str,\n    taxonomy_dict: dict[str, list[str]],\n) -&gt; dict[str, NonNegativeInt]:\n    \"\"\"Returns a dictionary with a taxonomic distance from the given organism.\n\n    e.g. if base_species is \"Escherichia coli\" and taxonomy_dict is\n    &lt;pre&gt;\n    {\n        \"Escherichia coli\": [\"Escherichia\", \"Bacteria\", \"Organism\"],\n        \"Pseudomonas\": [\"Pseudomonas\", \"Bacteria\", \"Organism\"],\n        \"Homo sapiens\": [\"Homo\", \"Mammalia\", \"Animalia\", \"Organism\"],\n    }\n    &lt;/pre&gt;\n    this function would return\n    &lt;pre&gt;\n    {\n        \"Escherichia coli\": 0,\n        \"Pseudomonas\": 1,\n        \"Homo sapiens\": 4,\n    }\n    &lt;/pre&gt;\n\n    Arguments\n    ----------\n    * base_species: str ~ The species to which a relation is made.\n    * taxonomy_dict: dict[str, list[str]] ~ A dictionary with organism names as keys and\n      their taxonomic levels (sorted from nearest to farthest) as string list.\n    \"\"\"\n    base_species_taxonomy = taxonomy_dict[base_species]\n    taxonomy_scores: dict[str, int] = {\n        base_species: 0,\n    }\n    for other_species_name, other_species_taxonomy in taxonomy_dict.items():\n        score = 0\n        for taxonomy_part in base_species_taxonomy:\n            if taxonomy_part in other_species_taxonomy:\n                break\n            score += 1\n        taxonomy_scores[other_species_name] = score\n\n    return taxonomy_scores\n</code></pre>"},{"location":"api.html#cobrak.ncbi_taxonomy_functionality.most_taxonomic_similar","title":"<code>most_taxonomic_similar(base_species, taxonomy_dict)</code>","text":"<p>Returns a dictionary with a score of taxonomic distance from the given organism.</p> <p>e.g. if base_species is \"Escherichia coli\" and taxonomy_dict is</p> <pre>\n{\n    \"Escherichia coli\": [\"Escherichia\", \"Bacteria\", \"Organism\"],\n    \"Pseudomonas\": [\"Pseudomonas\", \"Bacteria\", \"Organism\"],\n    \"Homo sapiens\": [\"Homo\", \"Mammalia\", \"Animalia\", \"Organism\"],\n}\n</pre> <p>this function would return</p> <pre>\n{\n    \"Escherichia coli\": 0,\n    \"Pseudomonas\": 1,\n    \"Homo sapiens\": 2,\n}\n</pre>"},{"location":"api.html#cobrak.ncbi_taxonomy_functionality.most_taxonomic_similar--arguments","title":"Arguments","text":"<ul> <li>base_species: str ~ The species to which a relation is made.</li> <li>taxonomy_dict: dict[str, list[str]] ~ A dictionary with organism names as keys and   their taxonomic levels (sorted from nearest to farthest) as string list.</li> </ul> Source code in <code>cobrak/ncbi_taxonomy_functionality.py</code> <pre><code>@validate_call(validate_return=True)\ndef most_taxonomic_similar(\n    base_species: str, taxonomy_dict: dict[str, list[str]]\n) -&gt; dict[str, int]:\n    \"\"\"Returns a dictionary with a score of taxonomic distance from the given organism.\n\n    e.g. if base_species is \"Escherichia coli\" and taxonomy_dict is\n    &lt;pre&gt;\n    {\n        \"Escherichia coli\": [\"Escherichia\", \"Bacteria\", \"Organism\"],\n        \"Pseudomonas\": [\"Pseudomonas\", \"Bacteria\", \"Organism\"],\n        \"Homo sapiens\": [\"Homo\", \"Mammalia\", \"Animalia\", \"Organism\"],\n    }\n    &lt;/pre&gt;\n    this function would return\n    &lt;pre&gt;\n    {\n        \"Escherichia coli\": 0,\n        \"Pseudomonas\": 1,\n        \"Homo sapiens\": 2,\n    }\n    &lt;/pre&gt;\n\n    Arguments\n    ----------\n    * base_species: str ~ The species to which a relation is made.\n    * taxonomy_dict: dict[str, list[str]] ~ A dictionary with organism names as keys and\n      their taxonomic levels (sorted from nearest to farthest) as string list.\n    \"\"\"\n    base_taxonomy = taxonomy_dict[base_species]\n    level_dict: dict[str, int] = {}\n    for level, taxonomic_level in enumerate(base_taxonomy):\n        level_dict[taxonomic_level] = level\n\n    score_dict: dict[str, int] = {}\n    for species, taxonomic_levels in taxonomy_dict.items():\n        for taxonomic_level in taxonomic_levels:\n            if taxonomic_level in level_dict:\n                score_dict[species] = level_dict[taxonomic_level]\n                break\n\n    return score_dict\n</code></pre>"},{"location":"api.html#cobrak.ncbi_taxonomy_functionality.parse_ncbi_taxonomy","title":"<code>parse_ncbi_taxonomy(ncbi_taxdmp_zipfile_path, ncbi_parsed_json_path)</code>","text":"<p>Parses NCBI taxonomy data from a taxdump zip file and saves it as a JSON file.</p> <p>This function extracts the necessary files from the NCBI taxdump zip archive, parses the taxonomy data, and writes the parsed data to a JSON file. The parsed data includes mappings from taxonomy numbers to names and vice versa, as well as the taxonomy tree structure.</p> <p>Parameters:</p> Name Type Description Default <code>ncbi_taxdmp_zipfile_path</code> <code>str</code> <p>The file path to the NCBI taxdump zip archive.</p> required <code>ncbi_parsed_json_path</code> <code>str</code> <p>The file path where the parsed JSON data will be saved.</p> required Source code in <code>cobrak/ncbi_taxonomy_functionality.py</code> <pre><code>@validate_call(validate_return=True)\ndef parse_ncbi_taxonomy(\n    ncbi_taxdmp_zipfile_path: str,\n    ncbi_parsed_json_path: str,\n) -&gt; None:\n    \"\"\"Parses NCBI taxonomy data from a taxdump zip file and saves it as a JSON file.\n\n    This function extracts the necessary files from the NCBI taxdump zip archive, parses the taxonomy data,\n    and writes the parsed data to a JSON file. The parsed data includes mappings from taxonomy numbers to names\n    and vice versa, as well as the taxonomy tree structure.\n\n    Args:\n        ncbi_taxdmp_zipfile_path (str): The file path to the NCBI taxdump zip archive.\n        ncbi_parsed_json_path (str): The file path where the parsed JSON data will be saved.\n    \"\"\"\n    old_wd = os.getcwd()\n    folder = standardize_folder(os.path.dirname(ncbi_taxdmp_zipfile_path))\n    filename = os.path.basename(ncbi_taxdmp_zipfile_path)\n    os.chdir(folder)\n\n    with ZipFile(filename, \"r\") as zipfile:\n        zipfile.extract(\"names.dmp\")\n        zipfile.extract(\"nodes.dmp\")\n\n    with open(\"names.dmp\", encoding=\"utf-8\") as f:\n        name_lines = f.readlines()\n    with open(\"nodes.dmp\", encoding=\"utf-8\") as f:\n        node_lines = f.readlines()\n\n    os.remove(\"names.dmp\")\n    os.remove(\"nodes.dmp\")\n    os.chdir(old_wd)\n\n    parsed_json_data = {}\n\n    number_to_names_dict: dict[str, Any] = {}\n    names_to_number_dict = {}\n    for line in name_lines:\n        if (\"scientific name\" not in line) and (\"synonym\" not in line):\n            continue\n        number = line.split(\"|\")[0].lstrip().rstrip()\n        name = line.split(\"|\")[1].lstrip().rstrip()\n        if number not in number_to_names_dict:\n            number_to_names_dict[number] = []\n        number_to_names_dict[number].append(name)\n        names_to_number_dict[name] = number\n\n    parsed_json_data[\"number_to_names_dict\"] = number_to_names_dict\n    parsed_json_data[\"names_to_number_dict\"] = names_to_number_dict\n\n    nodes_dict = {}\n    for line in node_lines:\n        begin = line.split(\"|\")[0].lstrip().rstrip()\n        end = line.split(\"|\")[1].lstrip().rstrip()\n        if begin == end:\n            nodes_dict[begin] = \"END\"\n        else:\n            nodes_dict[begin] = end\n    parsed_json_data[\"nodes_dict\"] = nodes_dict\n    json_zip_write(ncbi_parsed_json_path, parsed_json_data)\n</code></pre>"},{"location":"api.html#cobrak.nlps","title":"<code>nlps</code>","text":"<p>This file contains all non-linear programs (NLP) functions, including the evolutionary NLP optimization algorithm, that can be used with COBRAk models. With NLPs, all types of constraints (stoichiomnetric, enzymatic, \u03ba, \u03b3, \u03b9, ...) can be integrated. However, NLPs can be very slow. For linear-programs (LP) and mixed-integer linear programs (MILP), see lps.py in the same folder.</p>"},{"location":"api.html#cobrak.nlps.add_loop_constraints_to_nlp","title":"<code>add_loop_constraints_to_nlp(model, cobrak_model)</code>","text":"<p>Adds loop constraints to a non-linear program (NLP) model.</p> <p>The loop constraints are of the nonlinear form v_fwd * v_rev = 0.0 for any forward/reverse pair of split reversible reactions.</p> <p>Parameters * <code>model</code> (<code>ConcreteModel</code>): The NLP model to add constraints to. * <code>cobrak_model</code> (<code>Model</code>): The COBRAk model associated with the NLP model.</p> <p>Returns * <code>ConcreteModel</code>: The NLP model with added loop constraints.</p> Source code in <code>cobrak/nlps.py</code> <pre><code>@validate_call(config=ConfigDict(arbitrary_types_allowed=True))\ndef add_loop_constraints_to_nlp(\n    model: ConcreteModel,\n    cobrak_model: Model,\n) -&gt; ConcreteModel:\n    \"\"\"Adds loop constraints to a non-linear program (NLP) model.\n\n    The loop constraints are of the nonlinear form v_fwd * v_rev = 0.0\n    for any forward/reverse pair of split reversible reactions.\n\n    Parameters\n    * `model` (`ConcreteModel`): The NLP model to add constraints to.\n    * `cobrak_model` (`Model`): The COBRAk model associated with the NLP model.\n\n    Returns\n    * `ConcreteModel`: The NLP model with added loop constraints.\n    \"\"\"\n    model_var_names = [v.name for v in model.component_objects(Var)]\n    for reac_id, reaction in cobrak_model.reactions.items():\n        if reaction.dG0 is not None:\n            continue\n        if not reac_id.endswith(cobrak_model.rev_suffix):\n            continue\n        other_reac_id = reac_id.replace(\n            cobrak_model.rev_suffix, cobrak_model.fwd_suffix\n        )\n        if other_reac_id not in model_var_names:\n            continue\n\n        setattr(\n            model,\n            f\"loop_constraint_{reac_id}\",\n            Constraint(\n                rule=getattr(model, reac_id) * getattr(model, other_reac_id) == 0.0\n            ),\n        )\n\n    return model\n</code></pre>"},{"location":"api.html#cobrak.nlps.get_nlp_from_cobrak_model","title":"<code>get_nlp_from_cobrak_model(cobrak_model, ignored_reacs=[], with_kappa=True, with_gamma=True, with_iota=False, with_alpha=False, approximation_value=0.0001, irreversible_mode=False, variability_data={}, strict_mode=False, single_strict_reacs=[], irreversible_mode_min_mdf=STANDARD_MIN_MDF, with_flux_sum_var=False, correction_config=CorrectionConfig())</code>","text":"<p>Creates a pyomo non-linear program (NLP) model instance from a COBRAk Model.</p> <p>For more, see COBRAk's NLP documentation chapter.</p>"},{"location":"api.html#cobrak.nlps.get_nlp_from_cobrak_model--parameters","title":"Parameters","text":"<ul> <li><code>cobrak_model</code> (<code>Model</code>): The COBRAk model to create the NLP model from.</li> <li><code>ignored_reacs</code> (<code>list[str]</code>, optional): List of reaction IDs to ignore. Defaults to <code>[]</code>.</li> <li><code>with_kappa</code> (<code>bool</code>, optional): Whether to include \u03ba saturation term terms. Defaults to <code>True</code>.</li> <li><code>with_gamma</code> (<code>bool</code>, optional): Whether to include \u03b3 thermodynamic terms. Defaults to <code>True</code>.</li> <li><code>with_iota</code> (<code>bool</code>, optional): Whether to include \u03b9 inhibition terms. Defaults to <code>False</code> and untested!</li> <li><code>with_alpha</code> (<code>bool</code>, optional): Whether to include \u03b1 activation terms. Defaults to <code>False</code> and untested!</li> <li><code>approximation_value</code> (<code>float</code>, optional): Approximation value for \u03ba, \u03b3, \u03b9, and \u03b1 terms. Defaults to <code>0.0001</code>. This value is the    minimal value for \u03ba, \u03b3, \u03b9, and \u03b1 terms, and can lead to an overapproximation in this regard.</li> <li><code>irreversible_mode</code> (<code>bool</code>, optional): Whether to use irreversible mode. Defaults to <code>False</code>.</li> <li><code>variability_data</code> (<code>dict[str, tuple[float, float]]</code>, optional): Variability data for reactions. Defaults to <code>{}</code>.</li> <li><code>strict_mode</code> (<code>bool</code>, optional): Whether to use strict mode (i.e. all &lt;= heuristics become == relations). Defaults to <code>False</code>.</li> <li><code>single_strict_reacs</code> (<code>list[str]</code>, optional): If 'strict_mode==False', only reactions with an ID in this list are set to strict mode.</li> <li><code>irreversible_mode_min_mdf</code> (<code>float</code>, optional): Minimum MDF value for irreversible mode. Defaults to <code>STANDARD_MIN_MDF</code>.</li> <li><code>with_flux_sum_var</code> (<code>bool</code>, optional): Whether to include a flux sum variable of name <code>cobrak.constants.FLUX_SUM_VAR</code>. Defaults to <code>False</code>.</li> <li><code>correction_config</code> (<code>CorrectionConfig</code>, optional): Parameter correction configuration. Defaults to <code>CorrectionConfig()</code>.</li> </ul>"},{"location":"api.html#cobrak.nlps.get_nlp_from_cobrak_model--returns","title":"Returns","text":"<ul> <li><code>ConcreteModel</code>: The created NLP model.</li> </ul> Source code in <code>cobrak/nlps.py</code> <pre><code>@validate_call(config=ConfigDict(arbitrary_types_allowed=True))\ndef get_nlp_from_cobrak_model(\n    cobrak_model: Model,\n    ignored_reacs: list[str] = [],\n    with_kappa: bool = True,\n    with_gamma: bool = True,\n    with_iota: bool = False,\n    with_alpha: bool = False,\n    approximation_value: float = 0.0001,\n    irreversible_mode: bool = False,\n    variability_data: dict[str, tuple[float, float]] = {},\n    strict_mode: bool = False,\n    single_strict_reacs: list[str] = [],\n    irreversible_mode_min_mdf: float = STANDARD_MIN_MDF,\n    with_flux_sum_var: bool = False,\n    correction_config: CorrectionConfig = CorrectionConfig(),\n) -&gt; ConcreteModel:\n    \"\"\"Creates a pyomo non-linear program (NLP) model instance from a COBRAk Model.\n\n    For more, see COBRAk's NLP documentation chapter.\n\n    # Parameters\n    * `cobrak_model` (`Model`): The COBRAk model to create the NLP model from.\n    * `ignored_reacs` (`list[str]`, optional): List of reaction IDs to ignore. Defaults to `[]`.\n    * `with_kappa` (`bool`, optional): Whether to include \u03ba saturation term terms. Defaults to `True`.\n    * `with_gamma` (`bool`, optional): Whether to include \u03b3 thermodynamic terms. Defaults to `True`.\n    * `with_iota` (`bool`, optional): Whether to include \u03b9 inhibition terms. Defaults to `False` and untested!\n    * `with_alpha` (`bool`, optional): Whether to include \u03b1 activation terms. Defaults to `False` and untested!\n    * `approximation_value` (`float`, optional): Approximation value for \u03ba, \u03b3, \u03b9, and \u03b1 terms. Defaults to `0.0001`. This value is the\n       minimal value for \u03ba, \u03b3, \u03b9, and \u03b1 terms, and can lead to an overapproximation in this regard.\n    * `irreversible_mode` (`bool`, optional): Whether to use irreversible mode. Defaults to `False`.\n    * `variability_data` (`dict[str, tuple[float, float]]`, optional): Variability data for reactions. Defaults to `{}`.\n    * `strict_mode` (`bool`, optional): Whether to use strict mode (i.e. all &lt;= heuristics become == relations). Defaults to `False`.\n    * `single_strict_reacs` (`list[str]`, optional): If 'strict_mode==False', only reactions with an ID in this list are set to strict mode.\n    * `irreversible_mode_min_mdf` (`float`, optional): Minimum MDF value for irreversible mode. Defaults to `STANDARD_MIN_MDF`.\n    * `with_flux_sum_var` (`bool`, optional): Whether to include a flux sum variable of name ```cobrak.constants.FLUX_SUM_VAR```. Defaults to `False`.\n    * `correction_config` (`CorrectionConfig`, optional): Parameter correction configuration. Defaults to `CorrectionConfig()`.\n\n    # Returns\n    * `ConcreteModel`: The created NLP model.\n    \"\"\"\n    cobrak_model = deepcopy(cobrak_model)\n\n    reac_ids = list(cobrak_model.reactions.keys())\n    enforced_reacs: list[str] = []\n    ignored_reacs = deepcopy(ignored_reacs)\n    for reac_id in variability_data:\n        if reac_id not in reac_ids:\n            continue\n        min_flux = variability_data[reac_id][0]\n        if min_flux &lt; 1e-6:\n            continue\n        enforced_reacs.append(reac_id)\n\n        if reac_id.endswith(\"_REV\"):\n            other_id = reac_id.replace(\"_REV\", \"_FWD\")\n        elif reac_id.endswith(\"_FWD\"):\n            other_id = reac_id.replace(\"_FWD\", \"_REV\")\n        else:\n            continue\n        if other_id in reac_ids:\n            ignored_reacs.append(other_id)\n\n    model = get_lp_from_cobrak_model(\n        cobrak_model=cobrak_model,\n        ignored_reacs=ignored_reacs,\n        with_enzyme_constraints=True,\n        with_thermodynamic_constraints=False,\n        with_loop_constraints=False,\n        add_extra_linear_constraints=False,\n        with_flux_sum_var=with_flux_sum_var,\n        correction_config=CorrectionConfig(\n            add_kcat_times_e_error_term=correction_config.add_kcat_times_e_error_term,\n            kcat_times_e_error_cutoff=correction_config.kcat_times_e_error_cutoff,\n            max_rel_kcat_times_e_correction=correction_config.max_rel_kcat_times_e_correction,\n            add_error_sum_term=False,\n        ),\n    )\n    model = _add_concentration_vars_and_constraints(model, cobrak_model)\n\n    if correction_config.add_kcat_times_e_error_term:\n        model_vars = get_model_var_names(model)\n\n    if correction_config.add_km_error_term:\n        kms_lowbound, kms_highbound = _get_km_bounds(\n            cobrak_model, correction_config.km_error_cutoff\n        )\n    else:\n        kms_lowbound, kms_highbound = 0.0, 0.0\n\n    if correction_config.add_dG0_error_term:\n        dG0_highbound = _get_dG0_highbound(\n            cobrak_model, correction_config.dG0_error_cutoff\n        )\n    else:\n        dG0_highbound = 0.0\n\n    setattr(\n        model,\n        MDF_VAR_ID,\n        Var(within=Reals, bounds=(irreversible_mode_min_mdf, 1_000_000)),\n    )\n    # Set \"MM\" constraints\n    if not irreversible_mode:\n        reaction_couples = get_stoichiometrically_coupled_reactions(\n            cobrak_model=cobrak_model,\n        )\n        reac_id_to_reac_couple_id: dict[str, str] = {}\n        for couple in reaction_couples:\n            for reac_id in couple:\n                reac_id_to_reac_couple_id[reac_id] = \"\".join(couple)\n        created_z_vars = []\n\n    if with_alpha or with_iota:\n        model_var_names = get_model_var_names(model)\n    for reac_id, reaction in cobrak_model.reactions.items():\n        if reac_id in ignored_reacs:\n            continue\n\n        if reaction.dG0 is not None:\n            model, f_var_name = _add_df_and_dG0_var_for_reaction(\n                model,\n                reac_id,\n                reaction,\n                cobrak_model,\n                strict_df_equality=strict_mode or reac_id in single_strict_reacs,\n                add_error_term=correction_config.add_dG0_error_term\n                and (reaction.dG0 &gt;= dG0_highbound),\n                max_abs_dG0_correction=correction_config.max_abs_dG0_correction,\n            )\n\n            if (\n                not irreversible_mode\n                and variability_data[reac_id][0] == 0.0\n                and variability_data[reac_id][1] != 0.0\n            ):\n                z_varname = f\"{Z_VAR_PREFIX}{reac_id_to_reac_couple_id[reac_id]}\"\n                if z_varname not in created_z_vars:\n                    setattr(model, z_varname, Var(within=Binary))\n                    created_z_vars.append(z_varname)\n\n                # Big-M 0: r_i &lt;= lb * z_i\n                bigm_optmdfpathway_0_constraint = getattr(\n                    model, reac_id\n                ) &lt;= reaction.max_flux * getattr(model, z_varname)\n                setattr(\n                    model,\n                    f\"bigm_optmdfpathway_0_{reac_id}\",\n                    Constraint(rule=bigm_optmdfpathway_0_constraint),\n                )\n\n                # Big-M 1: f_i + (1-z_i) * M_i &gt;= var_B\n                bigm_optmdfpathway_1_constraint = getattr(model, f_var_name) + (\n                    1 - getattr(model, z_varname)\n                ) * BIG_M &gt;= getattr(model, MDF_VAR_ID)\n\n                setattr(\n                    model,\n                    f\"bigm_optmdfpathway_1_{reac_id}\",\n                    Constraint(rule=bigm_optmdfpathway_1_constraint),\n                )\n            elif variability_data[reac_id][1] != 0.0:\n                mdf_constraint = getattr(model, f_var_name) &gt;= getattr(\n                    model, MDF_VAR_ID\n                )\n\n                setattr(\n                    model,\n                    f\"mdf_constraint_{reac_id}\",\n                    Constraint(rule=mdf_constraint),\n                )\n\n        if reaction.enzyme_reaction_data is None:\n            continue\n\n        # Determine whether or not \u03ba, \u03b3, \u03b9 and \u03b1 are possible to add to the reaction\n        # given its current kinetic and thermodynamic data.\n        has_gamma = True\n        has_kappa = True\n        if not have_all_unignored_km(\n            reaction, cobrak_model.kinetic_ignored_metabolites\n        ):\n            has_kappa = False\n        if reaction.dG0 is None:\n            has_gamma = False\n        if (not has_kappa) and (not has_gamma):\n            continue\n        has_iota = reaction.enzyme_reaction_data.k_is != {}\n        has_alpha = reaction.enzyme_reaction_data.k_as != {}\n\n        reac_full_enzyme_id = get_full_enzyme_id(\n            reaction.enzyme_reaction_data.identifiers\n        )\n        if not reac_full_enzyme_id:  # E.g., in ATPM\n            continue\n        enzyme_var_id = get_reaction_enzyme_var_id(reac_id, reaction)\n\n        # V+\n        k_cat = reaction.enzyme_reaction_data.k_cat\n\n        if correction_config.add_kcat_times_e_error_term:\n            kcat_times_e_error_var_id = f\"{ERROR_VAR_PREFIX}_kcat_times_e_{reac_id}\"\n            if kcat_times_e_error_var_id in model_vars:\n                v_plus = getattr(model, enzyme_var_id) * k_cat + getattr(\n                    model, kcat_times_e_error_var_id\n                )\n            else:\n                v_plus = getattr(model, enzyme_var_id) * k_cat\n        else:\n            v_plus = getattr(model, enzyme_var_id) * k_cat\n\n        # \u03ba (for solver stability, with a minimal value of 0.0001)\n        if has_kappa and with_kappa:\n            model, kappa_substrates_var_id, kappa_products_var_id = (\n                _add_kappa_substrates_and_products_vars(\n                    model,\n                    reac_id,\n                    reaction,\n                    cobrak_model,\n                    strict_kappa_products_equality=strict_mode\n                    or reac_id in single_strict_reacs,\n                    add_error_term=correction_config.add_km_error_term,\n                    max_rel_km_correction=correction_config.max_rel_km_correction,\n                    kms_lowbound=kms_lowbound,\n                    kms_highbound=kms_highbound,\n                )\n            )\n\n            kappa_var_id = f\"{KAPPA_VAR_PREFIX}{reac_id}\"\n            setattr(\n                model,\n                kappa_var_id,\n                Var(within=Reals, bounds=(approximation_value, 1.0)),\n            )\n            kappa_rhs = approximation_value + exp(\n                getattr(model, kappa_substrates_var_id)\n            ) / (\n                1\n                + exp(getattr(model, kappa_substrates_var_id))\n                + exp(getattr(model, kappa_products_var_id))\n            )\n            if strict_mode or reac_id in single_strict_reacs:\n                kappa_constraint = getattr(model, kappa_var_id) == kappa_rhs\n            else:\n                kappa_constraint = getattr(model, kappa_var_id) &lt;= kappa_rhs\n            setattr(\n                model, f\"kappa_constraint_{reac_id}\", Constraint(rule=kappa_constraint)\n            )\n\n        # \u03b3 (for solver stability, with a minimal value of 0.0001)\n        if has_gamma and with_gamma:\n            gamma_var_name = f\"{GAMMA_VAR_PREFIX}{reac_id}\"\n\n            min_gamma_value = (\n                approximation_value if irreversible_mode else -float(\"inf\")\n            )\n            setattr(\n                model,\n                gamma_var_name,\n                Var(within=Reals, bounds=(min_gamma_value, 1.0)),\n            )\n            f_by_RT = getattr(model, f_var_name) / (cobrak_model.R * cobrak_model.T)\n\n            if irreversible_mode:\n                gamma_rhs = approximation_value + (1 - exp(-f_by_RT))\n            else:\n                gamma_rhs = (\n                    approximation_value\n                    + (\n                        1\n                        - exp(\n                            -f_by_RT\n                        )  # * getattr(model, f\"{Z_VAR_PREFIX}{reac_id_to_reac_couple_id[reac_id]}\")\n                    )\n                )  # (f_by_RT**2) / (1 + (f_by_RT**2)) would be a rough approximation\n\n            if strict_mode or reac_id in single_strict_reacs:\n                gamma_var_constraint_0 = getattr(model, gamma_var_name) == gamma_rhs\n            else:\n                gamma_var_constraint_0 = getattr(model, gamma_var_name) &lt;= gamma_rhs\n            setattr(\n                model,\n                f\"gamma_var_constraint_{reac_id}_0\",\n                Constraint(rule=gamma_var_constraint_0),\n            )\n\n        # \u03b9 (for solver stability, with a minimal value of 0.0001)\n        if with_iota and has_iota:\n            iota_product = 1.0\n            for met_id, k_i in reaction.enzyme_reaction_data.k_is.items():\n                if met_id in cobrak_model.kinetic_ignored_metabolites:\n                    continue\n                var_id = f\"{LNCONC_VAR_PREFIX}{met_id}\"\n                if var_id not in model_var_names:\n                    continue\n                stoichiometry = abs(\n                    reaction.stoichiometries.get(met_id, 1.0)\n                ) * reaction.enzyme_reaction_data.hill_coefficients.iota.get(\n                    met_id, 1.0\n                )\n                term_without_error = True\n                if (\n                    correction_config.add_ki_error_term\n                ):  # Error term to make k_I *higher*\n                    all_kis = get_model_kis(cobrak_model)\n                    if (\n                        k_i\n                        &lt; all_kis[\n                            : ceil(correction_config.ki_error_cutoff * len(all_kis))\n                        ][-1]\n                    ):\n                        term_without_error = False\n                        ki_error_var = setattr(\n                            model,\n                            f\"{ERROR_VAR_PREFIX}____{reac_id}____{met_id}____iota\",\n                            Var(\n                                within=Reals,\n                                bounds=(\n                                    0.0,\n                                    log(correction_config.max_rel_ki_correction * k_i),\n                                ),\n                            ),\n                        )\n                        iota_product *= 1 / (\n                            1\n                            + exp(\n                                stoichiometry * getattr(model, var_id)\n                                - stoichiometry * log(k_i)\n                                + stoichiometry * getattr(model, ki_error_var)\n                            )\n                        )\n                if term_without_error:\n                    iota_product *= 1 / (\n                        1\n                        + exp(\n                            stoichiometry * getattr(model, var_id)\n                            - stoichiometry * log(k_i)\n                        )\n                    )\n            iota_var_name = f\"{IOTA_VAR_PREFIX}{reac_id}\"\n            setattr(\n                model,\n                iota_var_name,\n                Var(within=Reals, bounds=(approximation_value, 1.0)),\n            )\n            if strict_mode or reac_id in single_strict_reacs:\n                iota_var_constraint_0 = (\n                    getattr(model, iota_var_name) == approximation_value + iota_product\n                )\n            else:\n                iota_var_constraint_0 = (\n                    getattr(model, iota_var_name) &lt;= approximation_value + iota_product\n                )\n            setattr(\n                model,\n                f\"iota_var_constraint_{reac_id}_0\",\n                Constraint(rule=iota_var_constraint_0),\n            )\n\n        if with_alpha and has_alpha:\n            alpha_product = 1.0\n            for met_id, k_a in reaction.enzyme_reaction_data.k_as.items():\n                if met_id in cobrak_model.kinetic_ignored_metabolites:\n                    continue\n                var_id = f\"{LNCONC_VAR_PREFIX}{met_id}\"\n                if var_id not in model_var_names:\n                    continue\n                stoichiometry = abs(\n                    reaction.stoichiometries.get(met_id, 1.0)\n                ) * reaction.enzyme_reaction_data.hill_coefficients.alpha.get(\n                    met_id, 1.0\n                )\n\n                term_without_error = True\n                if (\n                    correction_config.add_ki_error_term\n                ):  # Error term to make k_A *lower*\n                    all_kas = get_model_kas(cobrak_model)\n                    if (\n                        k_a\n                        &gt; all_kas[\n                            floor(\n                                (1 - correction_config.ka_error_cutoff) * len(all_kas)\n                            ) :\n                        ][0]\n                    ):\n                        term_without_error = False\n                        ka_error_var = setattr(\n                            model,\n                            f\"{ERROR_VAR_PREFIX}____{reac_id}____{met_id}____alpha\",\n                            Var(\n                                within=Reals,\n                                bounds=(\n                                    0.0,\n                                    log(correction_config.max_rel_ki_correction * k_i),\n                                ),\n                            ),\n                        )\n                        iota_product *= 1 / (\n                            1\n                            + exp(\n                                stoichiometry * log(k_a)\n                                - stoichiometry * getattr(model, var_id)\n                                - stoichiometry * getattr(model, ka_error_var)\n                            )\n                        )\n                if term_without_error:\n                    alpha_product *= 1 / (\n                        1\n                        + exp(\n                            stoichiometry * log(k_a)\n                            - stoichiometry * getattr(model, var_id)\n                        )\n                    )\n\n            alpha_var_name = f\"{ALPHA_VAR_PREFIX}{reac_id}\"\n            setattr(\n                model,\n                alpha_var_name,\n                Var(within=Reals, bounds=(approximation_value, 1.0)),\n            )\n\n            if strict_mode or reac_id in single_strict_reacs:\n                alpha_var_constraint_0 = (\n                    getattr(model, alpha_var_name)\n                    == approximation_value + alpha_product\n                )\n            else:\n                alpha_var_constraint_0 = (\n                    getattr(model, alpha_var_name)\n                    &lt;= approximation_value + alpha_product\n                )\n            setattr(\n                model,\n                f\"alpha_var_constraint_{reac_id}_0\",\n                Constraint(rule=alpha_var_constraint_0),\n            )\n\n        # Build kinetic term for reaction according to included parts\n        kinetic_rhs = v_plus\n        if has_kappa and with_kappa:\n            kinetic_rhs *= getattr(model, kappa_var_id)\n        if has_gamma and with_gamma:\n            kinetic_rhs *= getattr(model, gamma_var_name)\n        if has_iota and with_iota:\n            kinetic_rhs *= getattr(model, iota_var_name)\n        if has_alpha and with_alpha:\n            kinetic_rhs *= getattr(model, alpha_var_name)\n\n        # Apply strict mode\n        if strict_mode or reac_id in single_strict_reacs:\n            setattr(\n                model,\n                f\"full_reac_constraint_{reac_id}\",\n                Constraint(rule=getattr(model, reac_id) == kinetic_rhs),\n            )\n        else:\n            setattr(\n                model,\n                f\"full_reac_constraint_{reac_id}\",\n                Constraint(rule=getattr(model, reac_id) &lt;= kinetic_rhs),\n            )\n\n    model = _add_extra_watches_and_constraints_to_lp(\n        model, cobrak_model, ignore_nonlinear_terms=False\n    )\n    if is_any_error_term_active(correction_config):\n        if correction_config.error_scenario != {}:\n            _apply_error_scenario(\n                model,\n                cobrak_model,\n                correction_config,\n            )\n        if correction_config.add_error_sum_term:\n            model = _add_error_sum_to_model(\n                model,\n                cobrak_model,\n                correction_config,\n            )\n\n    ########################\n    if cobrak_model.max_conc_sum &lt; float(\"inf\"):\n        met_sum_ids: list[str] = []\n        for var_id in get_model_var_names(model):\n            if not var_id.startswith(LNCONC_VAR_PREFIX):\n                continue\n            if not any(\n                var_id.endswith(suffix)\n                for suffix in cobrak_model.conc_sum_include_suffixes\n            ):\n                continue\n            if any(\n                var_id.replace(LNCONC_VAR_PREFIX, \"\").startswith(prefix)\n                for prefix in cobrak_model.conc_sum_ignore_prefixes\n            ):\n                continue\n            met_sum_ids.append(var_id)\n\n        conc_sum_expr = 0.0\n        for met_sum_id in met_sum_ids:\n            met_id = met_sum_id[len(LNCONC_VAR_PREFIX) :]\n            # exp_var_id = f\"expvar_{met_sum_id}\"\n            # setattr(model, exp_var_id, Var(within=Reals, bounds=(1e-5, 1e6)),)\n            # setattr(\n            #     model,\n            #     f\"expvarconstraint_{met_sum_id}\",\n            #     Constraint(rule=getattr(model, exp_var_id) &gt;= getattr(model, met_sum_id)),\n            # )\n            conc_sum_expr += exp(getattr(model, met_sum_id))\n        setattr(\n            model,\n            \"met_sum_var\",\n            Var(within=Reals, bounds=(1e-5, cobrak_model.max_conc_sum)),\n        )\n        setattr(\n            model,\n            \"met_sum_constraint\",\n            Constraint(rule=conc_sum_expr &lt;= getattr(model, \"met_sum_var\")),\n        )\n    ################\n\n    return model\n</code></pre>"},{"location":"api.html#cobrak.nlps.perform_nlp_irreversible_optimization","title":"<code>perform_nlp_irreversible_optimization(cobrak_model, objective_target, objective_sense, variability_dict, with_kappa=True, with_gamma=True, with_iota=False, with_alpha=False, approximation_value=0.0001, verbose=False, strict_mode=False, single_strict_reacs=[], min_mdf=STANDARD_MIN_MDF, solver=IPOPT, min_flux=0.0, with_flux_sum_var=False, correction_config=CorrectionConfig(), var_data_abs_epsilon=1e-05)</code>","text":"<p>Performs an irreversible non-linear program (NLP) optimization on a COBRAk model.</p> <p>For more about the NLP, see the COBRAk documentation's NLP chapter.</p>"},{"location":"api.html#cobrak.nlps.perform_nlp_irreversible_optimization--parameters","title":"Parameters","text":"<ul> <li><code>cobrak_model</code> (<code>Model</code>): The COBRAk model to optimize.</li> <li><code>objective_target</code> (<code>str | dict[str, float]</code>): The objective target (reaction ID or dictionary of reaction IDs and coefficients).</li> <li><code>objective_sense</code> (<code>int</code>): The objective sense (1 for maximization, -1 for minimization).</li> <li><code>variability_dict</code> (<code>dict[str, tuple[float, float]]</code>): Dictionary of reaction IDs and their variability (lower and upper bounds).</li> <li><code>with_kappa</code> (<code>bool</code>, optional): Whether to include \u03ba saturation terms. Defaults to <code>True</code>.</li> <li><code>with_gamma</code> (<code>bool</code>, optional): Whether to include \u03b3 thermodynamic terms. Defaults to <code>True</code>.</li> <li><code>with_iota</code> (<code>bool</code>, optional): Whether to include \u03b9 inhibition terms. Defaults to <code>False</code> and untested!</li> <li><code>with_alpha</code> (<code>bool</code>, optional): Whether to include \u03b1 activation terms. Defaults to <code>False</code> and untested!</li> <li><code>approximation_value</code> (<code>float</code>, optional): Approximation value for \u03ba, \u03b3, \u03b9, and \u03b1 terms. Defaults to <code>0.0001</code>. This value is the    minimal value for \u03ba, \u03b3, \u03b9, and \u03b1 terms, and can lead to an overapproximation in this regard.</li> <li><code>verbose</code> (<code>bool</code>, optional): Whether to print solver output. Defaults to <code>False</code>.</li> <li><code>strict_mode</code> (<code>bool</code>, optional): Whether to use strict mode (i.e. all &lt;= heuristics become == relations). Defaults to <code>False</code>.</li> <li><code>single_strict_reacs</code> (<code>list[str]</code>, optional): If 'strict_mode==False', only reactions with an ID in this list are set to strict mode.</li> <li><code>min_mdf</code> (<code>float</code>, optional): Minimum MDF value. Defaults to <code>STANDARD_MIN_MDF</code>.</li> <li><code>solver_name</code> (Solver, optional): Used NLP solver. Defaults to IPOPT.</li> <li><code>min_flux</code> (<code>float</code>, optional): Minimum flux value. Defaults to <code>0.0</code>.</li> <li><code>with_flux_sum_var</code> (<code>bool</code>, optional): Whether to include a reaction flux sum variable of name <code>cobrak.constants.FLUX_SUM_VAR</code>. Defaults to <code>False</code>.</li> <li><code>correction_config</code> (<code>CorrectionConfig</code>, optional): Parameter correction configuration. Defaults to <code>CorrectionConfig()</code>.</li> <li>var_data_abs_epsilon: (<code>float</code>, optional): Under this value, any data given by the variability dict is considered to be 0. Defaults to 1e-5.</li> </ul>"},{"location":"api.html#cobrak.nlps.perform_nlp_irreversible_optimization--returns","title":"Returns","text":"<ul> <li><code>dict[str, float]</code>: The optimization results.</li> </ul> Source code in <code>cobrak/nlps.py</code> <pre><code>@validate_call(config=ConfigDict(arbitrary_types_allowed=True))\ndef perform_nlp_irreversible_optimization(\n    cobrak_model: Model,\n    objective_target: str | dict[str, float],\n    objective_sense: int,\n    variability_dict: dict[str, tuple[float, float]],\n    with_kappa: bool = True,\n    with_gamma: bool = True,\n    with_iota: bool = False,\n    with_alpha: bool = False,\n    approximation_value: NonNegativeFloat = 0.0001,\n    verbose: bool = False,\n    strict_mode: bool = False,\n    single_strict_reacs: list[str] = [],\n    min_mdf: float = STANDARD_MIN_MDF,\n    solver: Solver = IPOPT,\n    min_flux: NonNegativeFloat = 0.0,\n    with_flux_sum_var: bool = False,\n    correction_config: CorrectionConfig = CorrectionConfig(),\n    var_data_abs_epsilon: float = 1e-5,\n) -&gt; dict[str, float]:\n    \"\"\"Performs an irreversible non-linear program (NLP) optimization on a COBRAk model.\n\n    For more about the NLP, see the COBRAk documentation's NLP chapter.\n\n    # Parameters\n    * `cobrak_model` (`Model`): The COBRAk model to optimize.\n    * `objective_target` (`str | dict[str, float]`): The objective target (reaction ID or dictionary of reaction IDs and coefficients).\n    * `objective_sense` (`int`): The objective sense (1 for maximization, -1 for minimization).\n    * `variability_dict` (`dict[str, tuple[float, float]]`): Dictionary of reaction IDs and their variability (lower and upper bounds).\n    * `with_kappa` (`bool`, optional): Whether to include \u03ba saturation terms. Defaults to `True`.\n    * `with_gamma` (`bool`, optional): Whether to include \u03b3 thermodynamic terms. Defaults to `True`.\n    * `with_iota` (`bool`, optional): Whether to include \u03b9 inhibition terms. Defaults to `False` and untested!\n    * `with_alpha` (`bool`, optional): Whether to include \u03b1 activation terms. Defaults to `False` and untested!\n    * `approximation_value` (`float`, optional): Approximation value for \u03ba, \u03b3, \u03b9, and \u03b1 terms. Defaults to `0.0001`. This value is the\n       minimal value for \u03ba, \u03b3, \u03b9, and \u03b1 terms, and can lead to an overapproximation in this regard.\n    * `verbose` (`bool`, optional): Whether to print solver output. Defaults to `False`.\n    * `strict_mode` (`bool`, optional): Whether to use strict mode (i.e. all &lt;= heuristics become == relations). Defaults to `False`.\n    * `single_strict_reacs` (`list[str]`, optional): If 'strict_mode==False', only reactions with an ID in this list are set to strict mode.\n    * `min_mdf` (`float`, optional): Minimum MDF value. Defaults to `STANDARD_MIN_MDF`.\n    * `solver_name` (Solver, optional): Used NLP solver. Defaults to IPOPT.\n    * `min_flux` (`float`, optional): Minimum flux value. Defaults to `0.0`.\n    * `with_flux_sum_var` (`bool`, optional): Whether to include a reaction flux sum variable of name ```cobrak.constants.FLUX_SUM_VAR```. Defaults to `False`.\n    * `correction_config` (`CorrectionConfig`, optional): Parameter correction configuration. Defaults to `CorrectionConfig()`.\n    *  var_data_abs_epsilon: (`float`, optional): Under this value, any data given by the variability dict is considered to be 0. Defaults to 1e-5.\n\n    # Returns\n    * `dict[str, float]`: The optimization results.\n    \"\"\"\n    nlp_model = get_nlp_from_cobrak_model(\n        cobrak_model,\n        with_kappa=with_kappa,\n        with_gamma=with_gamma,\n        with_iota=with_iota,\n        with_alpha=with_alpha,\n        approximation_value=approximation_value,\n        irreversible_mode=True,\n        variability_data=variability_dict,\n        strict_mode=strict_mode,\n        single_strict_reacs=single_strict_reacs,\n        irreversible_mode_min_mdf=min_mdf,\n        with_flux_sum_var=with_flux_sum_var,\n        correction_config=correction_config,\n    )\n    variability_dict = deepcopy(variability_dict)\n    if min_flux != 0.0:\n        for reac_id in cobrak_model.reactions:\n            if (reac_id in variability_dict) and (\n                (variability_dict[reac_id][0] == 0.0)\n                and (variability_dict[reac_id][1] &gt;= min_flux)\n            ):\n                variability_dict[reac_id] = (min_flux, variability_dict[reac_id][1])\n\n    nlp_model = apply_variability_dict(\n        nlp_model,\n        cobrak_model,\n        variability_dict,\n        correction_config.error_scenario,\n        var_data_abs_epsilon,\n    )\n    nlp_model.obj = get_objective(nlp_model, objective_target, objective_sense)\n    pyomo_solver = get_solver(solver.name, solver.solver_options, solver.solver_attrs)\n    results = pyomo_solver.solve(nlp_model, tee=verbose, **solver.solve_extra_options)\n    mmtfba_dict = get_pyomo_solution_as_dict(nlp_model)\n    return add_statuses_to_optimziation_dict(mmtfba_dict, results)\n</code></pre>"},{"location":"api.html#cobrak.nlps.perform_nlp_irreversible_optimization_with_active_reacs_only","title":"<code>perform_nlp_irreversible_optimization_with_active_reacs_only(cobrak_model, objective_target, objective_sense, optimization_dict, variability_dict, with_kappa=True, with_gamma=True, with_iota=False, with_alpha=False, approximation_value=0.0001, verbose=False, strict_mode=False, single_strict_reacs=[], min_mdf=STANDARD_MIN_MDF, solver=IPOPT, do_not_delete_with_z_var_one=False, correction_config=CorrectionConfig(), var_data_abs_epsilon=1e-05)</code>","text":"<p>Performs an irreversible non-linear program (NLP) optimization on a COBRAk model, considering only active reactions of the optimization dict.</p> <p>For more about the NLP, see the COBRAk documentation's NLP chapter.</p>"},{"location":"api.html#cobrak.nlps.perform_nlp_irreversible_optimization_with_active_reacs_only--parameters","title":"Parameters","text":"<ul> <li><code>cobrak_model</code> (<code>Model</code>): The COBRAk model to optimize.</li> <li><code>objective_target</code> (<code>str | dict[str, float]</code>): The objective target (reaction ID or dictionary of reaction IDs and coefficients).</li> <li><code>objective_sense</code> (<code>int</code>): The objective sense (1 for maximization, -1 for minimization).</li> <li><code>optimization_dict</code> (<code>dict[str, float]</code>): Dictionary of reaction IDs and their optimization values.</li> <li><code>variability_dict</code> (<code>dict[str, tuple[float, float]]</code>): Dictionary of reaction IDs and their variability (lower and upper bounds).</li> <li><code>with_kappa</code> (<code>bool</code>, optional): Whether to include \u03ba terms. Defaults to <code>True</code>.</li> <li><code>with_gamma</code> (<code>bool</code>, optional): Whether to include \u03b3 terms. Defaults to <code>True</code>.</li> <li><code>with_iota</code> (<code>bool</code>, optional): Whether to include \u03b9 inhibition terms. Defaults to <code>False</code> and untested!</li> <li><code>with_alpha</code> (<code>bool</code>, optional): Whether to include \u03b1 activation terms. Defaults to <code>False</code> and untested!</li> <li><code>approximation_value</code> (<code>float</code>, optional): Approximation value for \u03ba, \u03b3, \u03b9, and \u03b1 terms. Defaults to <code>0.0001</code>. This value is the    minimal value for \u03ba, \u03b3, \u03b9, and \u03b1 terms, and can lead to an overapproximation in this regard.</li> <li><code>verbose</code> (<code>bool</code>, optional): Whether to print solver output. Defaults to <code>False</code>.</li> <li><code>strict_mode</code> (<code>bool</code>, optional): Whether to use strict mode (i.e. all &lt;= heuristics become == relations). Defaults to <code>False</code>.</li> <li><code>single_strict_reacs</code> (<code>list[str]</code>, optional): If 'strict_mode==False', only reactions with an ID in this list are set to strict mode.</li> <li><code>min_mdf</code> (<code>float</code>, optional): Minimum MDF value. Defaults to <code>STANDARD_MIN_MDF</code>.</li> <li><code>solver</code> (Solver, optional): Used NLP solver. Defaults to IPOPT.</li> <li><code>do_not_delete_with_z_var_one</code> (<code>bool</code>, optional): Whether to delete reactions with associated Z variables (in the optimization dics) equal to one.   Defaults to <code>False</code>.</li> <li><code>correction_config</code> (<code>CorrectionConfig</code>, optional): Paramter correction configuration. Defaults to <code>CorrectionConfig()</code>.</li> <li>var_data_abs_epsilon: (<code>float</code>, optional): Under this value, any data given by the variability dict is considered to be 0. Defaults to 1e-5.</li> </ul>"},{"location":"api.html#cobrak.nlps.perform_nlp_irreversible_optimization_with_active_reacs_only--returns","title":"Returns","text":"<ul> <li><code>dict[str, float]</code>: The optimization results.</li> </ul> Source code in <code>cobrak/nlps.py</code> <pre><code>@validate_call(config=ConfigDict(arbitrary_types_allowed=True))\ndef perform_nlp_irreversible_optimization_with_active_reacs_only(\n    cobrak_model: Model,\n    objective_target: str | dict[str, float],\n    objective_sense: int,\n    optimization_dict: dict[str, float],\n    variability_dict: dict[str, tuple[float, float]],\n    with_kappa: bool = True,\n    with_gamma: bool = True,\n    with_iota: bool = False,\n    with_alpha: bool = False,\n    approximation_value: float = 0.0001,\n    verbose: bool = False,\n    strict_mode: bool = False,\n    single_strict_reacs: list[str] = [],\n    min_mdf: float = STANDARD_MIN_MDF,\n    solver: Solver = IPOPT,\n    do_not_delete_with_z_var_one: bool = False,\n    correction_config: CorrectionConfig = CorrectionConfig(),\n    var_data_abs_epsilon: float = 1e-5,\n) -&gt; dict[str, float]:\n    \"\"\"Performs an irreversible non-linear program (NLP) optimization on a COBRAk model, considering only active reactions of the optimization dict.\n\n    For more about the NLP, see the COBRAk documentation's NLP chapter.\n\n    # Parameters\n    * `cobrak_model` (`Model`): The COBRAk model to optimize.\n    * `objective_target` (`str | dict[str, float]`): The objective target (reaction ID or dictionary of reaction IDs and coefficients).\n    * `objective_sense` (`int`): The objective sense (1 for maximization, -1 for minimization).\n    * `optimization_dict` (`dict[str, float]`): Dictionary of reaction IDs and their optimization values.\n    * `variability_dict` (`dict[str, tuple[float, float]]`): Dictionary of reaction IDs and their variability (lower and upper bounds).\n    * `with_kappa` (`bool`, optional): Whether to include \u03ba terms. Defaults to `True`.\n    * `with_gamma` (`bool`, optional): Whether to include \u03b3 terms. Defaults to `True`.\n    * `with_iota` (`bool`, optional): Whether to include \u03b9 inhibition terms. Defaults to `False` and untested!\n    * `with_alpha` (`bool`, optional): Whether to include \u03b1 activation terms. Defaults to `False` and untested!\n    * `approximation_value` (`float`, optional): Approximation value for \u03ba, \u03b3, \u03b9, and \u03b1 terms. Defaults to `0.0001`. This value is the\n       minimal value for \u03ba, \u03b3, \u03b9, and \u03b1 terms, and can lead to an overapproximation in this regard.\n    * `verbose` (`bool`, optional): Whether to print solver output. Defaults to `False`.\n    * `strict_mode` (`bool`, optional): Whether to use strict mode (i.e. all &lt;= heuristics become == relations). Defaults to `False`.\n    * `single_strict_reacs` (`list[str]`, optional): If 'strict_mode==False', only reactions with an ID in this list are set to strict mode.\n    * `min_mdf` (`float`, optional): Minimum MDF value. Defaults to `STANDARD_MIN_MDF`.\n    * `solver` (Solver, optional): Used NLP solver. Defaults to IPOPT.\n    * `do_not_delete_with_z_var_one` (`bool`, optional): Whether to delete reactions with associated Z variables (in the optimization dics) equal to one.\n      Defaults to `False`.\n    * `correction_config` (`CorrectionConfig`, optional): Paramter correction configuration. Defaults to `CorrectionConfig()`.\n    *  var_data_abs_epsilon: (`float`, optional): Under this value, any data given by the variability dict is considered to be 0. Defaults to 1e-5.\n\n    # Returns\n    * `dict[str, float]`: The optimization results.\n    \"\"\"\n    optimization_dict = deepcopy(optimization_dict)\n    for single_strict_reac in single_strict_reacs:\n        optimization_dict[single_strict_reac] = 1.0\n    nlp_cobrak_model = delete_unused_reactions_in_optimization_dict(\n        cobrak_model=cobrak_model,\n        optimization_dict=optimization_dict,\n        do_not_delete_with_z_var_one=do_not_delete_with_z_var_one,\n    )\n    return perform_nlp_irreversible_optimization(\n        cobrak_model=nlp_cobrak_model,\n        objective_target=objective_target,\n        objective_sense=objective_sense,\n        variability_dict=variability_dict,\n        with_kappa=with_kappa,\n        with_gamma=with_gamma,\n        with_iota=with_iota,\n        with_alpha=with_alpha,\n        approximation_value=approximation_value,\n        verbose=verbose,\n        strict_mode=strict_mode,\n        single_strict_reacs=single_strict_reacs,\n        min_mdf=min_mdf,\n        solver=solver,\n        correction_config=correction_config,\n        var_data_abs_epsilon=var_data_abs_epsilon,\n    )\n</code></pre>"},{"location":"api.html#cobrak.nlps.perform_nlp_irreversible_variability_analysis_with_active_reacs_only","title":"<code>perform_nlp_irreversible_variability_analysis_with_active_reacs_only(cobrak_model, optimization_dict, tfba_variability_dict, with_kappa=True, with_gamma=True, with_iota=False, with_alpha=False, active_reactions=[], min_active_flux=1e-05, calculate_reacs=True, calculate_concs=True, calculate_rest=True, extra_tested_vars_max=[], extra_tested_vars_min=[], strict_mode=False, single_strict_reacs=[], min_mdf=STANDARD_MIN_MDF, min_flux_cutoff=1e-08, solver=IPOPT, do_not_delete_with_z_var_one=False, parallel_verbosity_level=0, approximation_value=0.0001)</code>","text":"<p>Performs an irreversible non-linear program (NLP) variability analysis on a COBRAk model, considering only active reactions.</p> <p>This function calculates the minimum and maximum values of reaction fluxes, metabolite concentrations, and other variables in the model, given a set of active reactions and a variability dictionary. It uses a combination of NLP optimizations and parallel processing to efficiently compute the variability of the model.</p>"},{"location":"api.html#cobrak.nlps.perform_nlp_irreversible_variability_analysis_with_active_reacs_only--parameters","title":"Parameters","text":"<ul> <li><code>cobrak_model</code> (<code>Model</code>): The COBRAk model to analyze.</li> <li><code>optimization_dict</code> (<code>dict[str, float]</code>): Dictionary of reaction IDs and their optimization values.</li> <li><code>tfba_variability_dict</code> (<code>dict[str, tuple[float, float]]</code>): Dictionary of reaction IDs and their TFBA variability (lower and upper bounds).</li> <li><code>with_kappa</code> (<code>bool</code>, optional): Whether to include \u03ba saturation terms. Defaults to <code>True</code>.</li> <li><code>with_gamma</code> (<code>bool</code>, optional): Whether to include \u03b3 thermodynamic terms. Defaults to <code>True</code>.</li> <li><code>with_iota</code> (<code>bool</code>, optional): Whether to include \u03b9 inhibition terms. Defaults to <code>False</code> and untested!</li> <li><code>with_alpha</code> (<code>bool</code>, optional): Whether to include \u03b1 activation terms. Defaults to <code>False</code> and untested!</li> <li><code>active_reactions</code> (<code>list[str]</code>, optional): List of active reaction IDs. Defaults to <code>[]</code>.</li> <li><code>min_active_flux</code> (<code>float</code>, optional): Minimum flux value for active reactions. Defaults to <code>1e-5</code>.</li> <li><code>calculate_reacs</code> (<code>bool</code>, optional): Whether to calculate reaction flux variability. Defaults to <code>True</code>.</li> <li><code>calculate_concs</code> (<code>bool</code>, optional): Whether to calculate metabolite concentration variability. Defaults to <code>True</code>.</li> <li><code>calculate_rest</code> (<code>bool</code>, optional): Whether to calculate variability of other variables (e.g., enzyme delivery, \u03ba, \u03b3). Defaults to <code>True</code>.</li> <li><code>strict_mode</code> (<code>bool</code>, optional): Whether to use strict mode (i.e. all &lt;= heuristics become == relations). Defaults to <code>False</code>.</li> <li><code>single_strict_reacs</code> (<code>list[str]</code>, optional): If 'strict_mode==False', only reactions with an ID in this list are set to strict mode.</li> <li><code>min_mdf</code> (<code>float</code>, optional): Minimum MDF value. Defaults to <code>STANDARD_MIN_MDF</code>.</li> <li><code>min_flux_cutoff</code> (<code>float</code>, optional): Minimum flux cutoff value. Defaults to <code>1e-8</code>.</li> <li><code>solver</code> (Solver, optional): Used NLP solver. Defaults to IPOPT.</li> <li><code>do_not_delete_with_z_var_one</code> (<code>bool</code>, optional): Whether to delete reactions with Z variable equal to one. Defaults to <code>False</code>.</li> <li><code>parallel_verbosity_level</code> (<code>int</code>, optional): Verbosity level for parallel processing. Defaults to <code>0</code>.</li> <li><code>approximation_value</code> (<code>float</code>, optional): Approximation value for \u03ba, \u03b3, \u03b9, and \u03b1 terms. Defaults to <code>0.0001</code>. This value is the    minimal value for \u03ba, \u03b3, \u03b9, and \u03b1 terms, and can lead to an overapproximation in this regard.</li> </ul>"},{"location":"api.html#cobrak.nlps.perform_nlp_irreversible_variability_analysis_with_active_reacs_only--returns","title":"Returns","text":"<ul> <li><code>dict[str, tuple[float, float]]</code>: A dictionary of variable IDs and their variability (lower and upper bounds).</li> </ul> Source code in <code>cobrak/nlps.py</code> <pre><code>@validate_call(config=ConfigDict(arbitrary_types_allowed=True))\ndef perform_nlp_irreversible_variability_analysis_with_active_reacs_only(\n    cobrak_model: Model,\n    optimization_dict: dict[str, float],\n    tfba_variability_dict: dict[str, tuple[float, float]],\n    with_kappa: bool = True,\n    with_gamma: bool = True,\n    with_iota: bool = False,\n    with_alpha: bool = False,\n    active_reactions: list[str] = [],\n    min_active_flux: float = 1e-5,\n    calculate_reacs: bool = True,\n    calculate_concs: bool = True,\n    calculate_rest: bool = True,\n    extra_tested_vars_max: list[str] = [],\n    extra_tested_vars_min: list[str] = [],\n    strict_mode: bool = False,\n    single_strict_reacs: list[str] = [],\n    min_mdf: float = STANDARD_MIN_MDF,\n    min_flux_cutoff: float = 1e-8,\n    solver: Solver = IPOPT,\n    do_not_delete_with_z_var_one: bool = False,\n    parallel_verbosity_level: int = 0,\n    approximation_value: float = 0.0001,\n) -&gt; dict[str, tuple[float, float]]:\n    \"\"\"Performs an irreversible non-linear program (NLP) variability analysis on a COBRAk model, considering only active reactions.\n\n    This function calculates the minimum and maximum values of reaction fluxes, metabolite concentrations, and other variables in the model,\n    given a set of active reactions and a variability dictionary.\n    It uses a combination of NLP optimizations and parallel processing to efficiently compute the variability of the model.\n\n    # Parameters\n    * `cobrak_model` (`Model`): The COBRAk model to analyze.\n    * `optimization_dict` (`dict[str, float]`): Dictionary of reaction IDs and their optimization values.\n    * `tfba_variability_dict` (`dict[str, tuple[float, float]]`): Dictionary of reaction IDs and their TFBA variability (lower and upper bounds).\n    * `with_kappa` (`bool`, optional): Whether to include \u03ba saturation terms. Defaults to `True`.\n    * `with_gamma` (`bool`, optional): Whether to include \u03b3 thermodynamic terms. Defaults to `True`.\n    * `with_iota` (`bool`, optional): Whether to include \u03b9 inhibition terms. Defaults to `False` and untested!\n    * `with_alpha` (`bool`, optional): Whether to include \u03b1 activation terms. Defaults to `False` and untested!\n    * `active_reactions` (`list[str]`, optional): List of active reaction IDs. Defaults to `[]`.\n    * `min_active_flux` (`float`, optional): Minimum flux value for active reactions. Defaults to `1e-5`.\n    * `calculate_reacs` (`bool`, optional): Whether to calculate reaction flux variability. Defaults to `True`.\n    * `calculate_concs` (`bool`, optional): Whether to calculate metabolite concentration variability. Defaults to `True`.\n    * `calculate_rest` (`bool`, optional): Whether to calculate variability of other variables (e.g., enzyme delivery, \u03ba, \u03b3). Defaults to `True`.\n    * `strict_mode` (`bool`, optional): Whether to use strict mode (i.e. all &lt;= heuristics become == relations). Defaults to `False`.\n    * `single_strict_reacs` (`list[str]`, optional): If 'strict_mode==False', only reactions with an ID in this list are set to strict mode.\n    * `min_mdf` (`float`, optional): Minimum MDF value. Defaults to `STANDARD_MIN_MDF`.\n    * `min_flux_cutoff` (`float`, optional): Minimum flux cutoff value. Defaults to `1e-8`.\n    * `solver` (Solver, optional): Used NLP solver. Defaults to IPOPT.\n    * `do_not_delete_with_z_var_one` (`bool`, optional): Whether to delete reactions with Z variable equal to one. Defaults to `False`.\n    * `parallel_verbosity_level` (`int`, optional): Verbosity level for parallel processing. Defaults to `0`.\n    * `approximation_value` (`float`, optional): Approximation value for \u03ba, \u03b3, \u03b9, and \u03b1 terms. Defaults to `0.0001`. This value is the\n       minimal value for \u03ba, \u03b3, \u03b9, and \u03b1 terms, and can lead to an overapproximation in this regard.\n\n    # Returns\n    * `dict[str, tuple[float, float]]`: A dictionary of variable IDs and their variability (lower and upper bounds).\n    \"\"\"\n    cobrak_model = deepcopy(cobrak_model)\n    cobrak_model = delete_unused_reactions_in_optimization_dict(\n        cobrak_model=cobrak_model,\n        optimization_dict=optimization_dict,\n        do_not_delete_with_z_var_one=do_not_delete_with_z_var_one,\n    )\n\n    for active_reaction in active_reactions:\n        cobrak_model.reactions[active_reaction].min_flux = min_active_flux\n\n    model: ConcreteModel = get_nlp_from_cobrak_model(\n        cobrak_model=deepcopy(cobrak_model),\n        with_kappa=with_kappa,\n        with_gamma=with_gamma,\n        with_iota=with_iota,\n        with_alpha=with_alpha,\n        approximation_value=approximation_value,\n        variability_data=deepcopy(tfba_variability_dict),\n        strict_mode=strict_mode,\n        irreversible_mode_min_mdf=min_mdf,\n    )\n    model_var_names = get_model_var_names(model)\n\n    min_values: dict[str, float] = {}\n    max_values: dict[str, float] = {}\n    objective_targets: list[tuple[int, str]] = []\n\n    \"\"\"\n    min_flux_sum_result = perform_nlp_irreversible_optimization(\n        deepcopy(cobrak_model),\n        objective_target=FLUX_SUM_VAR_ID,\n        objective_sense=-1,\n        with_kappa=with_kappa,\n        with_gamma=with_gamma,\n        with_iota=with_iota,\n        with_alpha=with_alpha,\n        approximation_value=approximation_value,\n        variability_dict=deepcopy(tfba_variability_dict),\n        strict_mode=strict_mode,\n        min_mdf=min_mdf,\n        with_flux_sum_var=True,\n        solver=solver,\n    )\n    \"\"\"\n\n    if calculate_concs or calculate_rest:\n        min_mdf_result = perform_nlp_irreversible_optimization(\n            deepcopy(cobrak_model),\n            objective_target=MDF_VAR_ID,\n            objective_sense=-1,\n            with_kappa=with_kappa,\n            with_gamma=with_gamma,\n            with_iota=with_iota,\n            with_alpha=with_alpha,\n            approximation_value=approximation_value,\n            variability_dict=deepcopy(tfba_variability_dict),\n            strict_mode=strict_mode,\n            solver=solver,\n        )\n\n    if calculate_concs:\n        for met_id, metabolite in cobrak_model.metabolites.items():\n            met_var_name = f\"{LNCONC_VAR_PREFIX}{met_id}\"\n            if met_var_name in model_var_names:\n                min_mdf_conc = min_mdf_result[met_var_name]\n                max_mdf_conc = min_mdf_result[met_var_name]\n                if metabolite.log_min_conc in (min_mdf_conc, max_mdf_conc):\n                    min_values[met_var_name] = metabolite.log_min_conc\n                else:\n                    objective_targets.append((-1, met_var_name))\n                if metabolite.log_max_conc in (min_mdf_conc, max_mdf_conc):\n                    max_values[met_var_name] = metabolite.log_max_conc\n                else:\n                    objective_targets.append((+1, met_var_name))\n\n    for reac_id, reaction in cobrak_model.reactions.items():\n        # min_flux_sum_flux = min_flux_sum_result[reac_id]\n        if calculate_reacs:\n            # if reaction.min_flux in (min_flux_sum_flux,):\n            #    min_values[reac_id] = (\n            #        reaction.min_flux if reaction.min_flux &gt;= min_flux_cutoff else 0.0\n            #    )\n            # else:\n            # if reaction.max_flux in (min_flux_sum_flux,):\n            #    max_values[reac_id] = reaction.max_flux\n            # else:\n            objective_targets.extend(((-1, reac_id), (+1, reac_id)))\n\n        if not calculate_rest:\n            continue\n\n        kappa_var_name = f\"{KAPPA_VAR_PREFIX}{reac_id}\"\n        gamma_var_name = f\"{GAMMA_VAR_PREFIX}{reac_id}\"\n        if kappa_var_name in model_var_names:\n            objective_targets.extend(((-1, kappa_var_name), (+1, kappa_var_name)))\n        if gamma_var_name in model_var_names:\n            objective_targets.extend(((-1, gamma_var_name), (+1, gamma_var_name)))\n        if reaction.enzyme_reaction_data is not None:\n            full_enzyme_id = get_full_enzyme_id(\n                reaction.enzyme_reaction_data.identifiers\n            )\n            if full_enzyme_id:\n                enzyme_delivery_var_name = get_reaction_enzyme_var_id(reac_id, reaction)\n                # if 0.0 in (min_flux_sum_flux,):\n                #    min_values[enzyme_delivery_var_name] = 0.0\n                # else:\n                objective_targets.extend(\n                    ((-1, enzyme_delivery_var_name), (+1, enzyme_delivery_var_name))\n                )\n\n    if len(extra_tested_vars_min) &gt; 0:\n        for extra_tested_var in extra_tested_vars_max:\n            if extra_tested_var in model_var_names:\n                objective_targets.append((-1, extra_tested_var))\n\n    if len(extra_tested_vars_max) &gt; 0:\n        for extra_tested_var in extra_tested_vars_max:\n            if extra_tested_var in model_var_names:\n                objective_targets.append((+1, extra_tested_var))\n\n    objectives_data: list[tuple[str, str]] = []\n    for obj_sense, target_id in objective_targets:\n        if obj_sense == -1:\n            objective_name = f\"MIN_OBJ_{target_id}\"\n            pyomo_sense = minimize\n        else:\n            objective_name = f\"MAX_OBJ_{target_id}\"\n            pyomo_sense = maximize\n        setattr(\n            model,\n            objective_name,\n            Objective(expr=getattr(model, target_id), sense=pyomo_sense),\n        )\n        getattr(model, objective_name).deactivate()\n        objectives_data.append((objective_name, target_id))\n\n    objectives_data_batches = split_list(\n        objectives_data, len(objectives_data)\n    )  # cpu_count())\n\n    results_list = Parallel(n_jobs=-1, verbose=parallel_verbosity_level)(\n        delayed(_batch_nlp_variability_optimization)(\n            batch,\n            cobrak_model,\n            with_kappa,\n            with_gamma,\n            with_iota,\n            with_alpha,\n            approximation_value,\n            tfba_variability_dict,\n            strict_mode,\n            single_strict_reacs,\n            min_mdf,\n            solver,\n        )\n        for batch in objectives_data_batches\n    )\n    for result in chain(*results_list):\n        is_minimization = result[0]\n        target_id = result[1]\n        result_value = result[2]\n        if is_minimization:\n            min_values[target_id] = result_value\n        else:\n            max_values[target_id] = result_value\n\n    for key, min_value in min_values.items():\n        if (key in cobrak_model.reactions) or (\n            key.startswith(ENZYME_VAR_PREFIX) and (min_value is not None)\n        ):\n            min_values[key] = min_value if min_value &gt;= min_flux_cutoff else 0.0\n\n    all_target_ids = sorted(\n        set(\n            list(min_values.keys())\n            + list(max_values.keys())\n            + [obj_target[1] for obj_target in objective_targets]\n        )\n    )\n    all_target_ids = [x[1] for x in objectives_data]\n    variability_dict: dict[str, tuple[float, float]] = {\n        target_id: (min_values[target_id], max_values[target_id])\n        for target_id in all_target_ids\n    }\n\n    return variability_dict\n</code></pre>"},{"location":"api.html#cobrak.nlps.perform_nlp_reversible_optimization","title":"<code>perform_nlp_reversible_optimization(cobrak_model, objective_target, objective_sense, variability_dict, with_kappa=True, with_gamma=True, with_iota=False, with_alpha=False, approximation_value=0.0001, strict_mode=False, single_strict_reacs=[], verbose=False, solver=SCIP, with_flux_sum_var=False, correction_config=CorrectionConfig(), show_variable_count=False, var_data_abs_epsilon=1e-05)</code>","text":"<p>Performs a reversible MILP-based non-linear program (NLP) optimization on a COBRAk model.</p> <p>For more on the MINLP, see the COBRAk documentation's NLP chapter.</p>"},{"location":"api.html#cobrak.nlps.perform_nlp_reversible_optimization--parameters","title":"Parameters","text":"<ul> <li><code>cobrak_model</code> (<code>Model</code>): The COBRAk model to optimize.</li> <li><code>objective_target</code> (<code>str | dict[str, float]</code>): The objective target (reaction ID or dictionary of reaction IDs and coefficients).</li> <li><code>objective_sense</code> (<code>int</code>): The objective sense (1 for maximization, -1 for minimization).</li> <li><code>variability_dict</code> (<code>dict[str, tuple[float, float]]</code>): Dictionary of reaction IDs and their variability (lower and upper bounds).</li> <li><code>with_kappa</code> (<code>bool</code>, optional): Whether to include \u03ba saturation terms. Defaults to <code>True</code>.</li> <li><code>with_gamma</code> (<code>bool</code>, optional): Whether to include \u03b3 thermodynamic terms. Defaults to <code>True</code>.</li> <li><code>with_iota</code> (<code>bool</code>, optional): Whether to include \u03b9 inhibition terms. Defaults to <code>False</code> and untested!</li> <li><code>with_alpha</code> (<code>bool</code>, optional): Whether to include \u03b1 activation terms. Defaults to <code>False</code> and untested!</li> <li><code>approximation_value</code> (<code>float</code>, optional): Approximation value for \u03ba, \u03b3, \u03b9, and \u03b1 terms. Defaults to <code>0.0001</code>. This value is the    minimal value for \u03ba, \u03b3, \u03b9, and \u03b1 terms, and can lead to an overapproximation in this regard.</li> <li><code>strict_mode</code> (<code>bool</code>, optional): Whether to use strict mode (i.e. all &lt;= heuristics become == relations). Defaults to <code>False</code>.</li> <li><code>single_strict_reacs</code> (<code>list[str]</code>, optional): If 'strict_mode==False', only reactions with an ID in this list are set to strict mode.</li> <li><code>verbose</code> (<code>bool</code>, optional): Whether to print solver output. Defaults to <code>False</code>.</li> <li><code>solver_name</code> (<code>str</code>, optional): Used MINLP solver. Defaults to SCIP,</li> <li><code>with_flux_sum_var</code> (<code>bool</code>, optional): Whether to include a reaction flux sum variable of name <code>cobrak.constants.FLUX_SUM_VAR</code>. Defaults to <code>False</code>.</li> <li><code>correction_config</code> (<code>CorrectionConfig</code>, optional): Parameter correction configuration. Defaults to <code>CorrectionConfig()</code>.</li> <li>var_data_abs_epsilon: (<code>float</code>, optional): Under this value, any data given by the variability dict is considered to be 0. Defaults to 1e-5.</li> </ul>"},{"location":"api.html#cobrak.nlps.perform_nlp_reversible_optimization--returns","title":"Returns","text":"<ul> <li><code>dict[str, float]</code>: The optimization results.</li> </ul> Source code in <code>cobrak/nlps.py</code> <pre><code>@validate_call(config=ConfigDict(arbitrary_types_allowed=True))\ndef perform_nlp_reversible_optimization(\n    cobrak_model: Model,\n    objective_target: str | dict[str, float],\n    objective_sense: int,\n    variability_dict: dict[str, tuple[float, float]],\n    with_kappa: bool = True,\n    with_gamma: bool = True,\n    with_iota: bool = False,\n    with_alpha: bool = False,\n    approximation_value: NonNegativeFloat = 0.0001,\n    strict_mode: bool = False,\n    single_strict_reacs: list[str] = [],\n    verbose: bool = False,\n    solver: Solver = SCIP,\n    with_flux_sum_var: bool = False,\n    correction_config: CorrectionConfig = CorrectionConfig(),\n    show_variable_count: bool = False,\n    var_data_abs_epsilon: float = 1e-5,\n) -&gt; dict[str, float]:\n    \"\"\"Performs a reversible MILP-based non-linear program (NLP) optimization on a COBRAk model.\n\n    For more on the MINLP, see the COBRAk documentation's NLP chapter.\n\n    #### Parameters\n    * `cobrak_model` (`Model`): The COBRAk model to optimize.\n    * `objective_target` (`str | dict[str, float]`): The objective target (reaction ID or dictionary of reaction IDs and coefficients).\n    * `objective_sense` (`int`): The objective sense (1 for maximization, -1 for minimization).\n    * `variability_dict` (`dict[str, tuple[float, float]]`): Dictionary of reaction IDs and their variability (lower and upper bounds).\n    * `with_kappa` (`bool`, optional): Whether to include \u03ba saturation terms. Defaults to `True`.\n    * `with_gamma` (`bool`, optional): Whether to include \u03b3 thermodynamic terms. Defaults to `True`.\n    * `with_iota` (`bool`, optional): Whether to include \u03b9 inhibition terms. Defaults to `False` and untested!\n    * `with_alpha` (`bool`, optional): Whether to include \u03b1 activation terms. Defaults to `False` and untested!\n    * `approximation_value` (`float`, optional): Approximation value for \u03ba, \u03b3, \u03b9, and \u03b1 terms. Defaults to `0.0001`. This value is the\n       minimal value for \u03ba, \u03b3, \u03b9, and \u03b1 terms, and can lead to an overapproximation in this regard.\n    * `strict_mode` (`bool`, optional): Whether to use strict mode (i.e. all &lt;= heuristics become == relations). Defaults to `False`.\n    * `single_strict_reacs` (`list[str]`, optional): If 'strict_mode==False', only reactions with an ID in this list are set to strict mode.\n    * `verbose` (`bool`, optional): Whether to print solver output. Defaults to `False`.\n    * `solver_name` (`str`, optional): Used MINLP solver. Defaults to SCIP,\n    * `with_flux_sum_var` (`bool`, optional): Whether to include a reaction flux sum variable of name ```cobrak.constants.FLUX_SUM_VAR```. Defaults to `False`.\n    * `correction_config` (`CorrectionConfig`, optional): Parameter correction configuration. Defaults to `CorrectionConfig()`.\n    *  var_data_abs_epsilon: (`float`, optional): Under this value, any data given by the variability dict is considered to be 0. Defaults to 1e-5.\n\n    #### Returns\n    * `dict[str, float]`: The optimization results.\n    \"\"\"\n    nlp_model = get_nlp_from_cobrak_model(\n        cobrak_model,\n        with_kappa=with_kappa,\n        with_gamma=with_gamma,\n        with_iota=with_iota,\n        with_alpha=with_alpha,\n        approximation_value=approximation_value,\n        irreversible_mode=False,\n        variability_data=variability_dict,\n        strict_mode=strict_mode,\n        single_strict_reacs=single_strict_reacs,\n        with_flux_sum_var=with_flux_sum_var,\n        correction_config=correction_config,\n    )\n\n    nlp_model = apply_variability_dict(\n        nlp_model,\n        cobrak_model,\n        variability_dict,\n        correction_config.error_scenario,\n        var_data_abs_epsilon,\n    )\n    nlp_model.obj = get_objective(nlp_model, objective_target, objective_sense)\n    pyomo_solver = get_solver(solver.name, solver.solver_options, solver.solver_attrs)\n\n    if show_variable_count:\n        float_vars = [v for v in nlp_model.component_objects(Var) if v.domain == Reals]\n        num_float_vars = sum(1 for v in float_vars for i in v)\n        binary_vars = [\n            v for v in nlp_model.component_objects(Var) if v.domain == Binary\n        ]\n        num_binary_vars = sum(1 for v in binary_vars for i in v)\n        print(\"# FLOAT VARS:\", num_float_vars)\n        print(\"# BINARY VARS:\", num_binary_vars)\n\n    results = pyomo_solver.solve(nlp_model, tee=verbose, **solver.solve_extra_options)\n\n    nlp_result = get_pyomo_solution_as_dict(nlp_model)\n    return add_statuses_to_optimziation_dict(nlp_result, results)\n</code></pre>"},{"location":"api.html#cobrak.plotting","title":"<code>plotting</code>","text":"<p>Functions for plotting different types of data or reaction kinetics, all using matplotlib.</p>"},{"location":"api.html#cobrak.plotting.dual_axis_plot","title":"<code>dual_axis_plot(xpoints, leftaxis_ypoints_list, rightaxis_ypoints_list, xaxis_caption='', leftaxis_caption='', rightaxis_caption='', leftaxis_colors=[], rightaxis_colors=[], leftaxis_titles=[], rightaxis_titles=[], extrapoints=[], has_legend=True, legend_direction='', legend_position=(), is_leftaxis_logarithmic=False, is_rightaxis_logarithmic=False, point_style='', line_style='-', max_digits_after_comma=4, savepath='', left_ylim=None, right_ylim=None, xlim=None, left_axis_in_front=True, left_legend_position=[], right_legend_position=[], figure_size_inches=None, special_figure_mode=False)</code>","text":"<p>Creates a plot with a dual Y-axis.</p> <p>Parameters:</p> Name Type Description Default <code>xpoints</code> <code>list[float]</code> <p>X-axis data points.</p> required <code>leftaxis_ypoints_list</code> <code>list[list[float]]</code> <p>List of Y-axis data points for the left axis.</p> required <code>rightaxis_ypoints_list</code> <code>list[list[float]]</code> <p>List of Y-axis data points for the right axis.</p> required <code>xaxis_caption</code> <code>str</code> <p>X-axis caption. Defaults to \"\".</p> <code>''</code> <code>leftaxis_caption</code> <code>str</code> <p>Left Y-axis caption. Defaults to \"\".</p> <code>''</code> <code>rightaxis_caption</code> <code>str</code> <p>Right Y-axis caption. Defaults to \"\".</p> <code>''</code> <code>leftaxis_colors</code> <code>list[str]</code> <p>Colors for left axis lines. Defaults to [].</p> <code>[]</code> <code>rightaxis_colors</code> <code>list[str]</code> <p>Colors for right axis lines. Defaults to [].</p> <code>[]</code> <code>leftaxis_titles</code> <code>list[str]</code> <p>Legend titles for left axis lines. Defaults to [].</p> <code>[]</code> <code>rightaxis_titles</code> <code>list[str]</code> <p>Legend titles for right axis lines. Defaults to [].</p> <code>[]</code> <code>extrapoints</code> <code>list[tuple[float, float, bool, str, str, str, float]]</code> <p>List of single points, described by tuples with the content [x, y, is_left_axis, color, marker, label, yerr]. If yerr=0, no error bar is drawn at all. Defaults to [].</p> <code>[]</code> <code>has_legend</code> <code>bool</code> <p>Whether to show the legend. Defaults to True.</p> <code>True</code> <code>legend_direction</code> <code>str</code> <p>Legend direction. Defaults to \"\".</p> <code>''</code> <code>legend_position</code> <code>tuple[float, float]</code> <p>Legend position. Defaults to ().</p> <code>()</code> <code>is_leftaxis_logarithmic</code> <code>bool</code> <p>Whether to use a logarithmic scale for the left axis. Defaults to False.</p> <code>False</code> <code>is_rightaxis_logarithmic</code> <code>bool</code> <p>Whether to use a logarithmic scale for the right axis. Defaults to False.</p> <code>False</code> <code>point_style</code> <code>str</code> <p>Style for points. Defaults to \"\".</p> <code>''</code> <code>line_style</code> <code>str</code> <p>Style for lines. Defaults to \"-\".</p> <code>'-'</code> <code>max_digits_after_comma</code> <code>int</code> <p>Max digits after comma shown. Defaults to 4.</p> <code>4</code> <code>savepath</code> <code>str</code> <p>If given, the plot is not shown but saved at the given path. Defaults to \"\"</p> <code>''</code> <p>Returns:</p> Type Description <code>None</code> <p>None (displays the plot)</p> Source code in <code>cobrak/plotting.py</code> <pre><code>@validate_call(config=ConfigDict(arbitrary_types_allowed=True))\ndef dual_axis_plot(\n    xpoints: list[float],\n    leftaxis_ypoints_list: list[list[float]],\n    rightaxis_ypoints_list: list[list[float]],\n    xaxis_caption: str = \"\",\n    leftaxis_caption: str = \"\",\n    rightaxis_caption: str = \"\",\n    leftaxis_colors: list[str] = [],\n    rightaxis_colors: list[str] = [],\n    leftaxis_titles: list[str] = [],\n    rightaxis_titles: list[str] = [],\n    extrapoints: list[tuple[float, float, bool, str, str, str, float]] = [],\n    has_legend: bool = True,\n    legend_direction: str = \"\",\n    legend_position: tuple[Any, ...] = (),\n    is_leftaxis_logarithmic: bool = False,\n    is_rightaxis_logarithmic: bool = False,\n    point_style: str = \"\",\n    line_style: str = \"-\",\n    max_digits_after_comma: int = 4,\n    savepath: str = \"\",\n    left_ylim: None | tuple[float, float] = None,\n    right_ylim: None | tuple[float, float] = None,\n    xlim: None | tuple[float, float] = None,\n    left_axis_in_front: bool = True,\n    left_legend_position: list[int] = [],\n    right_legend_position: list[int] = [],\n    figure_size_inches: None | tuple[float, float] = None,\n    special_figure_mode: bool = False,\n) -&gt; None:\n    \"\"\"Creates a plot with a dual Y-axis.\n\n    Args:\n        xpoints (list[float]): X-axis data points.\n        leftaxis_ypoints_list (list[list[float]]): List of Y-axis data points for the left axis.\n        rightaxis_ypoints_list (list[list[float]]): List of Y-axis data points for the right axis.\n        xaxis_caption (str, optional): X-axis caption. Defaults to \"\".\n        leftaxis_caption (str, optional): Left Y-axis caption. Defaults to \"\".\n        rightaxis_caption (str, optional): Right Y-axis caption. Defaults to \"\".\n        leftaxis_colors (list[str], optional): Colors for left axis lines. Defaults to [].\n        rightaxis_colors (list[str], optional): Colors for right axis lines. Defaults to [].\n        leftaxis_titles (list[str], optional): Legend titles for left axis lines. Defaults to [].\n        rightaxis_titles (list[str], optional): Legend titles for right axis lines. Defaults to [].\n        extrapoints (list[tuple[float, float, bool, str, str, str, float]], optional): List of single points,\n            described by tuples with the content [x, y, is_left_axis, color, marker, label, yerr]. If yerr=0,\n            no error bar is drawn at all. Defaults to [].\n        has_legend (bool, optional): Whether to show the legend. Defaults to True.\n        legend_direction (str, optional): Legend direction. Defaults to \"\".\n        legend_position (tuple[float, float], optional): Legend position. Defaults to ().\n        is_leftaxis_logarithmic (bool, optional): Whether to use a logarithmic scale for the left axis. Defaults to False.\n        is_rightaxis_logarithmic (bool, optional): Whether to use a logarithmic scale for the right axis. Defaults to False.\n        point_style (str, optional): Style for points. Defaults to \"\".\n        line_style (str, optional): Style for lines. Defaults to \"-\".\n        max_digits_after_comma (int, optional): Max digits after comma shown. Defaults to 4.\n        savepath (str): If given, the plot is not shown but saved at the given path. Defaults to \"\"\n\n    Returns:\n        None (displays the plot)\n    \"\"\"\n\n    fig, ax1 = plt.subplots()\n    if figure_size_inches is not None:\n        fig.set_size_inches(figure_size_inches[0], figure_size_inches[1])\n\n    # Left Axis Plotting\n    for i, ypoints in enumerate(leftaxis_ypoints_list):\n        color = leftaxis_colors[i] if leftaxis_colors else None\n        title = leftaxis_titles[i] if leftaxis_titles else None\n        ax1.plot(\n            xpoints,\n            ypoints,\n            color=color,\n            linestyle=line_style,\n            marker=point_style,\n            label=title,\n        )\n\n    ax1.set_xlabel(xaxis_caption, fontsize=14)\n    ax1.set_ylabel(leftaxis_caption, fontsize=14)\n    if is_leftaxis_logarithmic:\n        ax1.set_yscale(\"log\")\n    if left_ylim is not None:\n        ax1.set_ylim(left_ylim[0], left_ylim[1])\n\n    plt.xticks(fontsize=13)\n    plt.yticks(fontsize=13)\n\n    # Right Axis Plotting\n    if len(rightaxis_ypoints_list) &gt; 0:\n        ax2 = ax1.twinx()\n        for i, ypoints in enumerate(rightaxis_ypoints_list):\n            color = rightaxis_colors[i] if rightaxis_colors else None\n            title = rightaxis_titles[i] if rightaxis_titles else None\n            ax2.plot(\n                xpoints,\n                ypoints,\n                color=color,\n                linestyle=line_style,\n                marker=point_style,\n                label=title,\n            )\n\n        ax2.set_ylabel(rightaxis_caption, fontsize=14)\n        if is_rightaxis_logarithmic:\n            ax2.set_yscale(\"log\")\n        if right_ylim is not None:\n            ax2.set_ylim(right_ylim[0], right_ylim[1])\n\n        if left_axis_in_front:\n            ax1.set_zorder(ax2.get_zorder() + 1)\n            ax1.patch.set_visible(False)\n\n    if xlim is not None:\n        ax1.set_xlim(xlim[0], xlim[1])\n\n    for i, extrapoint in enumerate(extrapoints):\n        axis = ax1 if extrapoint[2] else ax2\n        if extrapoint[6] != 0.0:\n            axis.errorbar(\n                extrapoint[0],\n                extrapoint[1],\n                yerr=extrapoint[6],\n                ecolor=extrapoint[3],\n                capsize=5,\n                linestyle=\"\",\n                color=extrapoint[3],\n                marker=extrapoint[4],\n                label=extrapoint[5],\n            )\n        else:\n            axis.plot(\n                extrapoint[0],\n                extrapoint[1],\n                linestyle=\"\",\n                color=extrapoint[3],\n                marker=extrapoint[4],\n                label=extrapoint[5],\n            )\n\n    # Legend\n    if has_legend:\n        handles, labels = ax1.get_legend_handles_labels()\n        if len(rightaxis_ypoints_list) &gt; 0:\n            handles2, labels2 = ax2.get_legend_handles_labels()\n\n            if left_legend_position != []:\n                oldhandles, oldlabels = deepcopy(handles), deepcopy(labels)\n                for i, left_legend_position in enumerate(left_legend_position):\n                    handles[left_legend_position] = oldhandles[i]\n                    labels[left_legend_position] = oldlabels[i]\n\n            if right_legend_position != []:\n                oldhandles2, oldlabels2 = deepcopy(handles2), deepcopy(labels2)\n                for i, right_legend_position in enumerate(right_legend_position):\n                    handles2[right_legend_position] = oldhandles2[i]\n                    labels2[right_legend_position] = oldlabels2[i]\n            if special_figure_mode:\n                # Just for COBRA-k's initial publication :-)\n                del handles[1]\n                del labels[1]\n                handles2.append(oldhandles[-2])\n                labels2.append(oldlabels[-2])\n\n            handles = handles + handles2\n            labels = labels + labels2\n        extraargs = {\"loc\": legend_position} if legend_position != () else {}\n        if legend_direction:\n            extraargs[\"loc\"] = legend_direction\n        plt.legend(\n            handles,\n            labels,\n            prop={\"size\": 10.5},\n            bbox_to_anchor=(0.5, 0.5)\n            if not legend_position and not legend_direction\n            else None,\n            **extraargs,\n        )\n\n    plt.xticks(fontsize=13)\n    plt.yticks(fontsize=13)\n\n    # Format axis ticks\n    ax1.xaxis.set_major_formatter(\n        plt.FuncFormatter(lambda x, _: f\"{x:.{max_digits_after_comma}f}\")\n    )\n    ax1.yaxis.set_major_formatter(\n        plt.FuncFormatter(lambda x, _: f\"{x:.{max_digits_after_comma}f}\")\n    )\n    if len(rightaxis_ypoints_list) &gt; 0:\n        ax2.yaxis.set_major_formatter(\n            plt.FuncFormatter(lambda x, _: f\"{x:.{max_digits_after_comma}f}\")\n        )\n\n    plt.tight_layout()  # Adjust layout to prevent labels from overlapping\n\n    if not savepath:\n        plt.show()\n    else:\n        plt.savefig(savepath)\n\n    # Close the plot to free up memory\n    plt.close()\n</code></pre>"},{"location":"api.html#cobrak.plotting.plot_combinations","title":"<code>plot_combinations(func, min_values, max_values, num_subplots_per_window=18, num_subplots_per_row=6)</code>","text":"<p>Plot all unique combinations of 2 variable arguments and constant values for the other arguments.</p> <p>The plot is a scatter plot with different colors for each category in the hue column. The x-axis represents the x-data, the y-axis represents the y-data, and the hue axis represents the category.</p> <p>The plot has the following features:</p> <ul> <li>A title at the top of the plot with the specified title.</li> <li>Labels for the x-axis and y-axis with the specified labels.</li> <li>A legend on the right side of the plot with the specified hue label.</li> <li>Different colors for each category in the hue column, specified by the palette.</li> <li>A scatter plot with points representing the data.</li> </ul> <p>Example usage:</p> <p>min_values = [-1.0, 0.0, 0.0] max_values = [10.0, 5.0, 10.0] def example_func(args: List[float]) -&gt; float:    return args[0] + args[1] + args[2]</p> <p>plot_combinations(example_func, min_values, max_values)</p> <p>Args: - func: The function to be plotted. It takes a list of floats and returns a float. - min_values: A list of minimum possible values for each argument. - max_values: A list of maximum possible values for each argument. - num_subplots_per_window: The maximum number of subplots per window. Defaults to 18. - num_subplots_per_row: The maximum number of subplots per row in a window. Defaults to 6.</p> <p>Returns: - None</p> Source code in <code>cobrak/plotting.py</code> <pre><code>@validate_call(config=ConfigDict(arbitrary_types_allowed=True))\ndef plot_combinations(\n    func: Callable[[list[float]], float],\n    min_values: list[float],\n    max_values: list[float],\n    num_subplots_per_window: int = 18,\n    num_subplots_per_row: int = 6,\n) -&gt; None:\n    \"\"\"Plot all unique combinations of 2 variable arguments and constant values for the other arguments.\n\n    The plot is a scatter plot with different colors for each category in the hue column. The x-axis represents the x-data,\n    the y-axis represents the y-data, and the hue axis represents the category.\n\n    The plot has the following features:\n\n    * A title at the top of the plot with the specified title.\n    * Labels for the x-axis and y-axis with the specified labels.\n    * A legend on the right side of the plot with the specified hue label.\n    * Different colors for each category in the hue column, specified by the palette.\n    * A scatter plot with points representing the data.\n\n    Example usage:\n    &gt;&gt;&gt; min_values = [-1.0, 0.0, 0.0]\n    &gt;&gt;&gt; max_values = [10.0, 5.0, 10.0]\n    &gt;&gt;&gt; def example_func(args: List[float]) -&gt; float:\n    &gt;&gt;&gt;    return args[0] + args[1] + args[2]\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; plot_combinations(example_func, min_values, max_values)\n\n    Args:\n    - func: The function to be plotted. It takes a list of floats and returns a float.\n    - min_values: A list of minimum possible values for each argument.\n    - max_values: A list of maximum possible values for each argument.\n    - num_subplots_per_window: The maximum number of subplots per window. Defaults to 18.\n    - num_subplots_per_row: The maximum number of subplots per row in a window. Defaults to 6.\n\n    Returns:\n    - None\n    \"\"\"\n\n    # Generate all possible combinations of 2 variable arguments\n    variable_combinations = []\n    for i in range(len(min_values)):\n        for j in range(i + 1, len(min_values)):\n            variable_combinations.append((i, j))\n\n    # Generate all unique combinations of variable and constant arguments\n    combinations = []\n    for variable_combination in variable_combinations:\n        constant_combinations = _get_constant_combinations(\n            len(min_values), variable_combination, min_values, max_values\n        )\n        for constant_combination in constant_combinations:\n            combinations.append((variable_combination, constant_combination))\n\n    # Plot each combination\n    num_windows = int(np.ceil(len(combinations) / num_subplots_per_window))\n    for window_index in range(num_windows):\n        num_subplots = min(\n            num_subplots_per_window,\n            len(combinations) - window_index * num_subplots_per_window,\n        )\n        num_rows = int(np.ceil(num_subplots / num_subplots_per_row))\n        _, axs = plt.subplots(\n            num_rows,\n            num_subplots_per_row,\n            figsize=(20, 5 * num_rows),\n            subplot_kw={\"projection\": \"3d\"},\n        )\n        if num_subplots_per_row == 1:\n            axs = [[ax] for ax in axs]\n        elif num_rows == 1:\n            axs = [axs]\n        else:\n            axs = [list(axs_row) for axs_row in axs]\n\n        z_mins = {}\n        z_maxs = {}\n        for combination in combinations[\n            window_index * num_subplots_per_window : (window_index + 1)\n            * num_subplots_per_window\n        ]:\n            variable_combination, constant_combination = combination\n            if variable_combination not in z_mins:\n                z_mins[variable_combination] = float(\"inf\")\n                z_maxs[variable_combination] = float(\"-inf\")\n            x = np.linspace(\n                min_values[variable_combination[0]],\n                max_values[variable_combination[0]],\n                100,\n            )\n            y = np.linspace(\n                min_values[variable_combination[1]],\n                max_values[variable_combination[1]],\n                100,\n            )\n            X, Y = np.meshgrid(x, y)\n            Z = np.zeros(X.shape)\n            for i in range(X.shape[0]):\n                for j in range(X.shape[1]):\n                    args = [\n                        (\n                            X[i, j]\n                            if k == variable_combination[0]\n                            else (\n                                Y[i, j]\n                                if k == variable_combination[1]\n                                else constant_combination[k]\n                            )\n                        )\n                        for k in range(len(min_values))\n                    ]\n                    Z[i, j] = func(args)\n            z_mins[variable_combination] = min(z_mins[variable_combination], np.min(Z))  # type: ignore\n            z_maxs[variable_combination] = max(z_maxs[variable_combination], np.max(Z))  # type: ignore\n\n        for subplot_index, combination in enumerate(\n            combinations[\n                window_index * num_subplots_per_window : (window_index + 1)\n                * num_subplots_per_window\n            ]\n        ):\n            variable_combination, constant_combination = combination\n            x = np.linspace(\n                min_values[variable_combination[0]],\n                max_values[variable_combination[0]],\n                100,\n            )\n            y = np.linspace(\n                min_values[variable_combination[1]],\n                max_values[variable_combination[1]],\n                100,\n            )\n            X, Y = np.meshgrid(x, y)\n            Z = np.zeros(X.shape)\n            for i in range(X.shape[0]):\n                for j in range(X.shape[1]):\n                    args = [\n                        (\n                            X[i, j]\n                            if k == variable_combination[0]\n                            else (\n                                Y[i, j]\n                                if k == variable_combination[1]\n                                else constant_combination[k]\n                            )\n                        )\n                        for k in range(len(min_values))\n                    ]\n                    Z[i, j] = func(args)\n\n            row_index = subplot_index // num_subplots_per_row\n            col_index = subplot_index % num_subplots_per_row\n\n            axs[row_index][col_index].plot_surface(\n                X, Y, Z, cmap=\"viridis\", edgecolor=\"none\"\n            )\n            axs[row_index][col_index].set_xlabel(f\"Argument {variable_combination[0]}\")\n            axs[row_index][col_index].set_ylabel(f\"Argument {variable_combination[1]}\")\n            axs[row_index][col_index].set_zlim(\n                z_mins[variable_combination], z_maxs[variable_combination]\n            )\n\n            constant_title = \", \".join(\n                [\n                    f\"{i}: {constant_combination[i]}\"\n                    for i in range(len(min_values))\n                    if i not in variable_combination\n                ]\n            )\n            axs[row_index][col_index].set_title(\n                (\n                    f\"Variable: {variable_combination[0]}, {variable_combination[1]}\\n\"\n                    f\"Constant: {constant_title}\"\n                    if constant_title\n                    else f\"Variable: {variable_combination[0]}, {variable_combination[1]}\"\n                ),\n                fontsize=8,\n            )\n\n            # Hide empty plots\n            if subplot_index &gt;= num_subplots:\n                axs[row_index][col_index].axis(\"off\")\n\n        plt.tight_layout()\n        plt.show()\n</code></pre>"},{"location":"api.html#cobrak.plotting.plot_objvalue_evolution","title":"<code>plot_objvalue_evolution(json_path, output_path, ylabel='Objective value', objvalue_multiplicator=-1.0, with_legend=False, algorithm='genetic', precision=4)</code>","text":"<p>Plots the evolution of the objective value over computational time.</p> <p>Parameters:</p> Name Type Description Default <code>json_path</code> <code>str</code> <p>Path to the JSON file containing the data.</p> required <code>output_path</code> <code>str</code> <p>Path to save the plot.</p> required <code>ylabel</code> <code>str</code> <p>Label for the Y-axis. Defaults to \"Objective value\".</p> <code>'Objective value'</code> <code>objvalue_multiplicator</code> <code>float</code> <p>Multiplier to apply to the objective value. Defaults to -1.0.</p> <code>-1.0</code> <code>with_legend</code> <code>bool</code> <p>Whether to display the legend. Defaults to False.</p> <code>False</code> <code>algorithm</code> <code>Literal['pso', 'genetic']</code> <p>The optimization algorithm used. Defaults to \"genetic\".</p> <code>'genetic'</code> <code>precision</code> <code>int</code> <p>The number of decimal places to display on the Y-axis. Defaults to 4.</p> <code>4</code> <p>Returns:</p> Type Description <code>None</code> <p>None. Saves the plot to the specified output path.</p> Source code in <code>cobrak/plotting.py</code> <pre><code>@validate_call(config=ConfigDict(arbitrary_types_allowed=True))\ndef plot_objvalue_evolution(\n    json_path: str,\n    output_path: str,\n    ylabel: str = \"Objective value\",\n    objvalue_multiplicator: float = -1.0,\n    with_legend: bool = False,\n    algorithm: Literal[\"pso\", \"genetic\"] = \"genetic\",\n    precision: int = 4,\n) -&gt; None:\n    \"\"\"Plots the evolution of the objective value over computational time.\n\n    Args:\n        json_path (str): Path to the JSON file containing the data.\n        output_path (str): Path to save the plot.\n        ylabel (str, optional): Label for the Y-axis. Defaults to \"Objective value\".\n        objvalue_multiplicator (float, optional): Multiplier to apply to the objective value. Defaults to -1.0.\n        with_legend (bool, optional): Whether to display the legend. Defaults to False.\n        algorithm (Literal[\"pso\", \"genetic\"], optional): The optimization algorithm used. Defaults to \"genetic\".\n        precision (int, optional): The number of decimal places to display on the Y-axis. Defaults to 4.\n\n    Returns:\n        None. Saves the plot to the specified output path.\n    \"\"\"\n\n    def format_decimal(x, _) -&gt; str:  # noqa: ANN001\n        return f\"{x:.{precision}f}\"  # Use the specified precision\n\n    # Load data from JSON file\n    data = json_load(json_path, Any)\n\n    # Extract timepoints\n    timepoints = tuple(float(key) for key in data)\n\n    # Initialize objvalues list\n    match algorithm:\n        case \"pso\":\n            objvalues = [[] for _ in range(len(list(data.values())[0]))]\n        case \"genetic\":\n            objvalues = [[]]\n        case _:\n            raise ValueError\n\n    # Populate objvalues list\n    for values in data.values():\n        match algorithm:\n            case \"pso\":\n                for value_idx, value in enumerate(values):\n                    if value &gt;= 1_000_000.0:\n                        objvalues[value_idx].append(None)\n                    else:\n                        objvalues[value_idx].append(value * objvalue_multiplicator)\n            case \"genetic\":\n                objvalues[0].append(objvalue_multiplicator * values[0])\n\n    plt.clf()\n    plt.cla()\n    match algorithm:\n        case \"pso\":\n            for objvalue_idx, objvalue_list in enumerate(objvalues):\n                plt.plot(\n                    timepoints,\n                    objvalue_list,\n                    linestyle=\"-\",\n                    marker=None,\n                    label=f\"Particle {objvalue_idx + 1}\",\n                )\n        case \"genetic\":\n            plt.plot(\n                timepoints, objvalues[0], linestyle=\"-\", marker=None, label=\"Best value\"\n            )\n\n    # Customize the plot\n    plt.xlabel(\"Computational Time [s]\")\n    plt.ylabel(ylabel)\n    plt.title(f\"{ylabel} Evolution Over Time\")\n    if with_legend:\n        plt.legend()\n\n    plt.gca().yaxis.set_major_formatter(FuncFormatter(format_decimal))\n\n    # Save the plot\n    plt.savefig(output_path)\n\n    # Close the plot to free up memory\n    plt.close()\n</code></pre>"},{"location":"api.html#cobrak.plotting.plot_variabilities","title":"<code>plot_variabilities(variabilities, variability_names, variability_titles, colors, xlabel='', ylabel='', yscale='log', plot_mean=True, save_path=None)</code>","text":"<p>Plots the mean values and whisker bars for multiple variabilities.</p> <p>This function generates a plot where each variability is represented by a series of points (triangles) and whisker bars. Each point (if plot_mean==True) represents the mean value of a data point in the variability, and the whisker bars represent the lower and upper bounds. The variabilities are grouped together for each data point, with a space between each group to clearly distinguish them.</p>"},{"location":"api.html#cobrak.plotting.plot_variabilities--parameters","title":"Parameters:","text":"<p>variabilities : List[List[Tuple[float, float, float]]] A list of lists, where each inner list represents a variability. Each tuple in the inner list contains (lower_bound, upper_bound, mean_value) for each data point in the variability.</p> <p>variability_names : List[str] A list of strings representing the names of the variabilities.</p> <p>colors : List[str] A list of strings representing the colors for each variability, e.g. using names from https://matplotlib.org/stable/gallery/color/named_colors.html</p> <p>plot_mean : bool, optional If True, the mean value is plotted as a triangle. If False, only the whisker bars are plotted. Default is True.</p> <p>save_path : str, optional The file path where the plot should be saved. If None, the plot is displayed. Default is None.</p>"},{"location":"api.html#cobrak.plotting.plot_variabilities--returns","title":"Returns:","text":"<p>None The function either displays the plot or saves it to the specified path.</p>"},{"location":"api.html#cobrak.plotting.plot_variabilities--example","title":"Example:","text":"<p>in_vivo = [(1.0, 3.0, 2.0), (2.0, 4.0, 3.0), (3.0, 5.0, 4.0)] in_silico = [(1.5, 3.5, 2.5), (2.5, 4.5, 3.5), (3.5, 5.5, 4.5)] another_variability = [(1.2, 3.2, 2.2), (2.2, 4.2, 3.2), (3.2, 5.2, 4.2)] variabilities = [in_vivo, in_silico, another_variability] variability_names = ['in_vivo', 'in_silico', 'another_variability'] colors = ['blue', 'orange', 'green'] plot_variabilities(variabilities, variability_names, colors) plot_variabilities(variabilities, variability_names, colors, plot_mean=False) plot_variabilities(variabilities, variability_names, colors, save_path='plot.png')</p> Source code in <code>cobrak/plotting.py</code> <pre><code>@validate_call(config=ConfigDict(arbitrary_types_allowed=True))\ndef plot_variabilities(\n    variabilities: list[list[tuple[float, float, float]]],\n    variability_names: list[str],\n    variability_titles: list[str],\n    colors: list[str],\n    xlabel: str = \"\",\n    ylabel: str = \"\",\n    yscale: str = \"log\",\n    plot_mean: bool = True,\n    save_path: str | None = None,\n) -&gt; None:\n    \"\"\"Plots the mean values and whisker bars for multiple variabilities.\n\n    This function generates a plot where each variability is represented by a series of points (triangles) and whisker bars.\n    Each point (if plot_mean==True) represents the mean value of a data point in the variability, and the whisker bars represent the lower and upper bounds.\n    The variabilities are grouped together for each data point, with a space between each group to clearly distinguish them.\n\n    Parameters:\n    -----------\n    variabilities : List[List[Tuple[float, float, float]]]\n    A list of lists, where each inner list represents a variability. Each tuple in the inner list contains\n    (lower_bound, upper_bound, mean_value) for each data point in the variability.\n\n    variability_names : List[str]\n    A list of strings representing the names of the variabilities.\n\n    colors : List[str]\n    A list of strings representing the colors for each variability, e.g. using names from https://matplotlib.org/stable/gallery/color/named_colors.html\n\n    plot_mean : bool, optional\n    If True, the mean value is plotted as a triangle. If False, only the whisker bars are plotted. Default is True.\n\n    save_path : str, optional\n    The file path where the plot should be saved. If None, the plot is displayed. Default is None.\n\n    Returns:\n    --------\n    None\n    The function either displays the plot or saves it to the specified path.\n\n    Example:\n    --------\n    &gt;&gt;&gt; in_vivo = [(1.0, 3.0, 2.0), (2.0, 4.0, 3.0), (3.0, 5.0, 4.0)]\n    &gt;&gt;&gt; in_silico = [(1.5, 3.5, 2.5), (2.5, 4.5, 3.5), (3.5, 5.5, 4.5)]\n    &gt;&gt;&gt; another_variability = [(1.2, 3.2, 2.2), (2.2, 4.2, 3.2), (3.2, 5.2, 4.2)]\n    &gt;&gt;&gt; variabilities = [in_vivo, in_silico, another_variability]\n    &gt;&gt;&gt; variability_names = ['in_vivo', 'in_silico', 'another_variability']\n    &gt;&gt;&gt; colors = ['blue', 'orange', 'green']\n    &gt;&gt;&gt; plot_variabilities(variabilities, variability_names, colors)\n    &gt;&gt;&gt; plot_variabilities(variabilities, variability_names, colors, plot_mean=False)\n    &gt;&gt;&gt; plot_variabilities(variabilities, variability_names, colors, save_path='plot.png')\n    \"\"\"\n    # Number of variabilities\n    n = len(variabilities[0])\n    num_variabilities = len(variabilities)\n\n    # Create a figure and axis\n    _, ax = plt.subplots()\n\n    # Define the positions for the groups\n    positions = [\n        list(\n            range(\n                i * (num_variabilities + 1),\n                i * (num_variabilities + 1) + num_variabilities,\n            )\n        )\n        for i in range(n)\n    ]\n\n    # Plot each variability\n    for i, (pos_group, variability) in enumerate(zip(positions, zip(*variabilities))):\n        for j, (pos, (lower, upper, mean)) in enumerate(zip(pos_group, variability)):\n            if plot_mean:\n                ax.errorbar(\n                    pos,\n                    mean,\n                    yerr=[[mean - lower], [upper - mean]],\n                    fmt=\"o\",\n                    capsize=5,\n                    color=colors[j],\n                    ecolor=colors[j],\n                    label=variability_titles[j] if i == 0 else \"\",\n                )\n            else:\n                ax.errorbar(\n                    pos,\n                    mean,\n                    yerr=[[mean - lower], [upper - mean]],\n                    fmt=\"none\",\n                    capsize=5,\n                    ecolor=colors[j],\n                    label=variability_titles[j] if i == 0 else \"\",\n                )\n\n    # Calculate midpoints between groups for vertical lines\n    for i in range(len(positions) - 1):\n        # Get the end of the current group and the start of the next group\n        current_group_end = positions[i][-1]\n        next_group_start = positions[i + 1][0]\n        # Calculate the midpoint\n        midpoint = (current_group_end + next_group_start) / 2\n        # Draw a thin vertical black line at the midpoint\n        ax.axvline(x=midpoint, color=\"black\", linestyle=\"-\", linewidth=0.5, alpha=0.7)\n\n    # Set the x-axis labels\n    ax.set_xticks([pos[0] + (num_variabilities - 1) / 2 for pos in positions])\n    ax.set_xticklabels(variability_names)  # [f\"Exp {i+1}\" for i in range(n)])\n\n    # Add labels and title\n    ax.set_xlabel(xlabel)\n    ax.set_ylabel(ylabel)\n    ax.set_title(\"Comparison of Variabilities\")\n    ax.set_yscale(yscale)\n\n    # Add legend\n    ax.legend()\n\n    # Save or show the plot\n    if save_path is not None:\n        plt.savefig(save_path)\n    else:\n        plt.show()\n</code></pre>"},{"location":"api.html#cobrak.plotting.scatterplot_with_labels","title":"<code>scatterplot_with_labels(x_data, y_data, labels, x_label=None, y_label=None, y_log=True, x_log=True, add_labels=False, identical_axis_lims=True, xlim_overwrite=None, ylim_overwrite=None, ax=None, save_path=None, title=None, extratext=None, x_labelsize=13, y_labelsize=13)</code>","text":"<p>Generates a scatter plot with error bars and optional point labels.</p> <p>Can be used standalone (\"one-off\" plot with plt.show()), or for subplotting by passing an Axes object. Optionally saves the figure if save_path is provided.</p>"},{"location":"api.html#cobrak.plotting.scatterplot_with_labels--parameters","title":"Parameters","text":"<p>x_data : list[tuple[float, float, float]]     Each tuple is (lower bound, upper bound, drawn value) for x. y_data : list[tuple[float, float, float]]     Each tuple is (lower bound, upper bound, drawn value) for y. labels : list[str]     Labels for each point (used if add_labels is True). x_label : str, optional     X-axis label. y_label : str, optional     Y-axis label. y_log : bool, default True     Use log scale for y-axis. x_log : bool, default True     Use log scale for x-axis. add_labels : bool, default False     Annotate points with corresponding label. identical_axis_lims : bool, default True     Make x and y axis limits identical and auto-scale them. ax : matplotlib.axes.Axes, optional     If provided, plot is drawn on this Axes (for subplotting). save_path : str, optional     If provided and <code>ax</code> is None (standalone plotting), save the figure at this path instead of showing.</p>"},{"location":"api.html#cobrak.plotting.scatterplot_with_labels--returns","title":"Returns","text":"<p>ax : matplotlib.axes.Axes     The axis object containing the plot.</p> Source code in <code>cobrak/plotting.py</code> <pre><code>@validate_call(config=ConfigDict(arbitrary_types_allowed=True))\ndef scatterplot_with_labels(\n    x_data: list[tuple[float, float, float]],\n    y_data: list[tuple[float, float, float]],\n    labels: list[str],\n    x_label: str = None,\n    y_label: str = None,\n    y_log: bool = True,\n    x_log: bool = True,\n    add_labels: bool = False,\n    identical_axis_lims: bool = True,\n    xlim_overwrite: None | tuple[float, float] = None,\n    ylim_overwrite: None | tuple[float, float] = None,\n    ax: plt.Axes = None,\n    save_path: str = None,\n    title: str | None = None,\n    extratext: str | None = None,\n    x_labelsize: float = 13,\n    y_labelsize: float = 13,\n) -&gt; plt.Axes:\n    \"\"\"\n    Generates a scatter plot with error bars and optional point labels.\n\n    Can be used standalone (\"one-off\" plot with plt.show()), or for subplotting by passing an Axes object.\n    Optionally saves the figure if save_path is provided.\n\n    Parameters\n    ----------\n    x_data : list[tuple[float, float, float]]\n        Each tuple is (lower bound, upper bound, drawn value) for x.\n    y_data : list[tuple[float, float, float]]\n        Each tuple is (lower bound, upper bound, drawn value) for y.\n    labels : list[str]\n        Labels for each point (used if add_labels is True).\n    x_label : str, optional\n        X-axis label.\n    y_label : str, optional\n        Y-axis label.\n    y_log : bool, default True\n        Use log scale for y-axis.\n    x_log : bool, default True\n        Use log scale for x-axis.\n    add_labels : bool, default False\n        Annotate points with corresponding label.\n    identical_axis_lims : bool, default True\n        Make x and y axis limits identical and auto-scale them.\n    ax : matplotlib.axes.Axes, optional\n        If provided, plot is drawn on this Axes (for subplotting).\n    save_path : str, optional\n        If provided and `ax` is None (standalone plotting), save the figure at this path instead of showing.\n\n    Returns\n    -------\n    ax : matplotlib.axes.Axes\n        The axis object containing the plot.\n    \"\"\"\n    # Calculate midpoints and error sizes for x and y coordinates\n    x_drawn = [x[2] for x in x_data]\n    x_low = [x[0] for x in x_data]\n    x_high = [x[1] for x in x_data]\n    x_err_low = [x_drawn[i] - x_low[i] for i in range(len(x_data))]\n    x_err_high = [x_high[i] - x_drawn[i] for i in range(len(x_data))]\n\n    y_drawn = [y[2] for y in y_data]\n    y_low = [y[0] for y in y_data]\n    y_high = [y[1] for y in y_data]\n    y_err_low = [y_drawn[i] - y_low[i] for i in range(len(y_data))]\n    y_err_high = [y_high[i] - y_drawn[i] for i in range(len(y_data))]\n\n    n_points = len(x_drawn)\n    colors = get_cmap(\"viridis\")(np.linspace(0, 1, n_points))\n\n    _created_fig = False\n    if ax is None:\n        fig, ax = plt.subplots(figsize=(10, 6))\n        _created_fig = True\n\n    # Plot each point individually to assign different colors\n    for i in range(n_points):\n        ax.errorbar(\n            x_drawn[i],\n            y_drawn[i],\n            xerr=[[x_err_low[i]], [x_err_high[i]]],\n            yerr=[[y_err_low[i]], [y_err_high[i]]],\n            fmt=\"o\",\n            markersize=8,\n            color=colors[i],\n            capsize=5,\n            capthick=2,\n            elinewidth=2,\n        )\n\n    # Add labels to each point\n    if add_labels:\n        for i, (xi, yi) in enumerate(zip(x_drawn, y_drawn)):\n            ax.annotate(\n                labels[i],\n                (xi, yi),\n                textcoords=\"offset points\",\n                xytext=(0, 10),\n                ha=\"center\",\n            )\n\n    # Axis limits &amp; unity line\n    all_x_values = [x_datapoint[0] for x_datapoint in x_data] + [\n        x_datapoint[1] for x_datapoint in x_data\n    ]\n    all_y_values = [y_datapoint[0] for y_datapoint in y_data] + [\n        y_datapoint[1] for y_datapoint in y_data\n    ]\n\n    min_val = min(*all_y_values, *all_x_values) * 0.99\n    max_val = max(*all_y_values, *all_x_values) * 1.2\n\n    if identical_axis_lims:\n        ax.set_xlim(min_val, max_val)\n        ax.set_ylim(min_val, max_val)\n\n    if xlim_overwrite is not None:\n        ax.set_xlim(xlim_overwrite[0], xlim_overwrite[1])\n    if ylim_overwrite is not None:\n        ax.set_ylim(ylim_overwrite[0], ylim_overwrite[1])\n\n    x_unity = np.linspace(0, max_val * 100, 10)\n    y_unity = x_unity\n    ax.plot(x_unity, y_unity, \"-\", color=\"black\", linewidth=1)\n\n    if y_log:\n        ax.set_yscale(\"log\")\n    if x_log:\n        ax.set_xscale(\"log\")\n\n    if x_label:\n        ax.set_xlabel(x_label, fontsize=x_labelsize)\n    if y_label:\n        ax.set_ylabel(y_label, fontsize=y_labelsize)\n\n    if title is not None:\n        ax.set_title(title, loc=\"left\", fontweight=\"bold\", fontsize=16)\n\n    if extratext:\n        ax.text(\n            0.15,\n            0.975,\n            extratext,\n            horizontalalignment=\"center\",\n            verticalalignment=\"top\",\n            transform=ax.transAxes,\n            fontsize=14,\n            fontweight=\"bold\",\n        )\n\n    ax.grid(True)\n\n    ax.tick_params(axis=\"both\", which=\"major\", labelsize=13)\n    ax.tick_params(axis=\"both\", which=\"minor\", labelsize=10)\n\n    if _created_fig:\n        plt.tight_layout()\n        if save_path is not None:\n            plt.savefig(save_path)\n        else:\n            plt.show()\n        plt.close(fig)\n    return ax\n</code></pre>"},{"location":"api.html#cobrak.printing","title":"<code>printing</code>","text":"<p>Pretty-print summaries of optimization and variability results as well as COBRAk Model instances.</p> <p>For results, its methods generate <code>rich</code> tables that display flux values and variability information for each category. For models, its methods generate <code>rich</code>tables that display the model's structure and parameters.</p>"},{"location":"api.html#cobrak.printing.print_dict","title":"<code>print_dict(dictionary, indent=4)</code>","text":"<p>Pretty-print a dictionary in a JSON formatted string with the specified indentation.</p> <p>Args: dictionary (dict[Any, Any]): The dictionary to print. indent (int, optional): The number of spaces for indentation. Defaults to 4.</p> Source code in <code>cobrak/printing.py</code> <pre><code>@validate_call(config=ConfigDict(arbitrary_types_allowed=True))\ndef print_dict(dictionary: dict[Any, Any], indent: int = 4) -&gt; None:\n    \"\"\"Pretty-print a dictionary in a JSON formatted string with the specified indentation.\n\n    Args:\n    dictionary (dict[Any, Any]): The dictionary to print.\n    indent (int, optional): The number of spaces for indentation. Defaults to 4.\n    \"\"\"\n    console.print(dumps(dictionary, indent=indent))\n</code></pre>"},{"location":"api.html#cobrak.printing.print_model","title":"<code>print_model(cobrak_model, print_reacs=True, print_enzymes=True, print_mets=True, print_extra_linear_constraints=True, print_settings=True, conc_rounding=6)</code>","text":"<p>Pretty-print a detailed summary of the model, including reactions, enzymes, metabolites, and settings.</p> <p>Args: cobrak_model (Model): The model to print. print_reacs (bool, optional): Whether to print reactions. Defaults to True. print_enzymes (bool, optional): Whether to print enzymes. Defaults to True. print_mets (bool, optional): Whether to print metabolites. Defaults to True. print_extra_linear_constraints (bool, optional): Whether to print extra linear constraints. Defaults to True. print_settings (bool, optional): Whether to print general settings. Defaults to True. conc_rounding (int, optional): Number of decimal places to round concentrations to. Defaults to 6.</p> Source code in <code>cobrak/printing.py</code> <pre><code>@validate_call\ndef print_model(\n    cobrak_model: Model,\n    print_reacs: bool = True,\n    print_enzymes: bool = True,\n    print_mets: bool = True,\n    print_extra_linear_constraints: bool = True,\n    print_settings: bool = True,\n    conc_rounding: int = 6,\n) -&gt; None:\n    \"\"\"Pretty-print a detailed summary of the model, including reactions, enzymes, metabolites, and settings.\n\n    Args:\n    cobrak_model (Model): The model to print.\n    print_reacs (bool, optional): Whether to print reactions. Defaults to True.\n    print_enzymes (bool, optional): Whether to print enzymes. Defaults to True.\n    print_mets (bool, optional): Whether to print metabolites. Defaults to True.\n    print_extra_linear_constraints (bool, optional): Whether to print extra linear constraints. Defaults to True.\n    print_settings (bool, optional): Whether to print general settings. Defaults to True.\n    conc_rounding (int, optional): Number of decimal places to round concentrations to. Defaults to 6.\n    \"\"\"\n\n    console.print(\"\\n[b u]Model[b u]\")\n\n    if print_reacs:\n        reac_table = Table(title=\"Reactions\", title_justify=\"left\")\n        reac_table.add_column(\"ID\")\n        reac_table.add_column(\"String\")\n        reac_table.add_column(\"\u0394G'\u00b0\")\n        reac_table.add_column(\"kcat\")\n        reac_table.add_column(\"kM\")\n        reac_table.add_column(\"kI\")\n        reac_table.add_column(\"kA\")\n        reac_table.add_column(\"Hills\")\n        reac_table.add_column(\"Name\")\n        reac_table.add_column(\"Annotation\")\n\n        for reac_id, reaction in sort_dict_keys(cobrak_model.reactions).items():\n            arguments = [\n                reac_id,\n                get_reaction_string(cobrak_model, reac_id),\n                _none_as_na(reaction.dG0),\n                (\n                    \"N/A\"\n                    if reaction.enzyme_reaction_data is None\n                    else str(reaction.enzyme_reaction_data.k_cat)\n                ),\n                (\n                    \"N/A\"\n                    if reaction.enzyme_reaction_data is None\n                    else str(reaction.enzyme_reaction_data.k_ms)\n                ),\n                (\n                    \"N/A\"\n                    if reaction.enzyme_reaction_data is None\n                    else str(reaction.enzyme_reaction_data.k_is)\n                ),\n                (\n                    \"N/A\"\n                    if reaction.enzyme_reaction_data is None\n                    else str(reaction.enzyme_reaction_data.k_as)\n                ),\n                (\n                    \"N/A\"\n                    if reaction.enzyme_reaction_data is None\n                    else str(reaction.enzyme_reaction_data.hill_coefficients)\n                ),\n                reaction.name,\n                str(reaction.annotation),\n            ]\n            reac_table.add_row(*arguments)\n        console.print(reac_table)\n\n    if print_enzymes and cobrak_model.enzymes != {}:\n        enzyme_table = Table(title=\"Enzymes\", title_justify=\"left\")\n        enzyme_table.add_column(\"ID\")\n        enzyme_table.add_column(\"MW\")\n        enzyme_table.add_column(\"min([E])\")\n        enzyme_table.add_column(\"max([E])\")\n        enzyme_table.add_column(\"Name\")\n        enzyme_table.add_column(\"Annotation\")\n\n        for enzyme_id, enzyme in sort_dict_keys(cobrak_model.enzymes).items():\n            arguments = [\n                enzyme_id,\n                str(enzyme.molecular_weight),\n                _none_as_na(enzyme.min_conc),\n                _none_as_na(enzyme.max_conc),\n                enzyme.name,\n                str(enzyme.annotation),\n            ]\n            enzyme_table.add_row(*arguments)\n        console.print(enzyme_table)\n\n    if print_mets:\n        met_table = Table(title=\"Metabolites\", title_justify=\"left\")\n        met_table.add_column(\"ID\")\n        met_table.add_column(\"min(c)\")\n        met_table.add_column(\"max(c)\")\n        met_table.add_column(\"Name\")\n        met_table.add_column(\"Annotation\")\n\n        for met_id, metabolite in sort_dict_keys(cobrak_model.metabolites).items():\n            arguments = [\n                met_id,\n                str(round(exp(metabolite.log_min_conc), conc_rounding)),\n                str(round(exp(metabolite.log_max_conc), conc_rounding)),\n                metabolite.name,\n                str(metabolite.annotation),\n            ]\n            met_table.add_row(*arguments)\n        console.print(met_table)\n\n    if print_extra_linear_constraints and cobrak_model.extra_linear_constraints != []:\n        console.print(\"\\n[b u]Extra linear constraints[b u]\")\n        for extra_linear_constraint in cobrak_model.extra_linear_constraints:\n            console.print(get_extra_linear_constraint_string(extra_linear_constraint))\n\n    if print_settings:\n        console.print(\"\\n[i]General settings[i]\")\n        print_strkey_dict_as_table(\n            {\n                \"Protein pool\": cobrak_model.T,\n                \"R [kJ\u22c5K\u207b\u00b9\u22c5mol\u207b\u00b9]\": cobrak_model.R,\n                \"T [K]\": cobrak_model.T,\n                \"Kinetic-ignored mets\": \", \".join(\n                    cobrak_model.kinetic_ignored_metabolites\n                ),\n            }\n        )\n</code></pre>"},{"location":"api.html#cobrak.printing.print_optimization_result","title":"<code>print_optimization_result(cobrak_model, optimization_dict, print_exchanges=True, print_reactions=True, print_enzymes=True, print_mets=True, print_error_values_if_existing=True, add_stoichiometries=False, rounding=3, conc_rounding=6, ignore_unused=False, multiple_tables_per_line=True, unused_limit=0.0001)</code>","text":"<p>Pretty-Print the results of an optimization, including exchanges, reactions, enzymes, and metabolites.</p> <p>Args: cobrak_model (Model): The model used for optimization. optimization_dict (dict[str, float]): A dictionary containing the optimization results. print_exchanges (bool, optional): Whether to print exchange reactions. Defaults to True. print_reactions (bool, optional): Whether to print non-exchange reactions. Defaults to True. print_enzymes (bool, optional): Whether to print enzyme usage. Defaults to True. print_mets (bool, optional): Whether to print metabolite concentrations. Defaults to True. add_stoichiometries (bool, optional): Whether to include reaction stoichiometries. Defaults to False. rounding (int, optional): Number of decimal places to round to. Defaults to 3. conc_rounding (int, optional): Number of decimal places to round concentrations to. Defaults to 6. ignore_unused (bool, optional): Whether to ignore reactions with zero flux. Defaults to False. multiple_tables_per_line (bool, optional): Whether to display multiple tables side by side. Defaults to True.</p> Source code in <code>cobrak/printing.py</code> <pre><code>@validate_call\ndef print_optimization_result(\n    cobrak_model: Model,\n    optimization_dict: dict[str, float],\n    print_exchanges: bool = True,\n    print_reactions: bool = True,\n    print_enzymes: bool = True,\n    print_mets: bool = True,\n    print_error_values_if_existing: bool = True,\n    add_stoichiometries: bool = False,\n    rounding: int = 3,\n    conc_rounding: int = 6,\n    ignore_unused: bool = False,\n    multiple_tables_per_line: bool = True,\n    unused_limit: float = 1e-4,\n) -&gt; None:\n    \"\"\"Pretty-Print the results of an optimization, including exchanges, reactions, enzymes, and metabolites.\n\n    Args:\n    cobrak_model (Model): The model used for optimization.\n    optimization_dict (dict[str, float]): A dictionary containing the optimization results.\n    print_exchanges (bool, optional): Whether to print exchange reactions. Defaults to True.\n    print_reactions (bool, optional): Whether to print non-exchange reactions. Defaults to True.\n    print_enzymes (bool, optional): Whether to print enzyme usage. Defaults to True.\n    print_mets (bool, optional): Whether to print metabolite concentrations. Defaults to True.\n    add_stoichiometries (bool, optional): Whether to include reaction stoichiometries. Defaults to False.\n    rounding (int, optional): Number of decimal places to round to. Defaults to 3.\n    conc_rounding (int, optional): Number of decimal places to round concentrations to. Defaults to 6.\n    ignore_unused (bool, optional): Whether to ignore reactions with zero flux. Defaults to False.\n    multiple_tables_per_line (bool, optional): Whether to display multiple tables side by side. Defaults to True.\n    \"\"\"\n\n    table_columns: list[Table] = []\n\n    all_fluxes = [\n        optimization_dict[reac_id]\n        for reac_id in cobrak_model.reactions\n        if reac_id in optimization_dict\n    ]\n    min_flux = min(all_fluxes)\n    max_flux = max(all_fluxes)\n    all_dfs = [\n        optimization_dict[key]\n        for key in optimization_dict\n        if key.startswith(DF_VAR_PREFIX)\n    ]\n\n    substrate_reac_ids, product_reac_ids = (\n        get_substrate_and_product_exchanges(cobrak_model, optimization_dict)\n        if print_exchanges\n        else ([\"\"], [\"\"])\n    )\n\n    if print_exchanges:\n        for title, exchange_ids in (\n            (\"Substrates\", substrate_reac_ids),\n            (\"Products\", product_reac_ids),\n        ):\n            exchange_table = Table(title=title, title_justify=\"left\")\n            exchange_table.add_column(\"ID\")\n            exchange_table.add_column(\"Flux\")\n            for exchange_id in exchange_ids:\n                exchange_flux = optimization_dict[exchange_id]\n                if ignore_unused and exchange_flux &lt;= unused_limit:\n                    continue\n\n                exchange_table.add_row(\n                    exchange_id,\n                    _mapcolored(\n                        round(optimization_dict[exchange_id], rounding),\n                        min_flux,\n                        max_flux,\n                        prefix=_zero_prefix(exchange_flux),\n                        suffix=_zero_suffix(exchange_flux),\n                    ),\n                )\n            table_columns.append(exchange_table)\n\n    if print_reactions:\n        reac_table = Table(\n            title=\"Non-exchange reactions\" if print_exchanges else \"Reactions\",\n            title_justify=\"left\",\n        )\n        reac_table.add_column(\"ID\")\n        reac_table.add_column(\"v\")\n        if add_stoichiometries:\n            reac_table.add_column(\"Stoichiometries\")\n        reac_table.add_column(\"df\")\n        reac_table.add_column(\"\u03ba\")\n        reac_table.add_column(\"\u03b3\")\n        reac_table.add_column(\"\u03b9\")\n        reac_table.add_column(\"\u03b1\")\n        for reac_id in sort_dict_keys(cobrak_model.reactions):\n            if ignore_unused and (\n                reac_id not in optimization_dict\n                or optimization_dict[reac_id] &lt;= unused_limit\n            ):\n                continue\n\n            if (\n                (reac_id not in optimization_dict)\n                or (reac_id in product_reac_ids)\n                or (reac_id in substrate_reac_ids)\n            ):\n                continue\n            arguments: list[str] = [reac_id]\n            if add_stoichiometries:\n                arguments.append(get_reaction_string(cobrak_model, reac_id))\n\n            reac_flux = optimization_dict[reac_id]\n            prefix, suffix = _zero_prefix(reac_flux), _zero_suffix(reac_flux)\n\n            arguments.extend(\n                (\n                    _mapcolored(\n                        round(reac_flux, rounding),\n                        min_flux,\n                        max_flux,\n                        prefix=prefix,\n                        suffix=suffix,\n                    ),\n                    _get_mapcolored_value_or_na(\n                        f\"{DF_VAR_PREFIX}{reac_id}\",\n                        optimization_dict,\n                        min(all_dfs) if len(all_dfs) &gt; 0 else 0.0,\n                        max(all_dfs) if len(all_dfs) &gt; 0 else 0.0,\n                        rounding=rounding,\n                        prefix=prefix,\n                        suffix=suffix,\n                    ),\n                    _get_mapcolored_value_or_na(\n                        f\"{KAPPA_VAR_PREFIX}{reac_id}\",\n                        optimization_dict,\n                        0.0,\n                        1.0,\n                        rounding=rounding,\n                        prefix=prefix,\n                        suffix=suffix,\n                    ),\n                    _get_mapcolored_value_or_na(\n                        f\"{GAMMA_VAR_PREFIX}{reac_id}\",\n                        optimization_dict,\n                        0.0,\n                        1.0,\n                        rounding=rounding,\n                        prefix=prefix,\n                        suffix=suffix,\n                    ),\n                    _get_mapcolored_value_or_na(\n                        f\"{IOTA_VAR_PREFIX}{reac_id}\",\n                        optimization_dict,\n                        0.0,\n                        1.0,\n                        rounding=rounding,\n                        prefix=prefix,\n                        suffix=suffix,\n                    ),\n                    _get_mapcolored_value_or_na(\n                        f\"{ALPHA_VAR_PREFIX}{reac_id}\",\n                        optimization_dict,\n                        0.0,\n                        1.0,\n                        rounding=rounding,\n                        prefix=prefix,\n                        suffix=suffix,\n                    ),\n                )\n            )\n            reac_table.add_row(*arguments)\n        table_columns.append(reac_table)\n\n    if print_enzymes:\n        enzyme_table = Table(title=\"Enzyme usage\", title_justify=\"left\")\n        enzyme_table.add_column(\"Pool %\")\n        enzyme_table.add_column(\"Enzyme IDs\")\n\n        enzyme_usage = get_enzyme_usage_by_protein_pool_fraction(\n            cobrak_model, optimization_dict\n        )\n        for pool_fraction, enzyme_ids in enzyme_usage.items():\n            if ignore_unused and pool_fraction &lt;= unused_limit:\n                continue\n\n            enzyme_table.add_row(\n                _mapcolored(\n                    round(pool_fraction * 100, rounding),\n                    0.0,\n                    100.0,\n                    prefix=_zero_prefix(pool_fraction),\n                    suffix=_zero_suffix(pool_fraction),\n                ),\n                \"; \".join(enzyme_ids),\n            )\n        table_columns.append(enzyme_table)\n\n    if print_mets:\n        met_table = Table(title=\"Metabolites\", title_justify=\"left\")\n        met_table.add_column(\"ID\")\n        met_table.add_column(\"Concentration\")\n        met_table.add_column(\"Consumption\")\n        met_table.add_column(\"Production\")\n        for met_id, metabolite in sort_dict_keys(cobrak_model.metabolites).items():\n            met_var_id = f\"{LNCONC_VAR_PREFIX}{met_id}\"\n\n            consumption, production = get_metabolite_consumption_and_production(\n                cobrak_model, met_id, optimization_dict\n            )\n\n            if ignore_unused and production &lt;= unused_limit:\n                continue\n\n            prefix, suffix = _zero_prefix(consumption), _zero_suffix(consumption)\n            arguments = [met_id]\n            arguments.append(\n                _get_mapcolored_value_or_na(\n                    met_var_id,\n                    optimization_dict,\n                    metabolite.log_min_conc,\n                    metabolite.log_max_conc,\n                    apply=exp,\n                    special_value=1.0,\n                    rounding=conc_rounding,\n                    prefix=prefix,\n                    suffix=suffix,\n                )\n            )\n\n            arguments.append(_none_as_na(consumption, prefix=prefix, suffix=suffix))\n            arguments.append(_none_as_na(production, prefix=prefix, suffix=suffix))\n\n            met_table.add_row(*arguments)\n        table_columns.append(met_table)\n\n    if (\n        print_error_values_if_existing\n        and sum(\n            key.startswith(ERROR_VAR_PREFIX) for key in list(optimization_dict.keys())\n        )\n        &gt; 0\n    ):\n        error_table = Table(title=\"Errors\", title_justify=\"left\")\n        error_table.add_column(\"ID\")\n        sorted_error_values = sort_dict_keys(\n            {\n                key[len(ERROR_VAR_PREFIX) + 1 :]: value\n                for key, value in optimization_dict.items()\n                if key.startswith(ERROR_VAR_PREFIX) and key != ERROR_SUM_VAR_ID\n            }\n        )\n        min_error_value = min(list(sorted_error_values.values()))\n        max_error_value = max(list(sorted_error_values.values()))\n        for error_name, error_value in sorted_error_values.items():\n            if ignore_unused and (error_value &lt;= unused_limit):\n                continue\n\n            prefix, suffix = _zero_prefix(error_value), _zero_suffix(error_value)\n            arguments = []\n            arguments.append(error_name)\n            arguments.append(\n                _get_mapcolored_value_or_na(\n                    error_name,\n                    sorted_error_values,\n                    min_value=min_error_value,\n                    max_value=max_error_value,\n                    prefix=prefix,\n                    suffix=suffix,\n                )\n            )\n            error_table.add_row(*arguments)\n        error_table.add_row(*[\"SUM\", str(optimization_dict[ERROR_SUM_VAR_ID])])\n        table_columns.append(error_table)\n\n    if multiple_tables_per_line:\n        console.print(Columns(table_columns))\n    else:\n        for table in table_columns:\n            console.print(table)\n\n    console.print(\n        \"OBJECTIVE VALUE:\",\n        str(optimization_dict[OBJECTIVE_VAR_NAME]),\n        \"| SOLVE STATUS OK?\",\n        str(optimization_dict[ALL_OK_KEY]),\n    )\n</code></pre>"},{"location":"api.html#cobrak.printing.print_strkey_dict_as_table","title":"<code>print_strkey_dict_as_table(dictionary, table_title='', key_title='', value_title='')</code>","text":"<p>Print a dictionary as a formatted table.</p> <p>Args: dictionary (dict[str, Any]): The dictionary to print. table_title (str, optional): The title of the table. Defaults to \"\". key_title (str, optional): The title for the key column. Defaults to \"\". value_title (str, optional): The title for the value column. Defaults to \"\".</p> Source code in <code>cobrak/printing.py</code> <pre><code>@validate_call(config=ConfigDict(arbitrary_types_allowed=True))\ndef print_strkey_dict_as_table(\n    dictionary: dict[str, Any],\n    table_title: str = \"\",\n    key_title: str = \"\",\n    value_title: str = \"\",\n) -&gt; None:\n    \"\"\"Print a dictionary as a formatted table.\n\n    Args:\n    dictionary (dict[str, Any]): The dictionary to print.\n    table_title (str, optional): The title of the table. Defaults to \"\".\n    key_title (str, optional): The title for the key column. Defaults to \"\".\n    value_title (str, optional): The title for the value column. Defaults to \"\".\n    \"\"\"\n    table = Table(title=table_title, title_justify=\"left\", show_header=False)\n    table.add_column(key_title, style=\"cyan\", no_wrap=True)\n    table.add_column(value_title, style=\"magenta\")\n    for key, value in sort_dict_keys(dictionary).items():\n        table.add_row(key, str(value))\n    console.print(table)\n</code></pre>"},{"location":"api.html#cobrak.printing.print_variability_result","title":"<code>print_variability_result(cobrak_model, variability_dict, print_exchanges=True, print_reacs=True, print_enzymes=False, print_mets=True, ignore_unused=False, add_stoichiometries=False, rounding=3, multiple_tables_per_line=True)</code>","text":"<p>Print the variability analysis results, including exchanges, reactions, enzymes, and metabolites.</p> <p>Args: cobrak_model (Model): The model used for variability analysis. variability_dict (dict[str, tuple[float, float]]): A dictionary containing the variability results. print_exchanges (bool, optional): Whether to print exchange reactions. Defaults to True. print_reacs (bool, optional): Whether to print non-exchange reactions. Defaults to True. print_enzymes (bool, optional): Whether to print enzyme usage. Defaults to False. print_mets (bool, optional): Whether to print metabolite concentrations. Defaults to True. ignore_unused (bool, optional): Whether to ignore reactions with zero flux. Defaults to False. add_stoichiometries (bool, optional): Whether to include reaction stoichiometries. Defaults to False. rounding (int, optional): Number of decimal places to round to. Defaults to 3. multiple_tables_per_line (bool, optional): Whether to display multiple tables side by side. Defaults to True.</p> Source code in <code>cobrak/printing.py</code> <pre><code>@validate_call\ndef print_variability_result(\n    cobrak_model: Model,\n    variability_dict: dict[str, tuple[float, float]],\n    print_exchanges: bool = True,\n    print_reacs: bool = True,\n    print_enzymes: bool = False,\n    print_mets: bool = True,\n    ignore_unused: bool = False,\n    add_stoichiometries: bool = False,\n    rounding: int = 3,\n    multiple_tables_per_line: bool = True,\n) -&gt; None:\n    \"\"\"Print the variability analysis results, including exchanges, reactions, enzymes, and metabolites.\n\n    Args:\n    cobrak_model (Model): The model used for variability analysis.\n    variability_dict (dict[str, tuple[float, float]]): A dictionary containing the variability results.\n    print_exchanges (bool, optional): Whether to print exchange reactions. Defaults to True.\n    print_reacs (bool, optional): Whether to print non-exchange reactions. Defaults to True.\n    print_enzymes (bool, optional): Whether to print enzyme usage. Defaults to False.\n    print_mets (bool, optional): Whether to print metabolite concentrations. Defaults to True.\n    ignore_unused (bool, optional): Whether to ignore reactions with zero flux. Defaults to False.\n    add_stoichiometries (bool, optional): Whether to include reaction stoichiometries. Defaults to False.\n    rounding (int, optional): Number of decimal places to round to. Defaults to 3.\n    multiple_tables_per_line (bool, optional): Whether to display multiple tables side by side. Defaults to True.\n    \"\"\"\n\n    table_columns: list[Table] = []\n\n    substrate_reac_ids, product_reac_ids = (\n        get_substrate_and_product_exchanges(cobrak_model, variability_dict)\n        if print_exchanges\n        else ([\"\"], [\"\"])\n    )\n\n    reac_columns = [\n        \"ID\",\n        \"min(v\u1d62)\",\n        \"max(v\u1d62)\",\n        \"min(df\u1d62)\",\n        \"max(df\u1d62)\",\n    ]\n    if add_stoichiometries:\n        reac_columns.insert(1, \"Reac string\")\n\n    if print_exchanges:\n        for title, exchange_ids in (\n            (\"Substrates\", substrate_reac_ids),\n            (\"Products\", product_reac_ids),\n        ):\n            exchange_table = Table(title=title, title_justify=\"left\")\n            if add_stoichiometries:\n                exchange_table.add_column(\"Reac string\")\n            for reac_column in reac_columns:\n                exchange_table.add_column(reac_column)\n            for exchange_reac_id in exchange_ids:\n                prefix, suffix = _varcolor(exchange_reac_id, variability_dict)\n                flux_range = _get_var_or_na(\n                    exchange_reac_id, variability_dict, rounding, prefix, suffix\n                )\n                if ignore_unused and flux_range[1] == 0.0:\n                    continue\n                arguments: list[str] = [\n                    exchange_reac_id,\n                    *flux_range,\n                    *_get_var_or_na(\n                        f\"{DF_VAR_PREFIX}{exchange_reac_id}\",\n                        variability_dict,\n                        rounding,\n                        prefix,\n                        suffix,\n                    ),\n                ]\n                exchange_table.add_row(*arguments)\n            table_columns.append(exchange_table)\n\n    if print_reacs:\n        reacs_table = Table(\n            title=\"Non-exchange reactions\" if print_exchanges else \"Reactions\",\n            title_justify=\"left\",\n        )\n        for reac_column in reac_columns:\n            reacs_table.add_column(reac_column)\n        for reac_id in sort_dict_keys(cobrak_model.reactions):\n            if reac_id in [*substrate_reac_ids, *product_reac_ids]:\n                continue\n            prefix, suffix = _varcolor(reac_id, variability_dict)\n\n            flux_range = _get_var_or_na(\n                reac_id, variability_dict, rounding, prefix, suffix\n            )\n            if ignore_unused and flux_range[1] == 0.0:\n                continue\n\n            arguments = [\n                reac_id,\n                *flux_range,\n                *_get_var_or_na(\n                    f\"{DF_VAR_PREFIX}{reac_id}\",\n                    variability_dict,\n                    rounding,\n                    prefix,\n                    suffix,\n                ),\n            ]\n            reacs_table.add_row(*arguments)\n        table_columns.append(reacs_table)\n\n    if print_enzymes:\n        enzymes_table = Table(title=\"Enzymes\", title_justify=\"left\")\n        enzymes_table.add_column(\"ID\")\n        enzymes_table.add_column(\"min(E\u1d62)\")\n        enzymes_table.add_column(\"max(E\u1d62)\")\n\n        for reac_id, reaction in sort_dict_keys(cobrak_model.reactions).items():\n            if reaction.enzyme_reaction_data is None:\n                continue\n            enzyme_var_id = get_reaction_enzyme_var_id(reac_id, reaction)\n            prefix, suffix = _varcolor(enzyme_var_id, variability_dict)\n            conc_range = _get_var_or_na(\n                enzyme_var_id, variability_dict, rounding, prefix, suffix\n            )\n            if ignore_unused and conc_range[1] == 0.0:\n                continue\n            reacs_table.add_row(\n                *[\n                    enzyme_var_id,\n                    conc_range,\n                ],\n                conc_range,\n            )\n        table_columns.append(enzymes_table)\n\n    if print_mets:\n        mets_table = Table(title=\"Metabolites\", title_justify=\"left\")\n        mets_table.add_column(\"ID\")\n        mets_table.add_column(\"min(c\u1d62)\")\n        mets_table.add_column(\"max(c\u1d62)\")\n        for met_id in sort_dict_keys(cobrak_model.metabolites):\n            min_conc_str, max_conc_str = _get_var_or_na(\n                f\"{LNCONC_VAR_PREFIX}{met_id}\", variability_dict, rounding=1_000\n            )\n            try:\n                min_conc = str(round(exp(float(min_conc_str)), rounding))\n                max_conc = str(round(exp(float(max_conc_str)), rounding))\n            except ValueError:\n                min_conc = min_conc_str\n                max_conc = max_conc_str\n            color = \"[blue]\" if min_conc != max_conc else \"[red]\"\n            mets_table.add_row(\n                *[\n                    met_id,\n                    f\"{color} {min_conc}\",\n                    f\"{color} {max_conc}\",\n                ]\n            )\n        table_columns.append(mets_table)\n\n    if multiple_tables_per_line:\n        console.print(Columns(table_columns))\n    else:\n        for table in table_columns:\n            console.print(table)\n</code></pre>"},{"location":"api.html#cobrak.pyomo_functionality","title":"<code>pyomo_functionality</code>","text":"<p>Utilities to work with pyomo ConcreteModel instances directly.</p>"},{"location":"api.html#cobrak.pyomo_functionality.ApproximationPoint","title":"<code>ApproximationPoint</code>","text":"<p>Represents a point in a linear approximation.</p> <p>This dataclass is used to store the slope, intercept, and x-coordinate of a point in a linear approximation.</p> <p>Attributes: - slope (float): The slope of the line passing through this point. - intercept (float): The y-intercept of the line passing through this point. - x_point (float): The x-coordinate of this point.</p> Source code in <code>cobrak/pyomo_functionality.py</code> <pre><code>@dataclass\nclass ApproximationPoint:\n    \"\"\"Represents a point in a linear approximation.\n\n    This dataclass is used to store the slope, intercept, and x-coordinate of a point in a linear approximation.\n\n    Attributes:\n    - slope (float): The slope of the line passing through this point.\n    - intercept (float): The y-intercept of the line passing through this point.\n    - x_point (float): The x-coordinate of this point.\n    \"\"\"\n\n    slope: float\n    intercept: float\n    x_point: float\n</code></pre>"},{"location":"api.html#cobrak.pyomo_functionality.add_linear_approximation_to_pyomo_model","title":"<code>add_linear_approximation_to_pyomo_model(model, y_function, y_function_derivative, x_reference_var_id, new_y_var_name, min_x, max_x, max_rel_difference, max_num_segments=float('inf'), min_abs_error=1e-06)</code>","text":"<p>Add a linear approximation of a given function to a Pyomo model.</p> <p>This function approximates the provided function <code>y_function</code> with a piecewise linear function and adds the approximation to the given Pyomo model. The approximation is based on the derivative of the function <code>y_function_derivative</code>. The approximation is added as a new variable and a set of constraints to the model.</p> <p>Parameters: - model (ConcreteModel): The Pyomo model to which the approximation will be added. - y_function (Callable[[float], float]): The function to be approximated. - y_function_derivative (Callable[[float], float]): The derivative of the function to be approximated. - x_reference_var_id (str): The name of the variable in the model that will be used as the independent variable for the approximation. - new_y_var_name (str): The name of the new variable that will be added to the model to represent the approximation. - min_x (float): The minimum value of the independent variable for the approximation. - max_x (float): The maximum value of the independent variable for the approximation. - max_rel_difference (float): The maximum allowed relative difference between the approximation and the original function. - max_num_segments (int, optional): The maximum number of segments to use for the piecewise linear approximation. Defaults to infinity. - min_abs_error (float, optional): The minimum absolute error allowed between the approximation and the original function. Defaults to 1e-6.</p> <p>Returns: - ConcreteModel: The Pyomo model with the added approximation.</p> Source code in <code>cobrak/pyomo_functionality.py</code> <pre><code>def add_linear_approximation_to_pyomo_model(\n    model: ConcreteModel,\n    y_function: Callable[[float], float],\n    y_function_derivative: Callable[[float], float],\n    x_reference_var_id: str,\n    new_y_var_name: str,\n    min_x: float,\n    max_x: float,\n    max_rel_difference: float,\n    max_num_segments: int = float(\"inf\"),\n    min_abs_error: float = 1e-6,\n) -&gt; ConcreteModel:\n    \"\"\"Add a linear approximation of a given function to a Pyomo model.\n\n    This function approximates the provided function `y_function` with a piecewise linear function\n    and adds the approximation to the given Pyomo model. The approximation is based on the derivative\n    of the function `y_function_derivative`. The approximation is added as a new variable and a set\n    of constraints to the model.\n\n    Parameters:\n    - model (ConcreteModel): The Pyomo model to which the approximation will be added.\n    - y_function (Callable[[float], float]): The function to be approximated.\n    - y_function_derivative (Callable[[float], float]): The derivative of the function to be approximated.\n    - x_reference_var_id (str): The name of the variable in the model that will be used as the independent variable for the approximation.\n    - new_y_var_name (str): The name of the new variable that will be added to the model to represent the approximation.\n    - min_x (float): The minimum value of the independent variable for the approximation.\n    - max_x (float): The maximum value of the independent variable for the approximation.\n    - max_rel_difference (float): The maximum allowed relative difference between the approximation and the original function.\n    - max_num_segments (int, optional): The maximum number of segments to use for the piecewise linear approximation. Defaults to infinity.\n    - min_abs_error (float, optional): The minimum absolute error allowed between the approximation and the original function. Defaults to 1e-6.\n\n    Returns:\n    - ConcreteModel: The Pyomo model with the added approximation.\n    \"\"\"\n    # Find fitting approximation\n    num_segments = 2\n    approximation_points: list[ApproximationPoint] = []\n    while True:\n        ignored_is = []\n        x_points = linspace(min_x, max_x, num_segments)\n        approximation_points = [\n            ApproximationPoint(\n                slope=y_function_derivative(x_point),\n                intercept=y_function(x_point)\n                - y_function_derivative(x_point) * x_point,\n                x_point=x_point,\n            )\n            for x_point in x_points\n        ]\n\n        max_found_min_rel_difference = -float(\"inf\")\n        x_midpoints_data: list[tuple[int, int, float]] = []\n        for i in range(len(x_points) - 1):\n            first_index, second_index = i, i + 1\n            if (\n                approximation_points[first_index].slope\n                - approximation_points[second_index].slope\n                == 0\n            ):\n                continue\n            x_midpoint = (\n                approximation_points[second_index].intercept\n                - approximation_points[first_index].intercept\n            ) / (\n                approximation_points[first_index].slope\n                - approximation_points[second_index].slope\n            )\n            x_midpoints_data.append((first_index, second_index, x_midpoint))\n\n        for first_index, second_index, x_value in x_midpoints_data:\n            real_y = y_function(x_value)\n            y_approx_one = (\n                approximation_points[first_index].slope * x_value\n                + approximation_points[first_index].intercept\n            )\n            y_approx_two = (\n                approximation_points[second_index].slope * x_value\n                + approximation_points[second_index].intercept\n            )\n            errors_absolute = (real_y - y_approx_one, real_y - y_approx_two)\n            if max(errors_absolute) &lt; min_abs_error:\n                ignored_is.append(first_index)\n            errors_relative = (\n                abs(errors_absolute[0] / real_y),\n                abs(errors_absolute[1] / real_y),\n            )\n            max_found_min_rel_difference = max(\n                max_found_min_rel_difference, min(errors_relative)\n            )\n\n        if (max_found_min_rel_difference &lt;= max_rel_difference) or (\n            num_segments == max_num_segments\n        ):\n            break\n\n        num_segments += 1\n    # Add approximation to model\n    min_approx_y = (\n        approximation_points[0].slope * x_points[0] + approximation_points[0].intercept\n    )\n    max_approx_y = (\n        approximation_points[-1].slope * x_points[-1]\n        + approximation_points[-1].intercept\n    )\n    setattr(\n        model, new_y_var_name, Var(within=Reals, bounds=(min_approx_y, max_approx_y))\n    )\n    for approx_i, approximation_point in enumerate(approximation_points):\n        if approx_i in ignored_is:\n            continue\n        setattr(\n            model,\n            f\"{new_y_var_name}_constraint_{approx_i}\",\n            Constraint(\n                rule=getattr(model, new_y_var_name)\n                &gt;= approximation_point.slope * getattr(model, x_reference_var_id)\n                + approximation_point.intercept\n            ),\n        )\n    return model\n</code></pre>"},{"location":"api.html#cobrak.pyomo_functionality.add_objective_to_model","title":"<code>add_objective_to_model(model, objective_target, objective_sense, objective_name, objective_var_name=OBJECTIVE_VAR_NAME)</code>","text":"<p>Add an objective function to a Pyomo model.</p> <p>This function adds an objective function to the given Pyomo model based on the provided target and sense. The target can be a single variable name or a dictionary of variable names with their corresponding multipliers. The sense can be either maximization (as int, value &gt; 0) or minimization (as int, value &lt; 0).</p> <p>Parameters: - model (ConcreteModel): The Pyomo model to which the objective function will be added. - objective_target (str | dict[str, float]): The target for the objective function. It can be a single variable name or a dictionary of variable names with their corresponding multipliers. - objective_sense (int): The sense of the objective function. It can be an integer (positive for maximization, negative for minimization, zero for no objective). - objective_name (str): The name of the new objective function that will be added to the model. - objective_var_name (str, optional): The name of the new variable that will be added to the model to represent the objective function. Defaults to OBJECTIVE_VAR_NAME.</p> <p>Returns: - ConcreteModel: The Pyomo model with the added objective function.</p> Source code in <code>cobrak/pyomo_functionality.py</code> <pre><code>def add_objective_to_model(\n    model: ConcreteModel,\n    objective_target: str | dict[str, float],\n    objective_sense: int,\n    objective_name: str,\n    objective_var_name: str = OBJECTIVE_VAR_NAME,\n) -&gt; ConcreteModel:\n    \"\"\"Add an objective function to a Pyomo model.\n\n    This function adds an objective function to the given Pyomo model based on the provided target and sense.\n    The target can be a single variable name or a dictionary of variable names with their corresponding multipliers.\n    The sense can be either maximization (as int, value &gt; 0) or minimization (as int, value &lt; 0).\n\n    Parameters:\n    - model (ConcreteModel): The Pyomo model to which the objective function will be added.\n    - objective_target (str | dict[str, float]): The target for the objective function. It can be a single variable name or a dictionary of variable names with their corresponding multipliers.\n    - objective_sense (int): The sense of the objective function. It can be an integer (positive for maximization, negative for minimization, zero for no objective).\n    - objective_name (str): The name of the new objective function that will be added to the model.\n    - objective_var_name (str, optional): The name of the new variable that will be added to the model to represent the objective function. Defaults to OBJECTIVE_VAR_NAME.\n\n    Returns:\n    - ConcreteModel: The Pyomo model with the added objective function.\n    \"\"\"\n    setattr(\n        model,\n        objective_name,\n        get_objective(\n            model,\n            objective_target,\n            objective_sense,\n            objective_var_name,\n        ),\n    )\n    return model\n</code></pre>"},{"location":"api.html#cobrak.pyomo_functionality.get_model_var_names","title":"<code>get_model_var_names(model)</code>","text":"<p>Extracts and returns a list of names of all variable components from a Pyomo model.</p> <p>This function iterates over all variable objects (<code>Var</code>) defined in the given Pyomo concrete model instance. It collects the name attribute of each variable object and returns these names as a list of strings.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>ConcreteModel</code> <p>A Pyomo concrete model instance containing various components, including variables.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: A list of string names representing all variable objects in the provided Pyomo model.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pyomo.environ import ConcreteModel, Var\n&gt;&gt;&gt; m = ConcreteModel()\n&gt;&gt;&gt; m.x = Var(initialize=1.0)\n&gt;&gt;&gt; m.y = Var([1, 2], initialize=lambda m,i: i)  # Creates two variables y[1] and y[2]\n&gt;&gt;&gt; var_names = get_model_var_names(m)\n&gt;&gt;&gt; print(var_names)\n['x', 'y[1]', 'y[2]']\n</code></pre> Source code in <code>cobrak/pyomo_functionality.py</code> <pre><code>def get_model_var_names(model: ConcreteModel) -&gt; list[str]:\n    \"\"\"Extracts and returns a list of names of all variable components from a Pyomo model.\n\n    This function iterates over all variable objects (`Var`) defined in the given Pyomo concrete model instance.\n    It collects the name attribute of each variable object and returns these names as a list of strings.\n\n    Parameters:\n        model (ConcreteModel): A Pyomo concrete model instance containing various components, including variables.\n\n    Returns:\n        list[str]: A list of string names representing all variable objects in the provided Pyomo model.\n\n    Examples:\n\n        &gt;&gt;&gt; from pyomo.environ import ConcreteModel, Var\n        &gt;&gt;&gt; m = ConcreteModel()\n        &gt;&gt;&gt; m.x = Var(initialize=1.0)\n        &gt;&gt;&gt; m.y = Var([1, 2], initialize=lambda m,i: i)  # Creates two variables y[1] and y[2]\n        &gt;&gt;&gt; var_names = get_model_var_names(m)\n        &gt;&gt;&gt; print(var_names)\n        ['x', 'y[1]', 'y[2]']\n    \"\"\"\n    return [v.name for v in model.component_objects(Var)]\n</code></pre>"},{"location":"api.html#cobrak.pyomo_functionality.get_objective","title":"<code>get_objective(model, objective_target, objective_sense, objective_var_name=OBJECTIVE_VAR_NAME)</code>","text":"<p>Create and return a pyomo objective function for the given model.</p> <p>Sets up an objective function based on the provided target and sense. The target can be a single variable or a weighted sum of multiple variables. The sense can be either maximization (as int, value &gt; 0) or minimization (as int, value &lt; 0).</p> <p>Parameters: - model (ConcreteModel): The Pyomo model to which the objective function will be added. - objective_target (str | dict[str, float]): The target for the objective function. It can be a single variable name or a dictionary of                                              variable names with their corresponding multipliers. - objective_sense (int): The sense of the objective function. It can be an integer                                     (positive for maximization, negative for minimization, zero for no objective).</p> <p>Returns: - Objective: The Pyomo Objective object representing the objective function.</p> Source code in <code>cobrak/pyomo_functionality.py</code> <pre><code>def get_objective(\n    model: ConcreteModel,\n    objective_target: str | dict[str, float],\n    objective_sense: int,\n    objective_var_name: str = OBJECTIVE_VAR_NAME,\n) -&gt; Objective:\n    \"\"\"Create and return a pyomo objective function for the given model.\n\n    Sets up an objective function based on the provided target and sense.\n    The target can be a single variable or a weighted sum of multiple variables.\n    The sense can be either maximization (as int, value &gt; 0) or minimization (as int, value &lt; 0).\n\n    Parameters:\n    - model (ConcreteModel): The Pyomo model to which the objective function will be added.\n    - objective_target (str | dict[str, float]): The target for the objective function. It can be a single variable name or a dictionary of\n                                                 variable names with their corresponding multipliers.\n    - objective_sense (int): The sense of the objective function. It can be an integer\n                                        (positive for maximization, negative for minimization, zero for no objective).\n\n    Returns:\n    - Objective: The Pyomo Objective object representing the objective function.\n    \"\"\"\n    model, expr = set_target_as_var_and_value(\n        model,\n        objective_target,\n        objective_var_name,\n        \"constraint_of_\" + objective_var_name,\n    )\n\n    if isinstance(objective_sense, int):\n        if objective_sense &gt; 0:\n            expr *= objective_sense\n            pyomo_sense = maximize\n        elif objective_sense &lt; 0:\n            expr *= abs(objective_sense)\n            pyomo_sense = minimize\n        else:  # objective_sense == 0\n            expr = 0.0\n            pyomo_sense = minimize\n    else:\n        print(f\"ERROR: Objective sense is {objective_sense}, but must be an integer.\")\n        raise ValueError\n    return Objective(expr=expr, sense=pyomo_sense)\n</code></pre>"},{"location":"api.html#cobrak.pyomo_functionality.get_solver","title":"<code>get_solver(solver_name, solver_options, solver_attrs)</code>","text":"<p>Create and configure a solver for the given solver name and options.</p> <p>This function returns a Pyomo solver using the specified solver name and applies the provided options to it.</p> <p>Parameters: - solver_name (str): The name of the solver to be used (e.g., 'glpk', 'cbc'). - solver_options (dict[str, float | int | str]): A dictionary of solver options where keys are option names and values are the corresponding option values. - solver_attrs (dict[str, float | int | str]): A dictionary of solver attributes where keys are attribute names and values are the corresponding attribute values.</p> <p>Returns: - SolverFactoryClass: The configured solver instance.</p> Source code in <code>cobrak/pyomo_functionality.py</code> <pre><code>def get_solver(\n    solver_name: str,\n    solver_options: dict[str, float | int | str],\n    solver_attrs: dict[str, float | int | str],\n) -&gt; SolverFactoryClass:\n    \"\"\"Create and configure a solver for the given solver name and options.\n\n    This function returns a Pyomo solver using the specified solver name and applies the provided options to it.\n\n    Parameters:\n    - solver_name (str): The name of the solver to be used (e.g., 'glpk', 'cbc').\n    - solver_options (dict[str, float | int | str]): A dictionary of solver options where keys are option names and values are the corresponding option values.\n    - solver_attrs (dict[str, float | int | str]): A dictionary of solver attributes where keys are attribute names and values are the corresponding attribute values.\n\n    Returns:\n    - SolverFactoryClass: The configured solver instance.\n    \"\"\"\n    if solver_name == \"ipopt\" and cpu_count() &gt; 16:\n        solver = SolverFactory(solver_name)\n    else:\n        solver = SolverFactory(solver_name)\n    for attr_name, attr_value in solver_attrs.items():\n        setattr(solver, attr_name, attr_value)\n    for option_name, option_value in solver_options.items():\n        solver.options[option_name] = option_value\n    return solver\n</code></pre>"},{"location":"api.html#cobrak.pyomo_functionality.set_target_as_var_and_value","title":"<code>set_target_as_var_and_value(model, target, var_name, constraint_name)</code>","text":"<p>Set a target as a variable and its value in a Pyomo model.</p> <p>This function adds a new variable to the given Pyomo model and sets its value to the provided target. The target can be either a single variable name or a dictionary of variable names with their corresponding multipliers.</p> <p>Parameters: - model (ConcreteModel): The Pyomo model to which the variable and constraint will be added. - target (str | dict[str, float]): The target for the new variable. It can be a single variable name or a dictionary of variable names with their corresponding multipliers. - var_name (str): The name of the new variable that will be added to the model. - constraint_name (str): The name of the new constraint that will be added to the model to set the value of the new variable.</p> <p>Returns: - tuple[ConcreteModel, Expression]: The Pyomo model with the added variable and constraint, and the expression representing the target.</p> Source code in <code>cobrak/pyomo_functionality.py</code> <pre><code>def set_target_as_var_and_value(\n    model: ConcreteModel,\n    target: str | dict[str, float],\n    var_name: str,\n    constraint_name: str,\n) -&gt; tuple[ConcreteModel, Expression]:\n    \"\"\"Set a target as a variable and its value in a Pyomo model.\n\n    This function adds a new variable to the given Pyomo model and sets its value to the provided target.\n    The target can be either a single variable name or a dictionary of variable names with their corresponding multipliers.\n\n    Parameters:\n    - model (ConcreteModel): The Pyomo model to which the variable and constraint will be added.\n    - target (str | dict[str, float]): The target for the new variable. It can be a single variable name or a dictionary of variable names with their corresponding multipliers.\n    - var_name (str): The name of the new variable that will be added to the model.\n    - constraint_name (str): The name of the new constraint that will be added to the model to set the value of the new variable.\n\n    Returns:\n    - tuple[ConcreteModel, Expression]: The Pyomo model with the added variable and constraint, and the expression representing the target.\n    \"\"\"\n    if isinstance(target, str):\n        expr = getattr(model, target)\n    else:\n        expr = 0.0\n        for target_id, multiplier in target.items():  # type: ignore\n            expr += multiplier * getattr(model, target_id)\n    setattr(model, var_name, Var(within=Reals, bounds=(-QUASI_INF, QUASI_INF)))\n    setattr(\n        model,\n        constraint_name,\n        Constraint(expr=getattr(model, var_name) == expr),\n    )\n    return model, expr\n</code></pre>"},{"location":"api.html#cobrak.sabio_rk_functionality","title":"<code>sabio_rk_functionality</code>","text":"<p>Functions and associated dataclasses for retrieving kinetic data from SABIO-RK</p>"},{"location":"api.html#cobrak.sabio_rk_functionality.SabioDict","title":"<code>SabioDict</code>  <code>dataclass</code>","text":"<p>Includes all retrieved SabioEntry instances and shows of which type they are</p> Source code in <code>cobrak/sabio_rk_functionality.py</code> <pre><code>@dataclass_json\n@dataclass\nclass SabioDict:\n    \"\"\"Includes all retrieved SabioEntry instances and shows of which type they are\"\"\"\n\n    kcat_entries: dict[str, list[SabioEntry]]\n    \"\"\"Turnover number entries\"\"\"\n    km_entries: dict[str, list[SabioEntry]]\n    \"\"\"Michaelis-Menten constant entries\"\"\"\n    ki_entries: dict[str, list[SabioEntry]]\n    \"\"\"Inhibition constant entries\"\"\"\n    ka_entries: dict[str, list[SabioEntry]]\n    \"\"\"Activation constant entries\"\"\"\n    hill_entries: dict[str, list[SabioEntry]]\n    \"\"\"Hill number entries\"\"\"\n</code></pre>"},{"location":"api.html#cobrak.sabio_rk_functionality.SabioDict.hill_entries","title":"<code>hill_entries</code>  <code>instance-attribute</code>","text":"<p>Hill number entries</p>"},{"location":"api.html#cobrak.sabio_rk_functionality.SabioDict.ka_entries","title":"<code>ka_entries</code>  <code>instance-attribute</code>","text":"<p>Activation constant entries</p>"},{"location":"api.html#cobrak.sabio_rk_functionality.SabioDict.kcat_entries","title":"<code>kcat_entries</code>  <code>instance-attribute</code>","text":"<p>Turnover number entries</p>"},{"location":"api.html#cobrak.sabio_rk_functionality.SabioDict.ki_entries","title":"<code>ki_entries</code>  <code>instance-attribute</code>","text":"<p>Inhibition constant entries</p>"},{"location":"api.html#cobrak.sabio_rk_functionality.SabioDict.km_entries","title":"<code>km_entries</code>  <code>instance-attribute</code>","text":"<p>Michaelis-Menten constant entries</p>"},{"location":"api.html#cobrak.sabio_rk_functionality.SabioEntry","title":"<code>SabioEntry</code>  <code>dataclass</code>","text":"<p>Represents the COBRAk-relevant data retrieved from a single SABIO-RK entry.</p> <p>Of which type this entry is (k_cat, k_m, k_i) is not determined here. This is done in the dataclass SabioDict.</p> Source code in <code>cobrak/sabio_rk_functionality.py</code> <pre><code>@dataclass_json\n@dataclass\nclass SabioEntry:\n    \"\"\"Represents the COBRAk-relevant data retrieved from a single SABIO-RK entry.\n\n    Of which type this entry is (k_cat, k_m, k_i) is not determined here. This is done\n    in the dataclass SabioDict.\n    \"\"\"\n\n    entry_id: int\n    \"\"\"The entry's ID number\"\"\"\n    is_recombinant: bool\n    \"\"\"Whether or not the entry is from a recombinant enzyme\"\"\"\n    kinetics_mechanism_type: str\n    \"\"\"The reaction's kinetic mechanism (e.g., \"Michaelis-Menten\")\"\"\"\n    organism: str\n    \"\"\"The organism (latin-greek name) associated with this entry\"\"\"\n    temperature: float | None\n    \"\"\"[None if not given] The measurement's temperature in \u00b0C\"\"\"\n    ph: float | None\n    \"\"\"[None if not given] The measurement's pH\"\"\"\n    parameter_value: float\n    \"\"\"The value of the parameter\"\"\"\n    parameter_unit: str\n    \"\"\"The unit of the value\"\"\"\n    parameter_associated_species: str\n    \"\"\"The species (metabolite) associated with the parameter\"\"\"\n    substrates: list[str]\n    \"\"\"The list of substrate names\"\"\"\n    products: list[str]\n    \"\"\"The list of product names\"\"\"\n    chebi_ids: list[str]\n    \"\"\"The list of all CHEBI IDs\"\"\"\n</code></pre>"},{"location":"api.html#cobrak.sabio_rk_functionality.SabioEntry.chebi_ids","title":"<code>chebi_ids</code>  <code>instance-attribute</code>","text":"<p>The list of all CHEBI IDs</p>"},{"location":"api.html#cobrak.sabio_rk_functionality.SabioEntry.entry_id","title":"<code>entry_id</code>  <code>instance-attribute</code>","text":"<p>The entry's ID number</p>"},{"location":"api.html#cobrak.sabio_rk_functionality.SabioEntry.is_recombinant","title":"<code>is_recombinant</code>  <code>instance-attribute</code>","text":"<p>Whether or not the entry is from a recombinant enzyme</p>"},{"location":"api.html#cobrak.sabio_rk_functionality.SabioEntry.kinetics_mechanism_type","title":"<code>kinetics_mechanism_type</code>  <code>instance-attribute</code>","text":"<p>The reaction's kinetic mechanism (e.g., \"Michaelis-Menten\")</p>"},{"location":"api.html#cobrak.sabio_rk_functionality.SabioEntry.organism","title":"<code>organism</code>  <code>instance-attribute</code>","text":"<p>The organism (latin-greek name) associated with this entry</p>"},{"location":"api.html#cobrak.sabio_rk_functionality.SabioEntry.parameter_associated_species","title":"<code>parameter_associated_species</code>  <code>instance-attribute</code>","text":"<p>The species (metabolite) associated with the parameter</p>"},{"location":"api.html#cobrak.sabio_rk_functionality.SabioEntry.parameter_unit","title":"<code>parameter_unit</code>  <code>instance-attribute</code>","text":"<p>The unit of the value</p>"},{"location":"api.html#cobrak.sabio_rk_functionality.SabioEntry.parameter_value","title":"<code>parameter_value</code>  <code>instance-attribute</code>","text":"<p>The value of the parameter</p>"},{"location":"api.html#cobrak.sabio_rk_functionality.SabioEntry.ph","title":"<code>ph</code>  <code>instance-attribute</code>","text":"<p>[None if not given] The measurement's pH</p>"},{"location":"api.html#cobrak.sabio_rk_functionality.SabioEntry.products","title":"<code>products</code>  <code>instance-attribute</code>","text":"<p>The list of product names</p>"},{"location":"api.html#cobrak.sabio_rk_functionality.SabioEntry.substrates","title":"<code>substrates</code>  <code>instance-attribute</code>","text":"<p>The list of substrate names</p>"},{"location":"api.html#cobrak.sabio_rk_functionality.SabioEntry.temperature","title":"<code>temperature</code>  <code>instance-attribute</code>","text":"<p>[None if not given] The measurement's temperature in \u00b0C</p>"},{"location":"api.html#cobrak.sabio_rk_functionality.SabioThread","title":"<code>SabioThread</code>","text":"<p>               Bases: <code>Thread</code></p> <p>Represents a single Sabio-RK connection, ready for multi-threading (on one CPU core) using the threading module</p> Source code in <code>cobrak/sabio_rk_functionality.py</code> <pre><code>class SabioThread(threading.Thread):\n    \"\"\"Represents a single Sabio-RK connection, ready for multi-threading (on one CPU core) using the threading module\"\"\"\n\n    def __init__(self, temp_folder: str, start_number: int, end_number: int) -&gt; None:\n        \"\"\"Initializes a SabioThread instance.\n\n        Args:\n            temp_folder (str): The path to the temporary folder where the results will be saved.\n            start_number (int): The starting number for the query range.\n            end_number (int): The ending number for the query range.\n        \"\"\"\n        super().__init__()\n\n        self.temp_folder = standardize_folder(temp_folder)\n        self.start_number = start_number\n        self.end_number = end_number\n\n    def run(self) -&gt; None:\n        \"\"\"Executes the thread's SABIO-RK data request\n\n        Constructs a query string, sends a POST request to the SABIO-RK web service,\n        and writes the response to a file in the temporary folder.\n        \"\"\"\n        query_numbers = \" OR \".join(\n            [str(i + 1) for i in range(self.start_number, self.end_number + 1)]\n        )\n        query_dict = {\"EntryID\": f\"({query_numbers})\"}\n        query_string = \" AND \".join([f\"{k}:{v}\" for k, v in query_dict.items()])\n        query_string += ' AND Parametertype:(\"activation constant\" OR \"Ki\" OR \"kcat\" OR \"km\" OR \"Hill coefficient\") AND EnzymeType:\"wildtype\"'\n        query = {\n            \"fields[]\": [\n                \"EntryID\",\n                \"Organism\",\n                \"IsRecombinant\",\n                \"ECNumber\",\n                \"KineticMechanismType\",\n                \"SabioCompoundID\",\n                \"ChebiID\",\n                \"Parameter\",\n                \"Substrate\",\n                \"Product\",\n                \"Temperature\",\n                \"pH\",\n            ],\n            \"q\": query_string,\n        }\n        request = requests.post(\n            \"http://sabiork.h-its.org/sabioRestWebServices/kineticlawsExportTsv\",\n            params=query,\n            timeout=1e6,\n        )\n        request.raise_for_status()\n        with open(  # noqa: FURB103\n            f\"{self.temp_folder}zzz{self.start_number}.txt\", \"w\", encoding=\"utf-8\"\n        ) as f:\n            f.write(request.text)\n</code></pre>"},{"location":"api.html#cobrak.sabio_rk_functionality.SabioThread.__init__","title":"<code>__init__(temp_folder, start_number, end_number)</code>","text":"<p>Initializes a SabioThread instance.</p> <p>Parameters:</p> Name Type Description Default <code>temp_folder</code> <code>str</code> <p>The path to the temporary folder where the results will be saved.</p> required <code>start_number</code> <code>int</code> <p>The starting number for the query range.</p> required <code>end_number</code> <code>int</code> <p>The ending number for the query range.</p> required Source code in <code>cobrak/sabio_rk_functionality.py</code> <pre><code>def __init__(self, temp_folder: str, start_number: int, end_number: int) -&gt; None:\n    \"\"\"Initializes a SabioThread instance.\n\n    Args:\n        temp_folder (str): The path to the temporary folder where the results will be saved.\n        start_number (int): The starting number for the query range.\n        end_number (int): The ending number for the query range.\n    \"\"\"\n    super().__init__()\n\n    self.temp_folder = standardize_folder(temp_folder)\n    self.start_number = start_number\n    self.end_number = end_number\n</code></pre>"},{"location":"api.html#cobrak.sabio_rk_functionality.SabioThread.run","title":"<code>run()</code>","text":"<p>Executes the thread's SABIO-RK data request</p> <p>Constructs a query string, sends a POST request to the SABIO-RK web service, and writes the response to a file in the temporary folder.</p> Source code in <code>cobrak/sabio_rk_functionality.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"Executes the thread's SABIO-RK data request\n\n    Constructs a query string, sends a POST request to the SABIO-RK web service,\n    and writes the response to a file in the temporary folder.\n    \"\"\"\n    query_numbers = \" OR \".join(\n        [str(i + 1) for i in range(self.start_number, self.end_number + 1)]\n    )\n    query_dict = {\"EntryID\": f\"({query_numbers})\"}\n    query_string = \" AND \".join([f\"{k}:{v}\" for k, v in query_dict.items()])\n    query_string += ' AND Parametertype:(\"activation constant\" OR \"Ki\" OR \"kcat\" OR \"km\" OR \"Hill coefficient\") AND EnzymeType:\"wildtype\"'\n    query = {\n        \"fields[]\": [\n            \"EntryID\",\n            \"Organism\",\n            \"IsRecombinant\",\n            \"ECNumber\",\n            \"KineticMechanismType\",\n            \"SabioCompoundID\",\n            \"ChebiID\",\n            \"Parameter\",\n            \"Substrate\",\n            \"Product\",\n            \"Temperature\",\n            \"pH\",\n        ],\n        \"q\": query_string,\n    }\n    request = requests.post(\n        \"http://sabiork.h-its.org/sabioRestWebServices/kineticlawsExportTsv\",\n        params=query,\n        timeout=1e6,\n    )\n    request.raise_for_status()\n    with open(  # noqa: FURB103\n        f\"{self.temp_folder}zzz{self.start_number}.txt\", \"w\", encoding=\"utf-8\"\n    ) as f:\n        f.write(request.text)\n</code></pre>"},{"location":"api.html#cobrak.sabio_rk_functionality.get_full_sabio_dict","title":"<code>get_full_sabio_dict(sabio_target_folder)</code>","text":"<p>Parses a SABIO-RK web query TSV file from the target folder to create a SabioDict instance containing SABIO-RK entries.</p> <p>Parameters:</p> Name Type Description Default <code>sabio_target_folder</code> <code>str</code> <p>The path to the folder containing the TSV file.</p> required <p>Returns:</p> Name Type Description <code>SabioDict</code> <code>SabioDict</code> <p>A SabioDict instance whichm in turn, contains SabioEntry instances</p> Source code in <code>cobrak/sabio_rk_functionality.py</code> <pre><code>def get_full_sabio_dict(sabio_target_folder: str) -&gt; SabioDict:\n    \"\"\"Parses a SABIO-RK web query TSV file from the target folder to create a SabioDict instance containing SABIO-RK entries.\n\n    Args:\n        sabio_target_folder (str): The path to the folder containing the TSV file.\n\n    Returns:\n        SabioDict: A SabioDict instance whichm in turn, contains SabioEntry instances\n    \"\"\"\n    tsv_str = _get_sabio_tsv_str(sabio_target_folder)\n\n    tsv_lines = tsv_str.split(\"\\n\")\n    titles = tsv_lines[0].split(\"\\t\")\n    del tsv_lines[0]\n\n    sabio_dict = SabioDict({}, {}, {}, {}, {})\n    for tsv_line in tsv_lines:\n        line = tsv_line.split(\"\\t\")\n\n        parameter_value_str = line[titles.index(\"parameter.startValue\")]\n        if not parameter_value_str:\n            continue\n        parameter_value = float(parameter_value_str)\n        if parameter_value &lt;= 0.0:\n            continue  # There is no kinetic parameter that is just 0 or below\n\n        parameter_type_str = line[titles.index(\"parameter.type\")]\n        match parameter_type_str.lower():\n            case \"kcat\":\n                sabio_dict_pointer = sabio_dict.kcat_entries\n            case \"km\":\n                sabio_dict_pointer = sabio_dict.km_entries\n            case \"ki\":\n                sabio_dict_pointer = sabio_dict.ki_entries\n            case \"activation constant\":\n                sabio_dict_pointer = sabio_dict.ka_entries\n            case \"hill coefficient\":\n                sabio_dict_pointer = sabio_dict.hill_entries\n            case _:\n                continue\n\n        ec_number = line[titles.index(\"ECNumber\")]\n        entry_id = int(line[titles.index(\"EntryID\")])\n        organism = line[titles.index(\"Organism\")]\n        is_recombinant = line[titles.index(\"IsRecombinant\")].lower() == \"true\"\n        kinetics_mechanism_type = line[titles.index(\"KineticMechanismType\")]\n        parameter_unit = line[titles.index(\"parameter.unit\")]\n        parameter_associated_species = line[titles.index(\"parameter.associatedSpecies\")]\n        substrates = line[titles.index(\"Substrate\")].split(\";\")\n        products = line[titles.index(\"Product\")].split(\";\")\n        chebi_ids = line[titles.index(\"ChebiID\")].split(\";\")\n        try:\n            temperature = float(line[titles.index(\"Temperature\")])\n        except (ValueError, IndexError):\n            temperature = None\n        try:\n            ph = float(line[titles.index(\"pH\")])\n        except (ValueError, IndexError):\n            ph = None\n\n        if ec_number not in sabio_dict_pointer:\n            sabio_dict_pointer[ec_number] = []\n        sabio_dict_pointer[ec_number].append(\n            SabioEntry(\n                entry_id=entry_id,\n                is_recombinant=is_recombinant,\n                kinetics_mechanism_type=kinetics_mechanism_type,\n                organism=organism,\n                temperature=temperature,\n                ph=ph,\n                parameter_unit=parameter_unit,\n                parameter_value=parameter_value,\n                parameter_associated_species=parameter_associated_species,\n                substrates=substrates,\n                products=products,\n                chebi_ids=chebi_ids,\n            )\n        )\n    return sabio_dict\n</code></pre>"},{"location":"api.html#cobrak.sabio_rk_functionality.sabio_select_enzyme_kinetic_data_for_model","title":"<code>sabio_select_enzyme_kinetic_data_for_model(cobra_model, sabio_target_folder, base_species, ncbi_parsed_json_path, bigg_metabolites_json_path, kinetic_ignored_metabolites=[], kinetic_ignored_enzyme_ids=[], custom_enzyme_kinetic_data={}, min_ph=-float('inf'), max_ph=float('inf'), accept_nan_ph=True, min_temperature=-float('inf'), max_temperature=float('inf'), accept_nan_temperature=True, kcat_overwrite={}, transfered_ec_number_json='', max_taxonomy_level=float('inf'), add_hill_coefficients=True)</code>","text":"<p>Selects enzyme kinetic data for a given COBRA-k model using SABIO-RK data.</p> <p>If this data cannot be found, an internet connection is built to SABIO-RK and the relevant data is downloaded, which may take some time in the order of dozens of minutes. If you want to download the full SABIO-RK data beforehand, run get_full_sabio_dict() from this module beforehand, with the same sabio_target_folder.</p> <p>Collected data includes k_cat, k_m, k_i, k_a and Hill coefficients for all EC numbers that occur in the model's BiGG-compliant EC number annotation.</p> <p>Parameters:</p> Name Type Description Default <code>cobra_model</code> <code>Model</code> <p>The COBRA-k model for which enzyme kinetic data is to be selected.</p> required <code>sabio_target_folder</code> <code>str</code> <p>The path to the folder containing SABIO-RK data.</p> required <code>base_species</code> <code>str</code> <p>The base species for taxonomy comparison.</p> required <code>ncbi_parsed_json_path</code> <code>str</code> <p>The path to the NCBI parsed JSON file.</p> required <code>bigg_metabolites_json_path</code> <code>str</code> <p>The path to the BIGG metabolites JSON file.</p> required <code>kinetic_ignored_metabolites</code> <code>list[str]</code> <p>List of metabolites to ignore. Defaults to [].</p> <code>[]</code> <code>kinetic_ignored_enzyme_ids</code> <code>list[str]</code> <p>List of enzyme IDs to ignore. Defaults to [].</p> <code>[]</code> <code>custom_enzyme_kinetic_data</code> <code>dict[str, EnzymeReactionData | None]</code> <p>Custom enzyme kinetic data. Defaults to {}.</p> <code>{}</code> <code>min_ph</code> <code>float</code> <p>Minimum pH value for filtering. Defaults to -float(\"inf\").</p> <code>-float('inf')</code> <code>max_ph</code> <code>float</code> <p>Maximum pH value for filtering. Defaults to float(\"inf\").</p> <code>float('inf')</code> <code>accept_nan_ph</code> <code>bool</code> <p>Whether to accept entries with NaN pH values. Defaults to True.</p> <code>True</code> <code>min_temperature</code> <code>float</code> <p>Minimum temperature value for filtering. Defaults to -float(\"inf\").</p> <code>-float('inf')</code> <code>max_temperature</code> <code>float</code> <p>Maximum temperature value for filtering. Defaults to float(\"inf\").</p> <code>float('inf')</code> <code>accept_nan_temperature</code> <code>bool</code> <p>Whether to accept entries with NaN temperature values. Defaults to True.</p> <code>True</code> <code>kcat_overwrite</code> <code>dict[str, float]</code> <p>Dictionary to overwrite kcat values. Defaults to {}.</p> <code>{}</code> <code>add_hill_coefficients</code> <code>bool</code> <p>Whether Hill coefficeints shall be collected (True) or not (False). Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict[str, EnzymeReactionData | None]</code> <p>dict[str, EnzymeReactionData | None]: A dictionary mapping reaction IDs to enzyme kinetic data.</p> Example <p>cobra_model = cobra.io.read_sbml_model(\"model.xml\") sabio_target_folder = \"/path/to/sabio/data\" base_species = \"Escherichia coli\" ncbi_parsed_json_path = \"/path/to/ncbi.json\" bigg_metabolites_json_path = \"/path/to/bigg_metabolites.json\" enzyme_kinetic_data = sabio_select_enzyme_kinetic_data_for_model(     cobra_model,     sabio_target_folder,     base_species,     ncbi_parsed_json_path,     bigg_metabolites_json_path ) print(enzyme_kinetic_data)</p> Source code in <code>cobrak/sabio_rk_functionality.py</code> <pre><code>def sabio_select_enzyme_kinetic_data_for_model(\n    cobra_model: cobra.Model,\n    sabio_target_folder: str,\n    base_species: str,\n    ncbi_parsed_json_path: str,\n    bigg_metabolites_json_path: str,\n    kinetic_ignored_metabolites: list[str] = [],\n    kinetic_ignored_enzyme_ids: list[str] = [],\n    custom_enzyme_kinetic_data: dict[str, EnzymeReactionData | None] = {},\n    min_ph: float = -float(\"inf\"),\n    max_ph: float = float(\"inf\"),\n    accept_nan_ph: bool = True,\n    min_temperature: float = -float(\"inf\"),\n    max_temperature: float = float(\"inf\"),\n    accept_nan_temperature: bool = True,\n    kcat_overwrite: dict[str, float] = {},\n    transfered_ec_number_json: str = \"\",\n    max_taxonomy_level: int = float(\"inf\"),\n    add_hill_coefficients: bool = True,\n) -&gt; dict[str, EnzymeReactionData | None]:\n    \"\"\"Selects enzyme kinetic data for a given COBRA-k model using SABIO-RK data.\n\n    If this data cannot be found, an internet connection is built to SABIO-RK and the relevant\n    data is downloaded, which may take some time in the order of dozens of minutes.\n    If you want to download the full SABIO-RK data beforehand, run get_full_sabio_dict() from\n    this module beforehand, with the same sabio_target_folder.\n\n    Collected data includes k_cat, k_m, k_i, k_a and Hill coefficients for all EC numbers that\n    occur in the model's BiGG-compliant EC number annotation.\n\n    Args:\n        cobra_model (cobra.Model): The COBRA-k model for which enzyme kinetic data is to be selected.\n        sabio_target_folder (str): The path to the folder containing SABIO-RK data.\n        base_species (str): The base species for taxonomy comparison.\n        ncbi_parsed_json_path (str): The path to the NCBI parsed JSON file.\n        bigg_metabolites_json_path (str): The path to the BIGG metabolites JSON file.\n        kinetic_ignored_metabolites (list[str], optional): List of metabolites to ignore. Defaults to [].\n        kinetic_ignored_enzyme_ids (list[str], optional): List of enzyme IDs to ignore. Defaults to [].\n        custom_enzyme_kinetic_data (dict[str, EnzymeReactionData | None], optional): Custom enzyme kinetic data. Defaults to {}.\n        min_ph (float, optional): Minimum pH value for filtering. Defaults to -float(\"inf\").\n        max_ph (float, optional): Maximum pH value for filtering. Defaults to float(\"inf\").\n        accept_nan_ph (bool, optional): Whether to accept entries with NaN pH values. Defaults to True.\n        min_temperature (float, optional): Minimum temperature value for filtering. Defaults to -float(\"inf\").\n        max_temperature (float, optional): Maximum temperature value for filtering. Defaults to float(\"inf\").\n        accept_nan_temperature (bool, optional): Whether to accept entries with NaN temperature values. Defaults to True.\n        kcat_overwrite (dict[str, float], optional): Dictionary to overwrite kcat values. Defaults to {}.\n        add_hill_coefficients (bool, optional): Whether Hill coefficeints shall be collected (True) or not (False). Defaults to True.\n\n    Returns:\n        dict[str, EnzymeReactionData | None]: A dictionary mapping reaction IDs to enzyme kinetic data.\n\n    Example:\n        cobra_model = cobra.io.read_sbml_model(\"model.xml\")\n        sabio_target_folder = \"/path/to/sabio/data\"\n        base_species = \"Escherichia coli\"\n        ncbi_parsed_json_path = \"/path/to/ncbi.json\"\n        bigg_metabolites_json_path = \"/path/to/bigg_metabolites.json\"\n        enzyme_kinetic_data = sabio_select_enzyme_kinetic_data_for_model(\n            cobra_model,\n            sabio_target_folder,\n            base_species,\n            ncbi_parsed_json_path,\n            bigg_metabolites_json_path\n        )\n        print(enzyme_kinetic_data)\n    \"\"\"\n    sabio_dict = get_full_sabio_dict(\n        sabio_target_folder,\n    )\n    ncbi_parsed_json_data = json_zip_load(ncbi_parsed_json_path)\n    name_to_bigg_id_dict: dict[str, str] = json_load(\n        bigg_metabolites_json_path, dict[str, str]\n    )\n\n    # Get reaction&lt;-&gt;enzyme reaction data mapping\n    enzyme_reaction_data: dict[str, EnzymeReactionData | None] = {}\n    transfered_ec_codes: dict[str, str] = (\n        json_load(transfered_ec_number_json, dict[str, str])\n        if transfered_ec_number_json\n        else {}\n    )\n    for reaction in cobra_model.reactions:\n        if \"ec-code\" not in reaction.annotation:\n            continue\n\n        enzyme_identifiers = reaction.gene_reaction_rule.split(\" and \")\n        has_found_ignored_enzyme = False\n        for enzyme_identifier in enzyme_identifiers:\n            if enzyme_identifier in kinetic_ignored_enzyme_ids:\n                has_found_ignored_enzyme = True\n                break\n        if has_found_ignored_enzyme:\n            continue\n\n        reac_met_ids = [met.id for met in reaction.metabolites]\n        substrate_bigg_ids = [\n            met_id[: met_id.rfind(\"_\")]\n            for met_id in reac_met_ids\n            if reaction.metabolites[cobra_model.metabolites.get_by_id(met_id)] &lt; 0\n        ]\n        product_bigg_ids = [\n            met_id[: met_id.rfind(\"_\")]\n            for met_id in reac_met_ids\n            if reaction.metabolites[cobra_model.metabolites.get_by_id(met_id)] &gt; 0\n        ]\n\n        ec_codes = reaction.annotation[\"ec-code\"]\n        if isinstance(ec_codes, str):\n            ec_codes = [ec_codes]\n        reaction_transfered_ec_codes = [\n            transfered_ec_codes[ec_code]\n            for ec_code in ec_codes\n            if ec_code in transfered_ec_codes\n        ]\n        ec_codes += reaction_transfered_ec_codes\n\n        all_entries = (\n            (\n                \"kcat\",\n                _get_ec_code_entries(\n                    sabio_dict.kcat_entries,\n                    ec_codes,\n                    min_ph,\n                    max_ph,\n                    accept_nan_ph,\n                    min_temperature,\n                    max_temperature,\n                    accept_nan_temperature,\n                    substrate_bigg_ids,\n                    product_bigg_ids,\n                    name_to_bigg_id_dict,\n                ),\n            ),\n            (\n                \"km\",\n                _get_ec_code_entries(\n                    sabio_dict.km_entries,\n                    ec_codes,\n                    min_ph,\n                    max_ph,\n                    accept_nan_ph,\n                    min_temperature,\n                    max_temperature,\n                    accept_nan_temperature,\n                    substrate_bigg_ids,\n                    product_bigg_ids,\n                    name_to_bigg_id_dict,\n                ),\n            ),\n            (\n                \"ki\",\n                _get_ec_code_entries(\n                    sabio_dict.ki_entries,\n                    ec_codes,\n                    min_ph,\n                    max_ph,\n                    accept_nan_ph,\n                    min_temperature,\n                    max_temperature,\n                    accept_nan_temperature,\n                    substrate_bigg_ids,\n                    product_bigg_ids,\n                    name_to_bigg_id_dict,\n                ),\n            ),\n            (\n                \"ka\",\n                _get_ec_code_entries(\n                    sabio_dict.ka_entries,\n                    ec_codes,\n                    min_ph,\n                    max_ph,\n                    accept_nan_ph,\n                    min_temperature,\n                    max_temperature,\n                    accept_nan_temperature,\n                    substrate_bigg_ids,\n                    product_bigg_ids,\n                    name_to_bigg_id_dict,\n                ),\n            ),\n            (\n                \"hill\",\n                _get_ec_code_entries(\n                    sabio_dict.hill_entries,\n                    ec_codes,\n                    min_ph,\n                    max_ph,\n                    accept_nan_ph,\n                    min_temperature,\n                    max_temperature,\n                    accept_nan_temperature,\n                    substrate_bigg_ids,\n                    product_bigg_ids,\n                    name_to_bigg_id_dict,\n                ),\n            ),\n        )\n\n        # {'mol', 'katal*g^(-1)', 'M', 'M^2', 'g', 'mol/mol', 'J/mol', '-',\n        # 's^(-1)', 's^(-1)*g^(-1)', 'mg/ml', 'mol*s^(-1)*mol^(-1)', 'M^(-1)', 'Pa',\n        # 'M^(-1)*s^(-1)', 'mol*s^(-1)*g^(-1)', 'katal'}\n        k_cat_per_tax_score: dict[int, list[float]] = {}\n        k_cat_refs_per_tax_score: dict[int, list[ParameterReference]] = {}\n        k_ms_per_tax_score: dict[str, dict[int, list[float]]] = {}\n        k_m_refs_per_tax_score: dict[str, dict[int, list[ParameterReference]]] = {}\n        k_is_per_tax_score: dict[str, dict[int, list[float]]] = {}\n        k_i_refs_per_tax_score: dict[str, dict[int, list[ParameterReference]]] = {}\n        k_as_per_tax_score: dict[str, dict[int, list[float]]] = {}\n        k_a_refs_per_tax_score: dict[str, dict[int, list[ParameterReference]]] = {}\n        hills_per_tax_score: dict[str, dict[int, list[float]]] = {}\n        hill_refs_per_tax_score: dict[str, dict[int, list[ParameterReference]]] = {}\n        for entries_type, entries in all_entries:\n            if entries_type == \"kcat\":  # Reaction-wide search\n                for entry in entries:\n                    match entry.parameter_unit:\n                        case \"s^(-1)\":\n                            multiplier = 3_600\n                        case _:\n                            continue\n\n                    taxonomy_dict = get_taxonomy_dict_from_nbci_taxonomy(\n                        [base_species, entry.organism], ncbi_parsed_json_data\n                    )\n                    taxonomy_score = get_taxonomy_scores(base_species, taxonomy_dict)[\n                        entry.organism\n                    ]\n                    if taxonomy_score &gt; max_taxonomy_level:\n                        continue\n                    if taxonomy_score not in k_cat_per_tax_score:\n                        k_cat_per_tax_score[taxonomy_score] = []\n                        k_cat_refs_per_tax_score[taxonomy_score] = []\n                    k_cat_per_tax_score[taxonomy_score].append(\n                        entry.parameter_value * multiplier\n                    )\n                    k_cat_refs_per_tax_score[taxonomy_score].append(\n                        ParameterReference(\n                            database=\"SABIO-RK\",\n                            comment=\"SabioEntryID: \" + str(entry.entry_id),\n                            species=entry.organism,\n                            substrate=entry.parameter_associated_species,\n                            value=entry.parameter_value * multiplier,\n                        )\n                    )\n            else:  # Metabolite-wide search\n                match entries_type:\n                    case \"ka\":\n                        values_pointer = k_as_per_tax_score\n                        ref_pointer = k_a_refs_per_tax_score\n                    case \"ki\":\n                        values_pointer = k_is_per_tax_score\n                        ref_pointer = k_i_refs_per_tax_score\n                    case \"km\":\n                        values_pointer = k_ms_per_tax_score\n                        ref_pointer = k_m_refs_per_tax_score\n                    case \"hill\":\n                        if not add_hill_coefficients:\n                            continue\n                        values_pointer = hills_per_tax_score\n                        ref_pointer = hill_refs_per_tax_score\n                    case _:\n                        raise ValueError\n                for met in cobra_model.metabolites:\n                    if met.id in kinetic_ignored_metabolites:\n                        continue\n                    if (entries_type == \"km\") and met not in reaction.metabolites:\n                        continue\n                    bigg_id = met.id[: met.id.rfind(\"_\")]\n                    for entry in entries:\n                        entry_met_id = (\n                            entry.parameter_associated_species.lower().strip()\n                        )\n                        if entry_met_id in name_to_bigg_id_dict:\n                            entry_bigg_id = name_to_bigg_id_dict[entry_met_id]\n                        else:\n                            entry_bigg_id = _search_metname_in_bigg_ids(\n                                met_id=entry_met_id,\n                                bigg_id=\"\",\n                                entry=entry,\n                                name_to_bigg_id_dict=name_to_bigg_id_dict,\n                            )\n                            if not entry_bigg_id:\n                                continue\n                        if entry_bigg_id != bigg_id:\n                            continue\n\n                        match entry.parameter_unit:\n                            case \"M^2\":\n                                applier = sqrt\n                            case \"M^(-1)\":\n                                applier = lambda x: 1 / x  # noqa: E731\n                            case \"M\":\n                                applier = lambda x: x  # noqa: E731\n                            case \"-\":  # e.g. for Hill coefficients\n                                applier = lambda x: x  # noqa: E731\n                            case _:  # unknown unit\n                                continue\n                        taxonomy_dict = get_taxonomy_dict_from_nbci_taxonomy(\n                            [base_species, entry.organism], ncbi_parsed_json_data\n                        )\n                        taxonomy_score = get_taxonomy_scores(\n                            base_species, taxonomy_dict\n                        )[entry.organism]\n                        if taxonomy_score &gt; max_taxonomy_level:\n                            continue\n\n                        if met.id not in values_pointer:\n                            values_pointer[met.id] = {}\n                            ref_pointer[met.id] = {}\n                        if taxonomy_score not in values_pointer[met.id]:\n                            values_pointer[met.id][taxonomy_score] = []\n                            ref_pointer[met.id][taxonomy_score] = []\n                        values_pointer[met.id][taxonomy_score].append(\n                            applier(entry.parameter_value)\n                        )\n                        ref_pointer[met.id][taxonomy_score].append(\n                            ParameterReference(\n                                database=\"SABIO-RK\",\n                                comment=\"SabioEntryID: \" + str(entry.entry_id),\n                                species=entry.organism,\n                                substrate=entry.parameter_associated_species,\n                                tax_distance=taxonomy_score,\n                                value=applier(entry.parameter_value),\n                            )\n                        )\n\n        if reaction.id in kcat_overwrite:\n            k_cat = kcat_overwrite[reaction.id]\n            k_cat_references = [\n                ParameterReference(database=\"OVERWRITE\", tax_distance=-1)\n            ]\n        elif (\n            (reaction.id not in kcat_overwrite) and (kcat_overwrite != {})\n        ) or not k_cat_per_tax_score:\n            continue\n        else:\n            min_k_cat_tax_score = min(k_cat_per_tax_score.keys())\n            k_cat = median(k_cat_per_tax_score[min_k_cat_tax_score])\n            k_cat_references = k_cat_refs_per_tax_score[min_k_cat_tax_score]\n\n        k_ms: dict[str, float] = {}\n        k_m_references: dict[str, list[ParameterReference]] = {}\n        for met_id, k_m_per_tax_score in k_ms_per_tax_score.items():\n            k_ms[met_id] = median(k_m_per_tax_score[min(k_m_per_tax_score.keys())])\n            k_m_references[met_id] = k_m_refs_per_tax_score[met_id][\n                min(k_m_per_tax_score.keys())\n            ]\n\n        k_is: dict[str, float] = {}\n        k_i_references: dict[str, list[ParameterReference]] = {}\n        for met_id, k_i_per_tax_score in k_is_per_tax_score.items():\n            k_is[met_id] = median(k_i_per_tax_score[min(k_i_per_tax_score.keys())])\n            k_i_references[met_id] = k_i_refs_per_tax_score[met_id][\n                min(k_i_per_tax_score.keys())\n            ]\n\n        k_as: dict[str, float] = {}\n        k_a_references: dict[str, list[ParameterReference]] = {}\n        for met_id, k_a_per_tax_score in k_as_per_tax_score.items():\n            k_as[met_id] = median(k_a_per_tax_score[min(k_a_per_tax_score.keys())])\n            k_a_references[met_id] = k_a_refs_per_tax_score[met_id][\n                min(k_a_per_tax_score.keys())\n            ]\n\n        hills: HillCoefficients = HillCoefficients()\n        hill_references: dict[str, list[ParameterReference]] = {}\n        for met_id, hills_per_tax_score in hills_per_tax_score.items():\n            hills.kappa[met_id] = median(\n                hills_per_tax_score[min(hills_per_tax_score.keys())]\n            )\n            hills.iota[met_id] = median(\n                hills_per_tax_score[min(hills_per_tax_score.keys())]\n            )\n            hills.alpha[met_id] = median(\n                hills_per_tax_score[min(hills_per_tax_score.keys())]\n            )\n            hill_references[met_id] = hill_refs_per_tax_score[met_id][\n                min(hills_per_tax_score.keys())\n            ]\n\n        enzyme_reaction_data[reaction.id] = EnzymeReactionData(\n            identifiers=enzyme_identifiers,\n            k_cat=k_cat,\n            k_cat_references=k_cat_references,\n            k_ms=k_ms,\n            k_m_references=k_m_references,\n            k_is=k_is,\n            k_i_references=k_i_references,\n            k_as=k_as,\n            k_a_references=k_a_references,\n            hill_coefficients=hills,\n            hill_coefficient_references=HillParameterReferences(\n                kappa=hill_references,\n                iota=hill_references,\n                alpha=hill_references,\n            ),\n        )\n\n    enzyme_reaction_data = {**enzyme_reaction_data, **custom_enzyme_kinetic_data}\n\n    for reac_id in kcat_overwrite:  # noqa: PLC0206\n        if reac_id not in enzyme_reaction_data:\n            reaction = cobra_model.reactions.get_by_id(reac_id)\n            enzyme_identifiers = reaction.gene_reaction_rule.split(\" and \")\n            enzyme_reaction_data[reac_id] = EnzymeReactionData(\n                identifiers=enzyme_identifiers,\n                k_cat=kcat_overwrite[reac_id],\n                k_cat_references=[\n                    ParameterReference(database=\"OVERWRITE\", tax_distance=-1)\n                ],\n                k_ms={},\n                k_is={},\n            )\n\n    return enzyme_reaction_data\n</code></pre>"},{"location":"api.html#cobrak.spreadsheet_functionality","title":"<code>spreadsheet_functionality</code>","text":"<p>Functions for generating spreadsheet overviews of variability/optimization results</p>"},{"location":"api.html#cobrak.spreadsheet_functionality.ABS_EPSILON","title":"<code>ABS_EPSILON = 1e-12</code>  <code>module-attribute</code>","text":"<p>Lower absolute values are shown as 0 in the spreadsheet</p>"},{"location":"api.html#cobrak.spreadsheet_functionality.EMPTY_CELL","title":"<code>EMPTY_CELL = SpreadsheetCell(None)</code>  <code>module-attribute</code>","text":"<p>Represents an empty spreadsheeet cell without content</p>"},{"location":"api.html#cobrak.spreadsheet_functionality.FONT_BOLD","title":"<code>FONT_BOLD = Font(name='Calibri', bold=True)</code>  <code>module-attribute</code>","text":"<p>Bold font for spreadsheet cells</p>"},{"location":"api.html#cobrak.spreadsheet_functionality.FONT_BOLD_AND_UNDERLINED","title":"<code>FONT_BOLD_AND_UNDERLINED = Font(name='Calibri', bold=True, underline='single')</code>  <code>module-attribute</code>","text":"<p>Bold and underlined font for spreadsheet cells</p>"},{"location":"api.html#cobrak.spreadsheet_functionality.FONT_DEFAULT","title":"<code>FONT_DEFAULT = Font(name='Calibri')</code>  <code>module-attribute</code>","text":"<p>Default font for spreadsheet cells</p>"},{"location":"api.html#cobrak.spreadsheet_functionality.WIDTH_DEFAULT","title":"<code>WIDTH_DEFAULT = 12</code>  <code>module-attribute</code>","text":"<p>Default spreadsheel column width</p>"},{"location":"api.html#cobrak.spreadsheet_functionality.OptimizationDataset","title":"<code>OptimizationDataset</code>  <code>dataclass</code>","text":"<p>Represents an optimization result and which of its data shall be shown in the spreadsheet</p> Source code in <code>cobrak/spreadsheet_functionality.py</code> <pre><code>@dataclass\nclass OptimizationDataset:\n    \"\"\"Represents an optimization result and which of its data shall be shown in the spreadsheet\"\"\"\n\n    data: dict[str, float]\n    \"\"\"The optimization result\"\"\"\n    with_df: bool = False\n    \"\"\"Shall driving forces be shown in the spreadsheet?\"\"\"\n    with_vplus: bool = False\n    \"\"\"Shall V+ values be shown in the spreadsheet?\"\"\"\n    with_kappa: bool = False\n    \"\"\"Shall saturation term values be shown in the spreadsheet?\"\"\"\n    with_gamma: bool = False\n    \"\"\"Shall gamma values be shown in the spreadsheet?\"\"\"\n    with_iota: bool = False\n    \"\"\"Shall iota values (inhibition terms) be shown in the spreadsheet?\"\"\"\n    with_alpha: bool = False\n    \"\"\"Shall alpha values (activation terms) be shown in the spreadsheet?\"\"\"\n    with_kinetic_differences: bool = False\n    \"\"\"Shall differences between NLP fluxes and 'real' fluxes from kinetics be shown in the spreadsheet?\"\"\"\n    with_error_corrections: bool = False\n    \"\"\"Shall error corrections be shown as their own sheet?\"\"\"\n</code></pre>"},{"location":"api.html#cobrak.spreadsheet_functionality.OptimizationDataset.data","title":"<code>data</code>  <code>instance-attribute</code>","text":"<p>The optimization result</p>"},{"location":"api.html#cobrak.spreadsheet_functionality.OptimizationDataset.with_alpha","title":"<code>with_alpha = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Shall alpha values (activation terms) be shown in the spreadsheet?</p>"},{"location":"api.html#cobrak.spreadsheet_functionality.OptimizationDataset.with_df","title":"<code>with_df = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Shall driving forces be shown in the spreadsheet?</p>"},{"location":"api.html#cobrak.spreadsheet_functionality.OptimizationDataset.with_error_corrections","title":"<code>with_error_corrections = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Shall error corrections be shown as their own sheet?</p>"},{"location":"api.html#cobrak.spreadsheet_functionality.OptimizationDataset.with_gamma","title":"<code>with_gamma = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Shall gamma values be shown in the spreadsheet?</p>"},{"location":"api.html#cobrak.spreadsheet_functionality.OptimizationDataset.with_iota","title":"<code>with_iota = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Shall iota values (inhibition terms) be shown in the spreadsheet?</p>"},{"location":"api.html#cobrak.spreadsheet_functionality.OptimizationDataset.with_kappa","title":"<code>with_kappa = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Shall saturation term values be shown in the spreadsheet?</p>"},{"location":"api.html#cobrak.spreadsheet_functionality.OptimizationDataset.with_kinetic_differences","title":"<code>with_kinetic_differences = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Shall differences between NLP fluxes and 'real' fluxes from kinetics be shown in the spreadsheet?</p>"},{"location":"api.html#cobrak.spreadsheet_functionality.OptimizationDataset.with_vplus","title":"<code>with_vplus = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Shall V+ values be shown in the spreadsheet?</p>"},{"location":"api.html#cobrak.spreadsheet_functionality.SpreadsheetCell","title":"<code>SpreadsheetCell</code>  <code>dataclass</code>","text":"<p>Represents the content of a spreadsheet cell.</p> <p>Includes the shown value, background color, font style and border setting.</p> Source code in <code>cobrak/spreadsheet_functionality.py</code> <pre><code>@dataclass\nclass SpreadsheetCell:\n    \"\"\"Represents the content of a spreadsheet cell.\n\n    Includes the shown value, background color, font style\n    and border setting.\n    \"\"\"\n\n    value: float | str | int | bool | None\n    \"\"\"The cell's shown content value (if None, nothing is shown)\"\"\"\n    bg_color: PatternFill = field(default=BG_COLOR_DEFAULT)\n    \"\"\"The cell's background color (default: BG_COLOR_DEFAULT)\"\"\"\n    font: Font = field(default=FONT_DEFAULT)\n    \"\"\"The cell's font style (default: FONT_DEFAULT)\"\"\"\n    border: Border | None = field(default=None)\n    \"\"\"The cell's border style (None if no style given; default: None)\"\"\"\n</code></pre>"},{"location":"api.html#cobrak.spreadsheet_functionality.SpreadsheetCell.bg_color","title":"<code>bg_color = field(default=BG_COLOR_DEFAULT)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The cell's background color (default: BG_COLOR_DEFAULT)</p>"},{"location":"api.html#cobrak.spreadsheet_functionality.SpreadsheetCell.border","title":"<code>border = field(default=None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The cell's border style (None if no style given; default: None)</p>"},{"location":"api.html#cobrak.spreadsheet_functionality.SpreadsheetCell.font","title":"<code>font = field(default=FONT_DEFAULT)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The cell's font style (default: FONT_DEFAULT)</p>"},{"location":"api.html#cobrak.spreadsheet_functionality.SpreadsheetCell.value","title":"<code>value</code>  <code>instance-attribute</code>","text":"<p>The cell's shown content value (if None, nothing is shown)</p>"},{"location":"api.html#cobrak.spreadsheet_functionality.Title","title":"<code>Title</code>  <code>dataclass</code>","text":"<p>Represents a title or metatitle used in visualizations.</p> Source code in <code>cobrak/spreadsheet_functionality.py</code> <pre><code>@dataclass\nclass Title:\n    \"\"\"Represents a title or metatitle used in visualizations.\"\"\"\n\n    text: str\n    \"\"\"Title text content\"\"\"\n    width: float\n    \"\"\"With of column\"\"\"\n    is_metatitle: bool = field(default=False)\n    \"\"\"If True, the title is shown *under* a the major title line in a second line. Defaults to False.\"\"\"\n</code></pre>"},{"location":"api.html#cobrak.spreadsheet_functionality.Title.is_metatitle","title":"<code>is_metatitle = field(default=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If True, the title is shown under a the major title line in a second line. Defaults to False.</p>"},{"location":"api.html#cobrak.spreadsheet_functionality.Title.text","title":"<code>text</code>  <code>instance-attribute</code>","text":"<p>Title text content</p>"},{"location":"api.html#cobrak.spreadsheet_functionality.Title.width","title":"<code>width</code>  <code>instance-attribute</code>","text":"<p>With of column</p>"},{"location":"api.html#cobrak.spreadsheet_functionality.VariabilityDataset","title":"<code>VariabilityDataset</code>  <code>dataclass</code>","text":"<p>Represents a dataset with variability for plotting, including error bars or ranges.</p> Source code in <code>cobrak/spreadsheet_functionality.py</code> <pre><code>@dataclass\nclass VariabilityDataset:\n    \"\"\"Represents a dataset with variability for plotting, including error bars or ranges.\"\"\"\n\n    data: dict[str, tuple[float, float]]\n    \"\"\"The variability data dict, as returned by COBRAk's variability functions\"\"\"\n    with_df: bool = False\n    \"\"\"Shall driving force variabilities be shown?\"\"\"\n</code></pre>"},{"location":"api.html#cobrak.spreadsheet_functionality.VariabilityDataset.data","title":"<code>data</code>  <code>instance-attribute</code>","text":"<p>The variability data dict, as returned by COBRAk's variability functions</p>"},{"location":"api.html#cobrak.spreadsheet_functionality.VariabilityDataset.with_df","title":"<code>with_df = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Shall driving force variabilities be shown?</p>"},{"location":"api.html#cobrak.spreadsheet_functionality.create_cobrak_spreadsheet","title":"<code>create_cobrak_spreadsheet(path, cobrak_model, variability_datasets, optimization_datasets, is_maximization=True, sheet_description=[], min_var_value=1e-06, min_rel_correction=0.01, kinetic_difference_precision=6, objective_overwrite=None, extra_optstatistics_data={})</code>","text":"<p>Generates a comprehensive Excel spreadsheet summarizing variability and optimization results for a COBRAk model.</p> <p>This function creates an Excel file that organizes and visualizes various aspects of the model's reactions, metabolites, enzymes, and optimization results. It includes multiple sheets, each focusing on different components of the model and their corresponding data.</p> <p>In particular, the generated Excel workbook includes the following sheets:</p> <ol> <li>Index: Provides an overview of the different sections in the spreadsheet.</li> <li>A) Optimization statistics: Displays statistical summaries of the optimization results, including objective values, solver status, and flux comparisons.</li> <li>B) Model settings: Lists the model's parameters such as protein pool, gas constant, temperature, and annotations.</li> <li>C) Reactions: Details each reaction's properties, including reaction strings, \u0394G'\u00b0 values, enzyme associations, and kinetic parameters.</li> <li>D) Metabolites: Shows metabolite concentrations, their ranges, and annotations.</li> <li>E) Enzymes: Lists individual enzymes with their molecular weights and concentration ranges.</li> <li>F) Complexes: Provides information on enzyme complexes, including associated reactions and molecular weights.</li> <li>G) Corrections (optional): If error corrections are included in the optimization datasets, this sheet displays the corrections applied.</li> </ol> <p>Each sheet is populated with data from the provided variability and optimization datasets, formatted for readability with appropriate styling, including background colors and borders to highlight important information.</p> <p>The function also handles various edge cases, such as missing data and low-flux reactions, ensuring that the spreadsheet remains organized and informative.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The file path where the Excel workbook will be saved.</p> required <code>cobrak_model</code> <code>Model</code> <p>The COBRAk model containing reactions, metabolites, and enzymes.</p> required <code>variability_datasets</code> <code>dict[str, VariabilityDataset]</code> <p>A dictionary of variability datasets, where each key is a dataset name and the value contains                                                  the data and flags for what to display.</p> required <code>optimization_datasets</code> <code>dict[str, OptimizationDataset]</code> <p>A dictionary of optimization results, where each key is a dataset name and the value contains                                                     the optimization data and flags for what to display.</p> required <code>is_maximization</code> <code>bool</code> <p>Indicates whether the optimization is a maximization problem. Defaults to True.</p> <code>True</code> <code>sheet_description</code> <code>list[str]</code> <p>A list of description lines to include in the index sheet. Defaults to an empty list.</p> <code>[]</code> <code>min_var_value</code> <code>float</code> <p>Where applicable (e.g. for fluxes), the minimum value to display a variable's value. Does not apply for error correction value (see next argument for that.                              Defaults to 1e-6.</p> <code>1e-06</code> <code>min_rel_correction</code> <code>float</code> <p>Minimal relative change to associated original value for which an error correction value is shown.</p> <code>0.01</code> <code>kinetic_difference_precision</code> <code>int</code> <p>The number of decimal places to round kinetic differences. Defaults to 6.</p> <code>6</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>The function does not return any value but saves the Excel workbook to the specified path.</p> Source code in <code>cobrak/spreadsheet_functionality.py</code> <pre><code>@validate_call\ndef create_cobrak_spreadsheet(\n    path: str,\n    cobrak_model: Model,\n    variability_datasets: dict[str, VariabilityDataset],\n    optimization_datasets: dict[str, OptimizationDataset],\n    is_maximization: bool = True,\n    sheet_description: list[str] = [],\n    min_var_value: float = 1e-6,\n    min_rel_correction: float = 0.01,\n    kinetic_difference_precision: int = 6,\n    objective_overwrite: None | str = None,\n    extra_optstatistics_data: dict[str, list[str | float | int | bool | None]] = {},\n) -&gt; None:\n    \"\"\"Generates a comprehensive Excel spreadsheet summarizing variability and optimization results for a COBRAk model.\n\n    This function creates an Excel file that organizes and visualizes various aspects of the model's reactions, metabolites, enzymes, and optimization results.\n    It includes multiple sheets, each focusing on different components of the model and their corresponding data.\n\n    In particular, the generated Excel workbook includes the following sheets:\n\n    1. **Index**: Provides an overview of the different sections in the spreadsheet.\n    2. **A) Optimization statistics**: Displays statistical summaries of the optimization results, including objective values, solver status, and flux comparisons.\n    3. **B) Model settings**: Lists the model's parameters such as protein pool, gas constant, temperature, and annotations.\n    4. **C) Reactions**: Details each reaction's properties, including reaction strings, \u0394G'\u00b0 values, enzyme associations, and kinetic parameters.\n    5. **D) Metabolites**: Shows metabolite concentrations, their ranges, and annotations.\n    6. **E) Enzymes**: Lists individual enzymes with their molecular weights and concentration ranges.\n    7. **F) Complexes**: Provides information on enzyme complexes, including associated reactions and molecular weights.\n    8. **G) Corrections (optional)**: If error corrections are included in the optimization datasets, this sheet displays the corrections applied.\n\n    Each sheet is populated with data from the provided variability and optimization datasets, formatted for readability with appropriate styling,\n    including background colors and borders to highlight important information.\n\n    The function also handles various edge cases, such as missing data and low-flux reactions, ensuring that the spreadsheet remains organized and informative.\n\n    Args:\n        path (str): The file path where the Excel workbook will be saved.\n        cobrak_model (Model): The COBRAk model containing reactions, metabolites, and enzymes.\n        variability_datasets (dict[str, VariabilityDataset]): A dictionary of variability datasets, where each key is a dataset name and the value contains\n                                                             the data and flags for what to display.\n        optimization_datasets (dict[str, OptimizationDataset]): A dictionary of optimization results, where each key is a dataset name and the value contains\n                                                                the optimization data and flags for what to display.\n        is_maximization (bool, optional): Indicates whether the optimization is a maximization problem. Defaults to True.\n        sheet_description (list[str], optional): A list of description lines to include in the index sheet. Defaults to an empty list.\n        min_var_value (float, optional): Where applicable (e.g. for fluxes), the minimum value to display a variable's value. Does not apply for error correction value (see next argument for that.\n                                         Defaults to 1e-6.\n        min_rel_correction (float, optional): Minimal relative change to associated original value for which an error correction value is shown.\n        kinetic_difference_precision (int, optional): The number of decimal places to round kinetic differences. Defaults to 6.\n\n    Returns:\n        None: The function does not return any value but saves the Excel workbook to the specified path.\n    \"\"\"\n    all_reac_ids = list(cobrak_model.reactions.keys())\n    all_met_ids = list(cobrak_model.metabolites.keys())\n    all_enzyme_ids = list(cobrak_model.enzymes.keys())\n    all_met_var_ids = [LNCONC_VAR_PREFIX + met_id for met_id in all_met_ids]\n    all_enzcomplex_ids = []\n    for reac_id, reaction in cobrak_model.reactions.items():\n        if reaction.enzyme_reaction_data is None:\n            continue\n        all_enzcomplex_ids.append(get_reaction_enzyme_var_id(reac_id, reaction))\n\n    has_any_vplus = any(\n        opt_data.with_vplus for opt_data in optimization_datasets.values()\n    )\n    has_any_df = any(opt_data.with_vplus for opt_data in optimization_datasets.values())\n    has_any_kappa = any(\n        opt_data.with_kappa for opt_data in optimization_datasets.values()\n    )\n    has_any_gamma = any(\n        opt_data.with_gamma for opt_data in optimization_datasets.values()\n    )\n    has_any_iota = any(\n        opt_data.with_iota for opt_data in optimization_datasets.values()\n    )\n    has_any_alpha = any(\n        opt_data.with_alpha for opt_data in optimization_datasets.values()\n    )\n    has_any_kinetic_differences = any(\n        opt_data.with_kinetic_differences for opt_data in optimization_datasets.values()\n    )\n\n    kappa_gamma_iota_alpha_str_list = []\n    if has_any_kappa:\n        kappa_gamma_iota_alpha_str_list.append(\"\u03ba\")\n    if has_any_gamma:\n        kappa_gamma_iota_alpha_str_list.append(\"\u03b3\")\n    if has_any_iota:\n        kappa_gamma_iota_alpha_str_list.append(\"\u03b9\")\n    if has_any_alpha:\n        kappa_gamma_iota_alpha_str_list.append(\"\u03b1\")\n    kappa_gamma_iota_alpha_str = \"\u22c5\".join(kappa_gamma_iota_alpha_str_list)\n\n    # Index sheet\n    index_titles: list[Title] = []\n    index_cells: dict[str, list[str | float | int | bool | None | SpreadsheetCell]] = {}\n    sheet_line = 1\n    for description_line in sheet_description:\n        index_cells[_num_to_sheet_letter(sheet_line)] = [\n            SpreadsheetCell(\n                description_line,\n            ),\n        ]\n        sheet_line += 1\n\n    if sheet_line == 1:\n        sheet_line = 0  # No description lines provided, first line can be used for A) to ... as following\n    index_cells = {\n        _num_to_sheet_letter(sheet_line + 1): [\n            SpreadsheetCell(\n                \"A) Optimization statistics: Objective values, minimal/maximal occurring kinetic values, ...\",\n            ),\n        ],\n        _num_to_sheet_letter(sheet_line + 2): [\n            SpreadsheetCell(\n                \"B) Global setting: Model settings such as the temperature, protein pool, ...\",\n            ),\n        ],\n        _num_to_sheet_letter(sheet_line + 3): [\n            SpreadsheetCell(\n                \"C) Reactions: Their fluxes, driving forces, kinetic values...\",\n            ),\n        ],\n        _num_to_sheet_letter(sheet_line + 4): [\n            SpreadsheetCell(\n                \"D) Metabolites: Their concentrations, formulas, ...\",\n            ),\n        ],\n        _num_to_sheet_letter(sheet_line + 5): [\n            SpreadsheetCell(\n                \"E) Enzymes: The single enzymes occurring in the model with their concentration settings (if any given)\",\n            ),\n        ],\n        _num_to_sheet_letter(sheet_line + 6): [\n            SpreadsheetCell(\n                \"F) Complexes: The (multi- or single-)enzyme complexes occurring in the model with protein pool fraction data\",\n            ),\n        ],\n    }\n\n    if has_any_kappa or has_any_gamma or has_any_iota or has_any_alpha:\n        index_cells |= {\n            _num_to_sheet_letter(sheet_line + 6): [\n                SpreadsheetCell(\n                    \"F) Complexes: The (multi- or single-)enzyme complexes occurring in the model with protein pool fraction data\",\n                ),\n            ],\n        }\n\n    # Model settings sheet\n    model_titles: list[Title] = []\n    model_cells: dict[str, list[str | float | int | bool | None | SpreadsheetCell]] = {\n        \"A\": [\n            SpreadsheetCell(\"Protein pool [g\u22c5gDW\u207b\u00b9]\", font=FONT_BOLD),\n            SpreadsheetCell(cobrak_model.max_prot_pool),\n        ],\n        \"B\": [\n            SpreadsheetCell(\"R [kJ\u22c5K\u207b\u00b9\u22c5mol\u207b\u00b9)]\", font=FONT_BOLD),\n            SpreadsheetCell(cobrak_model.R),\n        ],\n        \"C\": [\n            SpreadsheetCell(\"T [K]\", font=FONT_BOLD),\n            SpreadsheetCell(cobrak_model.T),\n        ],\n        \"D\": [\n            SpreadsheetCell(\"R\u22c5T [kJ\u22c5mol\u207b\u00b9]\", font=FONT_BOLD),\n            SpreadsheetCell(cobrak_model.R * cobrak_model.T),\n        ],\n        \"E\": [\n            SpreadsheetCell(\"\u03ba-ignored metabolites\", font=FONT_BOLD),\n            SpreadsheetCell(str(cobrak_model.kinetic_ignored_metabolites)),\n        ],\n        \"F\": [\n            SpreadsheetCell(\"Model annotation\", font=FONT_BOLD),\n            SpreadsheetCell(str(cobrak_model.annotation)),\n        ],\n        \"G\": [\n            SpreadsheetCell(\"Maximal concentration sum [M]:\", font=FONT_BOLD),\n            SpreadsheetCell(str(cobrak_model.max_conc_sum)),\n        ],\n    }\n\n    # Statistics sheet\n    comparisons = compare_multiple_results_to_best(\n        cobrak_model,\n        [dataset.data for dataset in optimization_datasets.values()],\n        is_maximization,\n        min_var_value,\n    )\n\n    stats_titles: list[Title] = [Title(\"\", WIDTH_DEFAULT)]\n    stats_cells: dict[str, list[str | float | int | bool | None | SpreadsheetCell]] = {\n        \"0\": [\n            SpreadsheetCell(\n                \"Objective value\"\n                if objective_overwrite is None\n                else f\"{objective_overwrite} value\",\n                font=FONT_BOLD,\n            ),\n        ],\n        \"1\": [\n            SpreadsheetCell(\"Solver status (see COBRAk documentation)\", font=FONT_BOLD),\n        ],\n        \"2\": [\n            SpreadsheetCell(\n                \"Termination condition (see COBRAk documentaiton)\", font=FONT_BOLD\n            ),\n        ],\n    }\n\n    statline = 3\n    if has_any_vplus:\n        stats_cells |= {\n            f\"{statline}\": [\n                SpreadsheetCell(\"Used protein pool [g\u22c5gDW\u207b\u00b9]\", font=FONT_BOLD),\n            ],\n        }\n        statline += 1\n\n    if has_any_df:\n        stats_cells |= {\n            f\"{statline}\": [\n                SpreadsheetCell(\"Min driving force [kJ\u22c5mol\u207b\u00b9]\", font=FONT_BOLD),\n            ],\n            f\"{statline + 1}\": [\n                SpreadsheetCell(\"Max driving force [kJ\u22c5mol\u207b\u00b9]\", font=FONT_BOLD),\n            ],\n            f\"{statline + 2}\": [\n                SpreadsheetCell(\"Mean driving force [kJ\u22c5mol\u207b\u00b9]\", font=FONT_BOLD),\n            ],\n            f\"{statline + 3}\": [\n                SpreadsheetCell(\"Median driving force [kJ\u22c5mol\u207b\u00b9]\", font=FONT_BOLD),\n            ],\n        }\n        statline += 4\n\n    if has_any_gamma:\n        stats_cells |= {\n            f\"{statline}\": [\n                SpreadsheetCell(\"Min \u03b3\", font=FONT_BOLD),\n            ],\n            f\"{statline + 1}\": [\n                SpreadsheetCell(\"Max \u03b3\", font=FONT_BOLD),\n            ],\n            f\"{statline + 2}\": [\n                SpreadsheetCell(\"Mean \u03b3\", font=FONT_BOLD),\n            ],\n            f\"{statline + 3}\": [\n                SpreadsheetCell(\"Median \u03b3\", font=FONT_BOLD),\n            ],\n        }\n        statline += 4\n\n    if has_any_kappa:\n        stats_cells |= {\n            f\"{statline}\": [\n                SpreadsheetCell(\"Min \u03ba\", font=FONT_BOLD),\n            ],\n            f\"{statline + 1}\": [\n                SpreadsheetCell(\"Max \u03ba\", font=FONT_BOLD),\n            ],\n            f\"{statline + 2}\": [\n                SpreadsheetCell(\"Mean \u03ba\", font=FONT_BOLD),\n            ],\n            f\"{statline + 3}\": [\n                SpreadsheetCell(\"Median \u03ba\", font=FONT_BOLD),\n            ],\n        }\n        statline += 4\n\n    if has_any_iota:\n        stats_cells |= {\n            f\"{statline}\": [\n                SpreadsheetCell(\"Min \u03b9\", font=FONT_BOLD),\n            ],\n            f\"{statline + 1}\": [\n                SpreadsheetCell(\"Max \u03b9\", font=FONT_BOLD),\n            ],\n            f\"{statline + 2}\": [\n                SpreadsheetCell(\"Mean \u03b9\", font=FONT_BOLD),\n            ],\n            f\"{statline + 3}\": [\n                SpreadsheetCell(\"Median \u03b9\", font=FONT_BOLD),\n            ],\n        }\n        statline += 4\n\n    if has_any_alpha:\n        stats_cells |= {\n            f\"{statline}\": [\n                SpreadsheetCell(\"Min \u03b1\", font=FONT_BOLD),\n            ],\n            f\"{statline + 1}\": [\n                SpreadsheetCell(\"Max \u03b1\", font=FONT_BOLD),\n            ],\n            f\"{statline + 2}\": [\n                SpreadsheetCell(\"Mean \u03b1\", font=FONT_BOLD),\n            ],\n            f\"{statline + 3}\": [\n                SpreadsheetCell(\"Median \u03b1\", font=FONT_BOLD),\n            ],\n        }\n        statline += 4\n\n    if has_any_kappa or has_any_gamma or has_any_alpha or has_any_iota:\n        stats_cells |= {\n            f\"{statline}\": [\n                SpreadsheetCell(f\"Min {kappa_gamma_iota_alpha_str}\", font=FONT_BOLD),\n            ],\n            f\"{statline + 1}\": [\n                SpreadsheetCell(f\"Max {kappa_gamma_iota_alpha_str}\", font=FONT_BOLD),\n            ],\n            f\"{statline + 2}\": [\n                SpreadsheetCell(f\"Mean {kappa_gamma_iota_alpha_str}\", font=FONT_BOLD),\n            ],\n            f\"{statline + 3}\": [\n                SpreadsheetCell(f\"Median {kappa_gamma_iota_alpha_str}\", font=FONT_BOLD),\n            ],\n        }\n        statline += 4\n\n    stats_cells |= {\n        f\"{statline}\": [\n            SpreadsheetCell(\"Min flux difference to best\", font=FONT_BOLD),\n        ],\n        f\"{statline + 1}\": [\n            SpreadsheetCell(\"Max flux difference to best\", font=FONT_BOLD),\n        ],\n        f\"{statline + 2}\": [\n            SpreadsheetCell(\"Sum of flux differences to best\", font=FONT_BOLD),\n        ],\n        f\"{statline + 3}\": [\n            SpreadsheetCell(\"Mean flux difference to best\", font=FONT_BOLD),\n        ],\n        f\"{statline + 4}\": [\n            SpreadsheetCell(\"Median flux difference to best\", font=FONT_BOLD),\n        ],\n        f\"{statline + 5}\": [\n            SpreadsheetCell(\"Objective difference to best\", font=FONT_BOLD),\n        ],\n        f\"{statline + 6}\": [\n            SpreadsheetCell(\n                \"Only in this to best (regarding active reactions)\", font=FONT_BOLD\n            ),\n        ],\n        f\"{statline + 7}\": [\n            SpreadsheetCell(\n                \"Only in best to this (regarding active reactions)\", font=FONT_BOLD\n            ),\n        ],\n    }\n    statline += 8\n\n    if has_any_kinetic_differences:\n        stats_cells |= {\n            f\"{statline}\": [\n                SpreadsheetCell(\"'Really' used protein pool [g\u22c5gDW\u207b\u00b9]\", font=FONT_BOLD),\n            ]\n        }\n        statline += 1\n\n    for extrai, extratitle in enumerate(extra_optstatistics_data.keys()):\n        stats_cells[f\"{statline + extrai}\"] = [\n            SpreadsheetCell(extratitle, font=FONT_BOLD)\n        ]\n\n    # Optimization data\n    for current_dataset_i, (opt_dataset_name, opt_dataset) in enumerate(\n        optimization_datasets.items()\n    ):\n        statline = 0\n        stats_titles.append(Title(opt_dataset_name, WIDTH_DEFAULT))\n        if objective_overwrite is None:\n            stats_cells[f\"{statline}\"].append(opt_dataset.data[OBJECTIVE_VAR_NAME])\n        else:\n            stats_cells[f\"{statline}\"].append(opt_dataset.data[objective_overwrite])\n        stats_cells[f\"{statline + 1}\"].append(opt_dataset.data[SOLVER_STATUS_KEY])\n        stats_cells[f\"{statline + 2}\"].append(\n            opt_dataset.data[TERMINATION_CONDITION_KEY]\n        )\n        statline += 3\n\n        if PROT_POOL_REAC_NAME in opt_dataset.data:\n            stats_cells[f\"{statline}\"].append(opt_dataset.data[PROT_POOL_REAC_NAME])\n            statline += 1\n        elif has_any_vplus:\n            stats_cells[f\"{statline}\"].append(_get_empty_cell())\n            statline += 1\n\n        if opt_dataset.with_df:\n            df_stats, _, _, _ = get_df_and_efficiency_factors_sorted_lists(\n                cobrak_model,\n                opt_dataset.data,\n                min_var_value,\n            )\n            stats_cells[f\"{statline}\"].append(min(df_stats.values()))\n            stats_cells[f\"{statline + 1}\"].append(max(df_stats.values()))\n            stats_cells[f\"{statline + 2}\"].append(mean(df_stats.values()))\n            stats_cells[f\"{statline + 3}\"].append(median(df_stats.values()))\n            statline += 4\n        elif has_any_df:\n            for line_letter in (f\"{statline + j}\" for j in range(4)):\n                stats_cells[line_letter].append(_get_empty_cell())\n            statline += 4\n\n        if opt_dataset.with_gamma:\n            _, _, gamma_stats, _, _, _ = get_df_and_efficiency_factors_sorted_lists(\n                cobrak_model,\n                opt_dataset.data,\n                min_var_value,\n            )\n            stats_cells[f\"{statline}\"].append(min(gamma_stats.values()))\n            stats_cells[f\"{statline + 1}\"].append(max(gamma_stats.values()))\n            stats_cells[f\"{statline + 2}\"].append(mean(gamma_stats.values()))\n            stats_cells[f\"{statline + 3}\"].append(median(gamma_stats.values()))\n            statline += 4\n        elif has_any_gamma:\n            for line_letter in (f\"{statline + j}\" for j in range(4)):\n                stats_cells[line_letter].append(_get_empty_cell())\n            statline += 4\n\n        if opt_dataset.with_kappa:\n            _, kappa_stats, _, _, _, _ = get_df_and_efficiency_factors_sorted_lists(\n                cobrak_model,\n                opt_dataset.data,\n                min_var_value,\n            )\n            stats_cells[f\"{statline}\"].append(min(kappa_stats.values()))\n            stats_cells[f\"{statline + 1}\"].append(max(kappa_stats.values()))\n            stats_cells[f\"{statline + 2}\"].append(mean(kappa_stats.values()))\n            stats_cells[f\"{statline + 3}\"].append(median(kappa_stats.values()))\n            statline += 4\n        elif has_any_kappa:\n            for line_letter in (f\"{statline + j}\" for j in range(4)):\n                stats_cells[line_letter].append(_get_empty_cell())\n            statline += 4\n\n        if opt_dataset.with_iota:\n            iota_values = [\n                opt_dataset.data[x]\n                for x in opt_dataset.data\n                if x.startswith(IOTA_VAR_PREFIX)\n                and (opt_dataset.data[x[len(IOTA_VAR_PREFIX) :]] &gt; min_var_value)\n            ]\n            stats_cells[f\"{statline}\"].append(min(iota_values))\n            stats_cells[f\"{statline + 1}\"].append(max(iota_values))\n            stats_cells[f\"{statline + 2}\"].append(mean(iota_values))\n            stats_cells[f\"{statline + 3}\"].append(median(iota_values))\n            statline += 4\n        elif has_any_iota:\n            for line_letter in (f\"{statline + j}\" for j in range(4)):\n                stats_cells[line_letter].append(_get_empty_cell())\n            statline += 4\n\n        if opt_dataset.with_alpha:\n            alpha_values = [\n                opt_dataset.data[x]\n                for x in opt_dataset.data\n                if x.startswith(ALPHA_VAR_PREFIX)\n                and (opt_dataset.data[x[len(ALPHA_VAR_PREFIX) :]] &gt; min_var_value)\n            ]\n            stats_cells[f\"{statline}\"].append(min(alpha_values))\n            stats_cells[f\"{statline + 1}\"].append(max(alpha_values))\n            stats_cells[f\"{statline + 2}\"].append(mean(alpha_values))\n            stats_cells[f\"{statline + 3}\"].append(median(alpha_values))\n            statline += 4\n        elif has_any_alpha:\n            for line_letter in (f\"{statline + j}\" for j in range(4)):\n                stats_cells[line_letter].append(_get_empty_cell())\n            statline += 4\n\n        if (\n            opt_dataset.with_kappa\n            or opt_dataset.with_gamma\n            or opt_dataset.with_alpha\n            or opt_dataset.with_iota\n        ):\n            _, _, _, _, _, multiplier_stats = (\n                get_df_and_efficiency_factors_sorted_lists(\n                    cobrak_model,\n                    opt_dataset.data,\n                    min_var_value,\n                )\n            )\n            efficiencies_product_stats_values = [\n                x[0] for x in multiplier_stats.values()\n            ]\n            stats_cells[f\"{statline}\"].append(min(efficiencies_product_stats_values))\n            stats_cells[f\"{statline + 1}\"].append(\n                max(efficiencies_product_stats_values)\n            )\n            stats_cells[f\"{statline + 2}\"].append(\n                mean(efficiencies_product_stats_values)\n            )\n            stats_cells[f\"{statline + 3}\"].append(\n                median(efficiencies_product_stats_values)\n            )\n            statline += 4\n        elif has_any_gamma and has_any_kappa:\n            for line_letter in (f\"{statline + j}\" for j in range(4)):\n                stats_cells[line_letter].append(_get_empty_cell())\n            statline += 4\n\n        if current_dataset_i in comparisons:\n            dataset_comparison_stats, dataset_unique_reacs = comparisons[\n                current_dataset_i\n            ]\n            tempstatline = statline\n            for j, comparison_value in enumerate(dataset_comparison_stats.values()):\n                stats_cells[f\"{statline + j}\"].append(comparison_value)\n                tempstatline = statline + j\n            statline = tempstatline + 1\n            stats_cells[f\"{statline}\"].append(\n                str(list(dataset_unique_reacs.values())[0])\n            )\n            stats_cells[f\"{statline + 1}\"].append(\n                str(list(dataset_unique_reacs.values())[1])\n            )\n            statline += 2\n        else:\n            for line_letter in (f\"{statline + j}\" for j in range(8)):\n                stats_cells[line_letter].append(\"(is best)\")\n            statline += 8\n\n        if opt_dataset.with_kinetic_differences:\n            unoptimized_reactions = get_unoptimized_reactions_in_nlp_solution(\n                cobrak_model,\n                opt_dataset.data,\n                regard_iota=has_any_iota,\n                regard_alpha=has_any_alpha,\n            )\n            prot_pool_sum = 0.0\n            for reac_id, reac_data in cobrak_model.reactions.items():\n                if reac_id not in opt_dataset.data:\n                    continue\n                if opt_dataset.data[reac_id] &lt; min_var_value:\n                    continue\n                if reac_data.enzyme_reaction_data is None:\n                    continue\n                enzyme_var_id = get_reaction_enzyme_var_id(reac_id, reac_data)\n                if enzyme_var_id not in opt_dataset.data:\n                    continue\n                enzyme_conc = opt_dataset.data[enzyme_var_id]\n                mw = get_full_enzyme_mw(cobrak_model, reac_data)\n                if reac_id in unoptimized_reactions:\n                    ratio = (\n                        unoptimized_reactions[reac_id][0]\n                        / unoptimized_reactions[reac_id][1]\n                    )\n                    if ratio &lt; 1.0:\n                        ratio = 1.0\n                    prot_pool_sum += mw * enzyme_conc * (ratio)\n                else:\n                    prot_pool_sum += mw * enzyme_conc\n\n            stats_cells[f\"{statline}\"].append(prot_pool_sum)\n            statline += 1\n        elif has_any_kinetic_differences:\n            stats_cells[f\"{statline}\"].append(\" \")\n            statline += 1\n\n    for extrai, extravalues in enumerate(extra_optstatistics_data.values()):\n        stats_cells[f\"{statline + extrai}\"].extend(\n            [SpreadsheetCell(extravalue) for extravalue in extravalues]\n        )\n\n    # Reaction sheet\n    reac_titles: list[Title] = [\n        Title(\"ID\", WIDTH_DEFAULT),\n        Title(\"String\", WIDTH_DEFAULT),\n        Title(\"\u0394G'\u00b0 [kJ\u22c5mol\u207b\u00b9]\", WIDTH_DEFAULT),\n        Title(\"Enzyme(s)\", WIDTH_DEFAULT),\n        Title(\"kcat [h\u207b\u00b9]\", WIDTH_DEFAULT),\n        Title(\"kms [M]\", WIDTH_DEFAULT),\n        Title(\"kis [M]\", WIDTH_DEFAULT),\n        Title(\"kas [M]\", WIDTH_DEFAULT),\n        Title(\"Hill coefficients [-]\", WIDTH_DEFAULT),\n    ]\n    reac_cells: dict[str, list[str | float | int | bool | None | SpreadsheetCell]] = {\n        reac_id: [] for reac_id in all_reac_ids\n    }\n    # Reaction data\n    for reac_id in all_reac_ids:\n        reaction = cobrak_model.reactions[reac_id]\n        # Reac ID\n        reac_cells[reac_id].append(reac_id)\n        # Reac string\n        reac_cells[reac_id].append(get_reaction_string(cobrak_model, reac_id))\n        # Reac \u0394G'\u00b0\n        reac_cells[reac_id].append(str(_na_str_or_value(reaction.dG0)))\n        enzyme_reaction_data = reaction.enzyme_reaction_data\n        match enzyme_reaction_data:\n            case None:\n                enzyme_id = None\n                k_cat = None\n                k_ms = None\n                k_is = None\n                k_as = None\n                hills = None\n            case _:\n                enzyme_id = str(enzyme_reaction_data.identifiers)\n                k_cat = enzyme_reaction_data.k_cat\n                k_ms = str(enzyme_reaction_data.k_ms)\n                k_is = str(enzyme_reaction_data.k_is)\n                k_as = str(enzyme_reaction_data.k_as)\n                hills = str(enzyme_reaction_data.hill_coefficients)\n        # Enzyme ID\n        reac_cells[reac_id].append(enzyme_id)\n        # kcat\n        reac_cells[reac_id].append(k_cat)\n        # kms\n        reac_cells[reac_id].append(k_ms)\n        # kis\n        reac_cells[reac_id].append(k_is)\n        # kas\n        reac_cells[reac_id].append(k_as)\n        # Hill coefficients\n        reac_cells[reac_id].append(hills)\n\n    # Variability data\n    for var_dataset_name, var_dataset in variability_datasets.items():\n        reac_titles.extend(\n            (\n                Title(var_dataset_name, WIDTH_DEFAULT, is_metatitle=True),\n                Title(\"Min flux [mmol\u22c5gDW\u207b\u00b9\u22c5h\u207b\u00b9]\", WIDTH_DEFAULT),\n                Title(\"Max flux [mmol\u22c5gDW\u207b\u00b9\u22c5h\u207b\u00b9]\", WIDTH_DEFAULT),\n            )\n        )\n        if var_dataset.with_df:\n            reac_titles.extend(\n                (\n                    Title(\"Min driving force [kJ\u22c5mol\u207b\u00b9]\", WIDTH_DEFAULT),\n                    Title(\"Max driving force [kJ\u22c5mol\u207b\u00b9]\", WIDTH_DEFAULT),\n                )\n            )\n        var_reac_ids = set(all_reac_ids) &amp; set(var_dataset.data.keys())\n        for reac_id in var_reac_ids:\n            variability_tuple = var_dataset.data[reac_id]\n            min_flux = variability_tuple[0]\n            max_flux = variability_tuple[1]\n            bg_color = _get_variability_bg_color(min_flux, max_flux)\n            reac_cells[reac_id].append(\n                SpreadsheetCell(min_flux, bg_color=bg_color, border=BORDER_BLACK_LEFT)\n            )\n            reac_cells[reac_id].append(SpreadsheetCell(max_flux, bg_color=bg_color))\n            if var_dataset.with_df:\n                df_var_id = f\"{DF_VAR_PREFIX}{reac_id}\"\n                if df_var_id in var_dataset.data:\n                    min_df = str(round(var_dataset.data[df_var_id][0], 4))\n                    max_df = str(round(var_dataset.data[df_var_id][1], 4))\n                else:\n                    min_df = \" \"\n                    max_df = \" \"\n            else:\n                min_df = \" \"\n                max_df = \" \"\n            reac_cells[reac_id].append(SpreadsheetCell(min_df, bg_color=bg_color))\n            reac_cells[reac_id].append(SpreadsheetCell(max_df, bg_color=bg_color))\n        missing_reac_ids = set(all_reac_ids) - set(var_dataset.data.keys())\n        for missing_reac_id in missing_reac_ids:\n            reac_cells[missing_reac_id].append(_get_empty_cell())\n            reac_cells[missing_reac_id].append(_get_empty_cell())\n            if var_dataset.with_df:\n                reac_cells[missing_reac_id].append(_get_empty_cell())\n                reac_cells[missing_reac_id].append(_get_empty_cell())\n\n    # Optimization data\n    for opt_dataset_name, opt_dataset in optimization_datasets.items():\n        reac_titles.extend(\n            (\n                Title(opt_dataset_name, WIDTH_DEFAULT, is_metatitle=True),\n                Title(\"Flux\", WIDTH_DEFAULT),\n            )\n        )\n        if opt_dataset.with_df:\n            reac_titles.append(Title(\"Driving force [kJ\u22c5mol\u207b\u00b9]\", WIDTH_DEFAULT))\n        if opt_dataset.with_vplus:\n            reac_titles.append(Title(\"V\u207a [mmol\u22c5gDW\u207b\u00b9\u22c5h\u207b\u00b9]\", WIDTH_DEFAULT))\n        if opt_dataset.with_kappa:\n            reac_titles.append(Title(\"\u03ba [0,1]\", WIDTH_DEFAULT))\n        if opt_dataset.with_gamma:\n            reac_titles.append(Title(\"\u03b3 [0,1]\", WIDTH_DEFAULT))\n        if opt_dataset.with_iota:\n            reac_titles.append(Title(\"\u03b9 [0,1]\", WIDTH_DEFAULT))\n        if opt_dataset.with_alpha:\n            reac_titles.append(Title(\"\u03b1 [0,1]\", WIDTH_DEFAULT))\n        if opt_dataset.with_kinetic_differences:\n            reac_titles.append(Title('\"Real\" flux', WIDTH_DEFAULT))\n            unoptimized_reactions = get_unoptimized_reactions_in_nlp_solution(\n                cobrak_model,\n                opt_dataset.data,\n                regard_alpha=True,\n                regard_iota=True,\n            )\n        opt_reac_ids = set(all_reac_ids) &amp; set(opt_dataset.data.keys())\n        reacs_with_too_low_flux = []\n        for reac_id in opt_reac_ids:\n            flux = get_fwd_rev_corrected_flux(\n                reac_id=reac_id,\n                usable_reac_ids=opt_reac_ids,\n                result=opt_dataset.data,\n                fwd_suffix=cobrak_model.fwd_suffix,\n                rev_suffix=cobrak_model.rev_suffix,\n            )\n            if flux &lt; min_var_value:\n                reacs_with_too_low_flux.append(reac_id)\n                continue\n            bg_color = _get_optimization_bg_color(flux)\n            reac_cells[reac_id].append(\n                SpreadsheetCell(flux, bg_color=bg_color, border=BORDER_BLACK_LEFT)\n            )\n            enzyme_reaction_data = cobrak_model.reactions[reac_id].enzyme_reaction_data\n            reaction = cobrak_model.reactions[reac_id]\n            if opt_dataset.with_df:\n                df_var_id = f\"{DF_VAR_PREFIX}{reac_id}\"\n                if df_var_id in opt_dataset.data:\n                    df_value = str(round(opt_dataset.data[df_var_id], 4))\n                else:\n                    df_value = \" \"\n                reac_cells[reac_id].append(SpreadsheetCell(df_value, bg_color=bg_color))\n            if opt_dataset.with_vplus:\n                if enzyme_reaction_data is not None:\n                    vplus = str(\n                        enzyme_reaction_data.k_cat\n                        * opt_dataset.data[\n                            get_reaction_enzyme_var_id(reac_id, reaction)\n                        ]\n                    )\n                else:\n                    vplus = \" \"\n                reac_cells[reac_id].append(SpreadsheetCell(vplus, bg_color=bg_color))\n            if opt_dataset.with_kappa:\n                kappa_var_id = KAPPA_VAR_PREFIX + reac_id\n                if kappa_var_id in opt_dataset.data:\n                    kappa_value = str(round(opt_dataset.data[kappa_var_id], 4))\n                else:\n                    kappa_value = \" \"\n                reac_cells[reac_id].append(\n                    SpreadsheetCell(kappa_value, bg_color=bg_color)\n                )\n            if opt_dataset.with_gamma:\n                gamma_var_id = GAMMA_VAR_PREFIX + reac_id\n                if gamma_var_id in opt_dataset.data:\n                    gamma_value = str(round(opt_dataset.data[gamma_var_id], 4))\n                else:\n                    gamma_value = \" \"\n                reac_cells[reac_id].append(\n                    SpreadsheetCell(gamma_value, bg_color=bg_color)\n                )\n            if opt_dataset.with_iota:\n                iota_var_id = IOTA_VAR_PREFIX + reac_id\n                if iota_var_id in opt_dataset.data:\n                    iota_value = str(opt_dataset.data[iota_var_id])\n                else:\n                    iota_value = \" \"\n                reac_cells[reac_id].append(\n                    SpreadsheetCell(iota_value, bg_color=bg_color)\n                )\n            if opt_dataset.with_alpha:\n                alpha_var_id = ALPHA_VAR_PREFIX + reac_id\n                if alpha_var_id in opt_dataset.data:\n                    alpha_value = str(opt_dataset.data[alpha_var_id])\n                else:\n                    alpha_value = \" \"\n                reac_cells[reac_id].append(\n                    SpreadsheetCell(alpha_value, bg_color=bg_color)\n                )\n            if opt_dataset.with_kinetic_differences:\n                if reac_id in unoptimized_reactions and (\n                    round(\n                        unoptimized_reactions[reac_id][1], kinetic_difference_precision\n                    )\n                    != round(\n                        unoptimized_reactions[reac_id][0], kinetic_difference_precision\n                    )\n                ):\n                    reac_cells[reac_id].append(\n                        SpreadsheetCell(\n                            unoptimized_reactions[reac_id][1], bg_color=bg_color\n                        )\n                    )\n                else:\n                    reac_cells[reac_id].append(\n                        SpreadsheetCell(flux, bg_color=bg_color, font=FONT_ITALIC)\n                    )\n        missing_reac_ids = set(all_reac_ids) - set(opt_dataset.data.keys())\n        missing_reac_ids |= set(reacs_with_too_low_flux)\n        for missing_reac_id in missing_reac_ids:\n            reac_cells[missing_reac_id].append(_get_empty_cell())\n            num_extra = sum(\n                [\n                    opt_dataset.with_df,\n                    opt_dataset.with_vplus,\n                    opt_dataset.with_kappa,\n                    opt_dataset.with_gamma,\n                    opt_dataset.with_iota,\n                    opt_dataset.with_alpha,\n                    opt_dataset.with_kinetic_differences,\n                ]\n            )\n            for _ in range(num_extra):\n                reac_cells[missing_reac_id].append(_get_empty_cell())\n\n    # Single enzyme sheet\n    enzyme_titles: list[Title] = [\n        Title(\"ID\", WIDTH_DEFAULT),\n        Title(\"MW\", WIDTH_DEFAULT),\n        Title(\"Conc. range [mmol\u22c5gDW\u207b\u00b9]\", WIDTH_DEFAULT),\n    ]\n    enzyme_cells: dict[str, list[str | float | int | bool | None | SpreadsheetCell]] = {\n        enzyme_id: [] for enzyme_id in all_enzyme_ids\n    }\n    # Single enzyme data\n    for enzyme_id in all_enzyme_ids:\n        enzyme: Enzyme = cobrak_model.enzymes[enzyme_id]\n        # Enzyme ID\n        enzyme_cells[enzyme_id].append(enzyme_id)\n        # Enzyme MW\n        enzyme_cells[enzyme_id].append(enzyme.molecular_weight)\n        # Enzyme concentration range\n        match enzyme.min_conc:\n            case None:\n                min_conc = None\n                bg_color = BG_COLOR_BLACK\n            case _:\n                min_conc = enzyme.min_conc\n                bg_color = BG_COLOR_DEFAULT\n        match enzyme.max_conc:\n            case None:\n                max_conc = None\n                bg_color = BG_COLOR_BLACK\n            case _:\n                max_conc = enzyme.max_conc\n                bg_color = BG_COLOR_DEFAULT\n\n        enzyme_cells[enzyme_id].append(SpreadsheetCell(min_conc, bg_color=bg_color))\n        enzyme_cells[enzyme_id].append(SpreadsheetCell(min_conc, bg_color=bg_color))\n\n    # Enzyme complexes sheet\n    enzcomplex_titles: list[Title] = [\n        Title(\"ID\", WIDTH_DEFAULT),\n        Title(\"Reactions\", WIDTH_DEFAULT),\n        Title(\"MW\", WIDTH_DEFAULT),\n    ]\n    enzcomplex_cells: dict[\n        str, list[str | float | int | bool | None | SpreadsheetCell]\n    ] = {enzcomplex_id: [] for enzcomplex_id in all_enzcomplex_ids}\n    # Enzyme complex data\n    for enzcomplex_id in all_enzcomplex_ids:\n        reac_id, reaction = _get_enzcomplex_reaction(cobrak_model, enzcomplex_id)\n        # Enzyme complex ID\n        enzcomplex_cells[enzcomplex_id].append(\n            enzcomplex_id.replace(ENZYME_VAR_PREFIX, \"\").split(ENZYME_VAR_INFIX)[0]\n        )\n        # Associated reaction\n        if reaction.enzyme_reaction_data is None:\n            raise ValueError\n        if reaction.enzyme_reaction_data.identifiers == [\"\"]:\n            continue\n        enzcomplex_cells[enzcomplex_id].append(reac_id)\n        # Enzyme complex MW\n        full_mw = get_full_enzyme_mw(cobrak_model, reaction)\n        enzcomplex_cells[enzcomplex_id].append(full_mw)\n\n    # Variability data\n    for var_dataset_name, var_dataset in variability_datasets.items():\n        enzcomplex_titles.extend(\n            (\n                Title(var_dataset_name, WIDTH_DEFAULT, is_metatitle=True),\n                Title(\"Min conc. [mmol\u22c5gDW\u207b\u00b9]\", WIDTH_DEFAULT),\n                Title(\"Max conc. [mmolgDW\u207b\u00b9]\", WIDTH_DEFAULT),\n            )\n        )\n        var_enzcomplex_ids = set(all_enzcomplex_ids) &amp; set(var_dataset.data.keys())\n        for enzcomplex_id in var_enzcomplex_ids:\n            _, reaction = _get_enzcomplex_reaction(cobrak_model, enzcomplex_id)\n            variability_tuple = var_dataset.data[enzcomplex_id]\n            min_conc = variability_tuple[0]\n            max_conc = variability_tuple[1]\n            bg_color = _get_variability_bg_color(min_conc, max_conc)\n            enzcomplex_cells[enzcomplex_id].append(\n                SpreadsheetCell(min_conc, bg_color=bg_color, border=BORDER_BLACK_LEFT)\n            )\n            enzcomplex_cells[enzcomplex_id].append(\n                SpreadsheetCell(max_conc, bg_color=bg_color)\n            )\n        missing_enzcomplex_ids = set(all_enzcomplex_ids) - set(var_dataset.data.keys())\n        for missing_enzcomplex_id in missing_enzcomplex_ids:\n            enzcomplex_cells[missing_enzcomplex_id].append(_get_empty_cell())\n            enzcomplex_cells[missing_enzcomplex_id].append(_get_empty_cell())\n\n    # Enzyme complex data\n    for opt_dataset_name, opt_dataset in optimization_datasets.items():\n        enzcomplex_titles.extend(\n            (\n                Title(opt_dataset_name, WIDTH_DEFAULT, is_metatitle=True),\n                Title(\"Concentration [mmol\u22c5gDW\u207b\u00b9]\", WIDTH_DEFAULT),\n                Title(\"% of pool\", WIDTH_DEFAULT),\n            )\n        )\n        opt_enzcomplex_ids = set(all_enzcomplex_ids) &amp; set(opt_dataset.data.keys())\n        for enzcomplex_id in opt_enzcomplex_ids:\n            _, reaction = _get_enzcomplex_reaction(cobrak_model, enzcomplex_id)\n            complexconc = opt_dataset.data[enzcomplex_id]\n            pool_pct = (\n                100\n                * complexconc\n                * get_full_enzyme_mw(cobrak_model, reaction)\n                / cobrak_model.max_prot_pool\n            )\n            bg_color = _get_optimization_bg_color(complexconc)\n            enzcomplex_cells[enzcomplex_id].append(\n                SpreadsheetCell(\n                    complexconc, bg_color=bg_color, border=BORDER_BLACK_LEFT\n                )\n            )\n            enzcomplex_cells[enzcomplex_id].append(\n                SpreadsheetCell(round(pool_pct, 4), bg_color=bg_color)\n            )\n        missing_enzcomplex_ids = set(all_enzcomplex_ids) - set(opt_dataset.data.keys())\n        for missing_enzcomplex_id in missing_enzcomplex_ids:\n            enzcomplex_cells[missing_enzcomplex_id].append(_get_empty_cell())\n            enzcomplex_cells[missing_enzcomplex_id].append(_get_empty_cell())\n\n    # Metabolite sheet\n    met_titles: list[Title] = [\n        Title(\"ID\", WIDTH_DEFAULT),\n        Title(\"Min set concentration [mmol\u22c5gDW\u207b\u00b9\u22c5h\u207b\u00b9)]\", WIDTH_DEFAULT),\n        Title(\"Max set concentration [mmolgDW\u207b\u00b9\u22c5h\u207b\u00b9)]\", WIDTH_DEFAULT),\n        Title(\"Annotation\", WIDTH_DEFAULT),\n    ]\n    met_cells: dict[str, list[str | float | int | bool | None | SpreadsheetCell]] = {\n        met_id: [] for met_id in all_met_ids\n    }\n    # Metabolite data\n    for met_id in all_met_ids:\n        met: Metabolite = cobrak_model.metabolites[met_id]\n        # Met ID\n        met_cells[met_id].append(met_id)\n        # Min conc\n        met_cells[met_id].append(exp(met.log_min_conc))\n        # Max conc\n        met_cells[met_id].append(exp(met.log_max_conc))\n        # Annotation\n        met_cells[met_id].append(str(met.annotation))\n\n    # Variability data\n    for var_dataset_name, var_dataset in variability_datasets.items():\n        met_titles.extend(\n            (\n                Title(var_dataset_name, WIDTH_DEFAULT, is_metatitle=True),\n                Title(\"Min concentration [mmol\u22c5gDW\u207b\u00b9\u22c5h\u207b\u00b9)]\", WIDTH_DEFAULT),\n                Title(\"Max concentration [mmol\u22c5gDW\u207b\u00b9\u22c5h\u207b\u00b9)]\", WIDTH_DEFAULT),\n            )\n        )\n        all_met_var_ids = [LNCONC_VAR_PREFIX + met_id for met_id in all_met_ids]\n        var_met_ids = set(all_met_var_ids) &amp; set(var_dataset.data.keys())\n        for met_var_id in var_met_ids:\n            variability_tuple = var_dataset.data[met_var_id]\n            min_conc = exp(variability_tuple[0])\n            max_conc = exp(variability_tuple[1])\n            bg_color = BG_COLOR_RED if min_conc == max_conc else BG_COLOR_GREEN\n            met_cells[_get_met_id_from_met_var_id(met_var_id)].append(\n                SpreadsheetCell(min_conc, bg_color=bg_color, border=BORDER_BLACK_LEFT)\n            )\n            met_cells[_get_met_id_from_met_var_id(met_var_id)].append(\n                SpreadsheetCell(max_conc, bg_color=bg_color)\n            )\n        missing_met_var_ids = set(all_met_var_ids) - set(var_dataset.data.keys())\n        for missing_met_var_id in missing_met_var_ids:\n            met_cells[_get_met_id_from_met_var_id(missing_met_var_id)].append(\n                _get_empty_cell()\n            )\n            met_cells[_get_met_id_from_met_var_id(missing_met_var_id)].append(\n                _get_empty_cell()\n            )\n\n    # Optimization data\n    for opt_dataset_name, opt_dataset in optimization_datasets.items():\n        met_titles.extend(\n            (\n                Title(opt_dataset_name, WIDTH_DEFAULT, is_metatitle=True),\n                Title(\"Concentration [M]\", WIDTH_DEFAULT),\n                Title(\"Consumption [mmol\u22c5gDW\u207b\u00b9\u22c5h\u207b\u00b9]\", WIDTH_DEFAULT),\n                Title(\"Production [mmol\u22c5gDW\u207b\u00b9\u22c5h\u207b\u00b9]\", WIDTH_DEFAULT),\n            )\n        )\n        opt_met_ids = set(all_met_var_ids) &amp; set(opt_dataset.data.keys())\n        for met_var_id in opt_met_ids:\n            conc = exp(opt_dataset.data[met_var_id])\n            consumption, production = get_metabolite_consumption_and_production(\n                cobrak_model, _get_met_id_from_met_var_id(met_var_id), opt_dataset.data\n            )\n            bg_color = _get_optimization_bg_color(consumption)\n            met_cells[_get_met_id_from_met_var_id(met_var_id)].append(\n                SpreadsheetCell(conc, bg_color=bg_color, border=BORDER_BLACK_LEFT)\n            )\n            met_cells[_get_met_id_from_met_var_id(met_var_id)].append(\n                SpreadsheetCell(consumption, bg_color=bg_color)\n            )\n            met_cells[_get_met_id_from_met_var_id(met_var_id)].append(\n                SpreadsheetCell(production, bg_color=bg_color)\n            )\n        missing_met_ids = set(all_met_var_ids) - set(opt_dataset.data.keys())\n        for missing_met_id in missing_met_ids:\n            for _ in range(3):\n                met_cells[_get_met_id_from_met_var_id(missing_met_id)].append(\n                    _get_empty_cell()\n                )\n\n    # \u03ba and \u03b3 statistics\n    kgstats_titles: list[Title] = [Title(\"Rank\", WIDTH_DEFAULT, is_metatitle=False)]\n    kgstats_cells: dict[\n        str, list[str | float | int | bool | None | SpreadsheetCell]\n    ] = {str(i): [i + 1] for i in range(len(cobrak_model.reactions))}\n    for opt_dataset_name, opt_dataset in optimization_datasets.items():\n        kgstats_titles.extend(\n            (\n                Title(opt_dataset_name, WIDTH_DEFAULT, is_metatitle=True),\n                Title(\"Reaction ID\", WIDTH_DEFAULT),\n                Title(\"\u03ba\", WIDTH_DEFAULT),\n                Title(\"Reaction ID\", WIDTH_DEFAULT),\n                Title(\"\u03b3\", WIDTH_DEFAULT),\n                Title(\"Reaction ID\", WIDTH_DEFAULT),\n                Title(\"\u03b9\", WIDTH_DEFAULT),\n                Title(\"Reaction ID\", WIDTH_DEFAULT),\n                Title(\"\u03b1\", WIDTH_DEFAULT),\n                Title(\"Reaction ID\", WIDTH_DEFAULT),\n                Title(kappa_gamma_iota_alpha_str, WIDTH_DEFAULT),\n            )\n        )\n\n        _, kappa_stats, gamma_stats, iota_stats, alpha_stats, multiplier_stats = (\n            get_df_and_efficiency_factors_sorted_lists(\n                cobrak_model,\n                opt_dataset.data,\n                min_var_value,\n            )\n        )\n        kappa_stats_titles = list(kappa_stats.keys())\n        gamma_stats_titles = list(gamma_stats.keys())\n        iota_stats_titles = list(iota_stats.keys())\n        alpha_stats_titles = list(alpha_stats.keys())\n        kappa_times_gamma_stats_titles = list(multiplier_stats.keys())\n        for key, cell_list in kgstats_cells.items():\n            # \u03ba\n            if len(kappa_stats_titles) &gt; int(key):\n                cell_list.extend(\n                    (\n                        kappa_stats_titles[int(key)],\n                        kappa_stats[kappa_stats_titles[int(key)]],\n                    )\n                )\n            else:\n                cell_list.extend((None, None))\n            # \u03b3\n            if len(gamma_stats_titles) &gt; int(key):\n                cell_list.extend(\n                    (\n                        gamma_stats_titles[int(key)],\n                        gamma_stats[gamma_stats_titles[int(key)]],\n                    )\n                )\n            else:\n                cell_list.extend((None, None))\n            # \u03b9\n            if len(iota_stats_titles) &gt; int(key):\n                cell_list.extend(\n                    (\n                        iota_stats_titles[int(key)],\n                        iota_stats[iota_stats_titles[int(key)]],\n                    )\n                )\n            else:\n                cell_list.extend((None, None))\n            # \u03b1\n            if len(alpha_stats_titles) &gt; int(key):\n                cell_list.extend(\n                    (\n                        alpha_stats_titles[int(key)],\n                        alpha_stats[alpha_stats_titles[int(key)]],\n                    )\n                )\n            else:\n                cell_list.extend((None, None))\n            # \u03ba\u22c5\u03b3\u22c5\u03b9\u22c5\u03b1\n            if len(kappa_times_gamma_stats_titles) &gt; int(key):\n                cell_list.extend(\n                    (\n                        kappa_times_gamma_stats_titles[int(key)],\n                        multiplier_stats[kappa_times_gamma_stats_titles[int(key)]][0],\n                    )\n                )\n            else:\n                cell_list.extend((None, None))\n\n    titles_and_data_dict: dict[\n        str,\n        tuple[\n            list[Title],\n            dict[str, list[str | float | int | bool | None | SpreadsheetCell]],\n        ],\n    ] = {\n        \"Index\": (index_titles, index_cells),\n        \"A) Optimization statistics\": (stats_titles, stats_cells),\n        \"B) Model settings\": (model_titles, model_cells),\n        \"C) Reactions\": (reac_titles, reac_cells),\n        \"D) Metabolites\": (met_titles, met_cells),\n        \"E) Enzymes\": (enzyme_titles, enzyme_cells),\n        \"F) Complexes\": (enzcomplex_titles, enzcomplex_cells),\n    }\n    if has_any_gamma or has_any_kappa:\n        titles_and_data_dict |= {\n            \"G) Efficiency factor statistics\": (kgstats_titles, kgstats_cells),\n        }\n\n    # Correction data (if given)\n    correction_titles: list[Title] = [\n        Title(\"Affected parameter\", WIDTH_DEFAULT),\n        Title(\"Original value\", WIDTH_DEFAULT),\n    ]\n    correction_cells: dict[\n        str, list[str | float | int | bool | None | SpreadsheetCell]\n    ] = {}\n\n    num_processed_datasets = 0\n    for opt_dataset_name, opt_dataset in optimization_datasets.items():\n        if not opt_dataset.with_error_corrections:\n            num_processed_datasets += 1\n            continue\n        correction_titles.append(Title(opt_dataset_name, WIDTH_DEFAULT))\n\n        for var_name, var_value in opt_dataset.data.items():\n            displayed_var = var_name.replace(ERROR_VAR_PREFIX + \"_\", \"\")\n            if not var_name.startswith(ERROR_VAR_PREFIX):\n                if displayed_var in correction_cells:\n                    correction_cells[displayed_var].append(None)\n                continue\n\n            round_value = 12\n            is_dataset_dependent: bool = False\n            is_relative: bool = True\n            original_value: float = 0.0\n            if \"kcat_times_e_\" in displayed_var:\n                reac_id = displayed_var.split(\"kcat_times_e_\")[1]\n                enzyme_id = get_reaction_enzyme_var_id(\n                    reac_id, cobrak_model.reactions[reac_id]\n                )\n                original_value = (\n                    cobrak_model.reactions[reac_id].enzyme_reaction_data.k_cat\n                    * opt_dataset.data[enzyme_id]\n                )\n                displayed_original_value = \"(see comments)\"\n                error_value = var_value - original_value\n                is_dataset_dependent = True\n            elif displayed_var.endswith((\"_substrate\", \"_product\")):\n                reac_id = displayed_var.split(\"____\")[0]\n                met_id = (\n                    displayed_var.split(\"____\")[1]\n                    .replace(\"_substrate\", \"\")\n                    .replace(\"_product\", \"\")\n                )\n                original_value = cobrak_model.reactions[\n                    reac_id\n                ].enzyme_reaction_data.k_ms[met_id]\n                displayed_original_value = original_value\n                error_mult = +1 if displayed_var.endswith(\"_product\") else -1\n                error_value = error_mult * -(\n                    original_value - exp(log(original_value) + error_mult * var_value)\n                )\n                round_value = 12\n                if displayed_var.endswith(\"_substrate\"):\n                    print(\n                        displayed_var,\n                        original_value,\n                        error_value,\n                        abs(error_value) / original_value,\n                    )\n            elif displayed_var.startswith(\"dG0_\"):\n                reac_id = displayed_var[len(\"dG0_\") :]\n                original_value = cobrak_model.reactions[reac_id].dG0\n                is_relative = False\n            elif displayed_var.endswith((\"_plus\", \"_minus\")):\n                valueblock = displayed_var.split(\"_origstart_\")[1].split(\"_origend_\")[0]\n                min_value = float(valueblock.split(\"__\")[0].replace(\"-\", \".\"))\n                max_value = float(valueblock.split(\"__\")[1].replace(\"-\", \".\"))\n                displayed_original_value = f\"({min_value}, {max_value}\"\n                min_difference = abs(var_value - min_value)\n                max_difference = abs(var_value - max_value)\n                original_value = (\n                    min_value if min_difference &lt; max_difference else max_value\n                )\n                error_value = min(max_difference, min_difference)\n            else:\n                continue\n\n            if not is_relative:\n                print(displayed_var, error_value, original_value)\n            if not (\n                is_relative and (error_value / original_value) &gt;= min_rel_correction\n            ) or (not is_relative and error_value &gt;= min_var_value):\n                if displayed_var in correction_cells:\n                    correction_cells[displayed_var].append(None)\n                continue\n\n            if displayed_var not in correction_cells:\n                correction_cells[displayed_var] = [\n                    displayed_var,\n                    displayed_original_value,\n                ] + [None for _ in range(num_processed_datasets)]\n            correction_cells[displayed_var].append(\n                f\"{round(error_value, round_value)}{f' from {round(original_value, round_value)}' if is_dataset_dependent else ''}\"\n            )\n\n        num_processed_datasets += 1\n\n    if correction_cells != {}:\n        titles_and_data_dict[\n            f\"{'H' if has_any_alpha or has_any_iota or has_any_gamma or has_any_kappa else 'G'}) Corrections\"\n        ] = (correction_titles, correction_cells)\n\n    _create_xlsx_from_datadicts(\n        path=path,\n        titles_and_data_dict=titles_and_data_dict,\n    )\n</code></pre>"},{"location":"api.html#cobrak.standard_solvers","title":"<code>standard_solvers</code>","text":"<p>Includes definitions of some (MI)LP and NLP solvers.</p> <p>Instead of these pre-definitions, you can also use pyomo's solver definitions.</p>"},{"location":"api.html#cobrak.tellurium_functionality","title":"<code>tellurium_functionality</code>","text":"<p>Functions for exporting COBRA-k model and solution to a kinetic model with the help of Tellurium.</p> <p>Note: Tellurium's description language for kinetic models is called 'Antimony'.</p>"},{"location":"api.html#cobrak.tellurium_functionality.get_tellurium_string_from_cobrak_model_and_solution","title":"<code>get_tellurium_string_from_cobrak_model_and_solution(cobrak_model, cell_density, e_concs, met_concs, nlp_results)</code>","text":"<p>Convert a complete COBRA\u2011k model and its optimisation solution into an Antimony string that can be loaded by Tellurium.</p> <p>The function iterates over all reactions, skips those with negligible net flux, and concatenates the Antimony fragments produced by :func:<code>_get_reaction_string_of_cobrak_reaction</code>.  After processing reactions, it adds definitions for metabolites (either user\u2011provided concentrations or concentrations inferred from the NLP solution) and the global constants <code>R</code> and <code>T</code>.</p>"},{"location":"api.html#cobrak.tellurium_functionality.get_tellurium_string_from_cobrak_model_and_solution--parameters","title":"Parameters","text":"<p>cobrak_model : Model     The COBRA\u2011k model containing reactions, metabolites, and model\u2011wide     parameters. cell_density : float     Cell density (g\u202fL\u207b\u00b9) used to convert between substance\u2011only and molar     concentrations. e_concs : dict[str, float]     Optional enzyme concentrations keyed by reaction ID. Missing entries     default to <code>1.0</code>. met_concs : dict[str, float]     Optional metabolite concentrations (mol\u202fL\u207b\u00b9) keyed by metabolite ID. nlp_results : dict[str, float]     Optimisation variables returned by the NLP solver (log\u2011concentrations,     fluxes, etc.).</p>"},{"location":"api.html#cobrak.tellurium_functionality.get_tellurium_string_from_cobrak_model_and_solution--returns","title":"Returns","text":"<p>str     A complete Antimony model string ready for <code>tellurium.loada</code>.</p> Source code in <code>cobrak/tellurium_functionality.py</code> <pre><code>@validate_call(validate_return=True)\ndef get_tellurium_string_from_cobrak_model_and_solution(\n    cobrak_model: Model,\n    cell_density: float,\n    e_concs: dict[str, float],\n    met_concs: dict[str, float],\n    nlp_results: dict[str, float],\n) -&gt; str:\n    \"\"\"Convert a complete COBRA\u2011k model and its optimisation solution into an\n    Antimony string that can be loaded by Tellurium.\n\n    The function iterates over all reactions, skips those with negligible net\n    flux, and concatenates the Antimony fragments produced by\n    :func:`_get_reaction_string_of_cobrak_reaction`.  After processing reactions,\n    it adds definitions for metabolites (either user\u2011provided concentrations or\n    concentrations inferred from the NLP solution) and the global constants\n    ``R`` and ``T``.\n\n    Parameters\n    ----------\n    cobrak_model : Model\n        The COBRA\u2011k model containing reactions, metabolites, and model\u2011wide\n        parameters.\n    cell_density : float\n        Cell density (g\u202fL\u207b\u00b9) used to convert between substance\u2011only and molar\n        concentrations.\n    e_concs : dict[str, float]\n        Optional enzyme concentrations keyed by reaction ID. Missing entries\n        default to ``1.0``.\n    met_concs : dict[str, float]\n        Optional metabolite concentrations (mol\u202fL\u207b\u00b9) keyed by metabolite ID.\n    nlp_results : dict[str, float]\n        Optimisation variables returned by the NLP solver (log\u2011concentrations,\n        fluxes, etc.).\n\n    Returns\n    -------\n    str\n        A complete Antimony model string ready for ``tellurium.loada``.\n    \"\"\"\n    unoptimized_reactions = get_unoptimized_reactions_in_nlp_solution(\n        cobrak_model,\n        nlp_results,\n    )\n    tellurium_string = (\n        \"# General constants\\n\" + f\"R = {STANDARD_R}\\n\" + f\"T = {STANDARD_T}\\n\"\n    )\n    for reac_id, cobrak_reaction in cobrak_model.reactions.items():\n        if reac_id.endswith(cobrak_model.fwd_suffix):\n            reverse_id = reac_id.replace(\n                cobrak_model.fwd_suffix, cobrak_model.rev_suffix\n            )\n        elif reac_id.endswith(cobrak_model.rev_suffix):\n            reverse_id = reac_id.replace(\n                cobrak_model.rev_suffix, cobrak_model.fwd_suffix\n            )\n        else:\n            reverse_id = \"\"\n\n        if reverse_id in nlp_results:\n            reac_flux = nlp_results[reac_id] - nlp_results[reverse_id]\n        else:\n            reac_flux = nlp_results[reac_id]\n\n        if reac_flux &lt;= abs(1e-12):\n            continue\n\n        e_conc = e_concs.get(reac_id, 1.0)\n\n        tellurium_string += _get_reaction_string_of_cobrak_reaction(\n            cobrak_model=cobrak_model,\n            reac_id=reac_id,\n            cobrak_reaction=cobrak_reaction,\n            e_conc=e_conc,\n            met_concs=met_concs,\n            reac_flux=reac_flux,\n            nlp_results=nlp_results,\n            kinetic_ignored_metabolites=cobrak_model.kinetic_ignored_metabolites,\n            unoptimized_reactions=unoptimized_reactions,\n        )\n\n    cobrak_model = delete_orphaned_metabolites_and_enzymes(cobrak_model)\n\n    for unsafe_met_id, metabolite in cobrak_model.metabolites.items():\n        original_met_id = unsafe_met_id\n        met_id = _get_numbersafe_id(unsafe_met_id)\n        if met_id in met_concs:\n            tellurium_string += (\n                f\"\\nconst substanceOnly species {met_id} = {met_concs[met_id] * 1_000 / cell_density}\"\n                f\"\\n{met_id}_molar := {met_id} * {cell_density / 1_000}\\n\"\n            )\n        else:\n            if (\"x_\" + original_met_id in nlp_results) and (\n                metabolite.log_min_conc != metabolite.log_max_conc\n            ):\n                exp_conc = (\n                    exp(nlp_results[LNCONC_VAR_PREFIX + original_met_id])\n                    * 1_000\n                    / cell_density\n                )\n                tellurium_string += (\n                    f\"\\nsubstanceOnly species {met_id} = {exp_conc}\"\n                    f\"\\n{met_id}_molar := {met_id} * {cell_density / 1_000}\"\n                )\n            else:\n                prefix = \"const \" if original_met_id.endswith(\"_e\") else \"\"\n                tellurium_string += (\n                    f\"\\n{prefix}substanceOnly species {met_id} = {exp(metabolite.log_min_conc) * 1_000 / cell_density}\"\n                    f\"\\n{met_id}_molar := {met_id} * {cell_density / 1_000}\"\n                )\n\n    return tellurium_string\n</code></pre>"},{"location":"api.html#cobrak.tellurium_functionality.write_kinetic_sbml_model_from_cobrak_model_and_solution","title":"<code>write_kinetic_sbml_model_from_cobrak_model_and_solution(sbml_path, cobrak_model, cell_density, e_concs, met_concs, nlp_results)</code>","text":"<p>Export a kinetic model derived from a COBRA\u2011k model to an SBML file.</p> <p>The function first builds an Antimony string via :func:<code>get_tellurium_string_from_cobrak_model_and_solution</code>, loads it into a Tellurium <code>RoadRunner</code> instance, and then writes the model to the specified SBML file path.</p>"},{"location":"api.html#cobrak.tellurium_functionality.write_kinetic_sbml_model_from_cobrak_model_and_solution--parameters","title":"Parameters","text":"<p>sbml_path : str     Destination file path for the SBML document (e.g. <code>\"model.xml\"</code>). cobrak_model : Model     The source COBRA\u2011k model. cell_density : float     Cell density used for concentration conversions. e_concs : dict[str, float]     Enzyme concentrations per reaction. met_concs : dict[str, float]     Metabolite concentrations per species. nlp_results : dict[str, float]     NLP optimisation results (log\u2011concentrations, fluxes, etc.).</p>"},{"location":"api.html#cobrak.tellurium_functionality.write_kinetic_sbml_model_from_cobrak_model_and_solution--returns","title":"Returns","text":"<p>None     The function writes the SBML file as a side effect.</p> Source code in <code>cobrak/tellurium_functionality.py</code> <pre><code>@validate_call\ndef write_kinetic_sbml_model_from_cobrak_model_and_solution(\n    sbml_path: str,\n    cobrak_model: Model,\n    cell_density: float,\n    e_concs: dict[str, float],\n    met_concs: dict[str, float],\n    nlp_results: dict[str, float],\n) -&gt; None:\n    \"\"\"Export a kinetic model derived from a COBRA\u2011k model to an SBML file.\n\n    The function first builds an Antimony string via\n    :func:`get_tellurium_string_from_cobrak_model_and_solution`, loads it into a\n    Tellurium ``RoadRunner`` instance, and then writes the model to the specified\n    SBML file path.\n\n    Parameters\n    ----------\n    sbml_path : str\n        Destination file path for the SBML document (e.g. ``\"model.xml\"``).\n    cobrak_model : Model\n        The source COBRA\u2011k model.\n    cell_density : float\n        Cell density used for concentration conversions.\n    e_concs : dict[str, float]\n        Enzyme concentrations per reaction.\n    met_concs : dict[str, float]\n        Metabolite concentrations per species.\n    nlp_results : dict[str, float]\n        NLP optimisation results (log\u2011concentrations, fluxes, etc.).\n\n    Returns\n    -------\n    None\n        The function writes the SBML file as a side effect.\n    \"\"\"\n    tellurium_string = get_tellurium_string_from_cobrak_model_and_solution(\n        cobrak_model=cobrak_model,\n        cell_density=cell_density,\n        e_concs=e_concs,\n        met_concs=met_concs,\n        nlp_results=nlp_results,\n    )\n    tellurium_runner = tellurium.loada(tellurium_string)\n    tellurium_runner.exportToSBML(sbml_path)\n</code></pre>"},{"location":"api.html#cobrak.uniprot_functionality","title":"<code>uniprot_functionality</code>","text":"<p>get_protein_mass_mapping.py</p> <p>Functions for the generation of a model's mapping of its proteins and their masses.</p>"},{"location":"api.html#cobrak.uniprot_functionality.uniprot_get_enzyme_molecular_weights","title":"<code>uniprot_get_enzyme_molecular_weights(model, cache_basepath, multiplication_factor=1 / 1000)</code>","text":"<p>Returns a JSON with a mapping of protein IDs as keys, and as values the protein mass in kDa.</p> <p>The protein masses are taken  from UniProt (retrieved using UniProt's REST API).</p>"},{"location":"api.html#cobrak.uniprot_functionality.uniprot_get_enzyme_molecular_weights--arguments","title":"Arguments","text":"<ul> <li>model: cobra.Model ~ The model in the cobrapy format</li> </ul>"},{"location":"api.html#cobrak.uniprot_functionality.uniprot_get_enzyme_molecular_weights--output","title":"Output","text":"<p>A JSON file with the path project_folder+project_name+'_protein_id_mass_mapping.json' and the following structure:</p> <pre>\n{\n    \"$PROTEIN_ID\": $PROTEIN_MASS_IN_KDA,\n    (...),\n}\n</pre> Source code in <code>cobrak/uniprot_functionality.py</code> <pre><code>@validate_call(config=ConfigDict(arbitrary_types_allowed=True), validate_return=True)\ndef uniprot_get_enzyme_molecular_weights(\n    model: cobra.Model,\n    cache_basepath: str,\n    multiplication_factor: float = 1 / 1000,\n) -&gt; dict[str, float]:\n    \"\"\"Returns a JSON with a mapping of protein IDs as keys, and as values the protein mass in kDa.\n\n    The protein masses are taken  from UniProt (retrieved using\n    UniProt's REST API).\n\n    Arguments\n    ----------\n    * model: cobra.Model ~ The model in the cobrapy format\n\n    Output\n    ----------\n    A JSON file with the path project_folder+project_name+'_protein_id_mass_mapping.json'\n    and the following structure:\n    &lt;pre&gt;\n    {\n        \"$PROTEIN_ID\": $PROTEIN_MASS_IN_KDA,\n        (...),\n    }\n    &lt;/pre&gt;\n    \"\"\"\n\n    # GET UNIPROT ID - PROTEIN MAPPING\n    uniprot_id_protein_id_mapping: dict[str, list[str]] = {}\n    for gene in model.genes:\n        # Without a UniProt ID, no mass mapping can be found\n        if \"uniprot\" not in gene.annotation:\n            uniprot_id_protein_id_mapping[gene.id] = [gene.id]\n            continue\n        uniprot_id = gene.annotation[\"uniprot\"]\n        if uniprot_id in uniprot_id_protein_id_mapping:\n            uniprot_id_protein_id_mapping[uniprot_id].append(gene.id)\n        else:\n            uniprot_id_protein_id_mapping[uniprot_id] = [gene.id]\n\n    # GET UNIPROT ID&lt;-&gt;PROTEIN MASS MAPPING\n    uniprot_id_protein_mass_mapping: dict[str, float] = {}\n    # The cache stored UniProt masses for already searched\n    # UniProt IDs (each file in the cache folder has the name\n    # of the corresponding UniProt ID). This prevents searching\n    # UniProt for already found protein masses. :-)\n    cache_basepath = standardize_folder(cache_basepath)\n    ensure_folder_existence(cache_basepath)\n    cache_filepath = f\"{cache_basepath}_cache_uniprot_molecular_weights.json\"\n    try:\n        cache_json = json_load(cache_filepath, Any)\n    except Exception:\n        cache_json = {}\n    # Go through each batch of UniProt IDs (multiple UniProt IDs\n    # are searched at once in order to save an amount of UniProt API calls)\n    # and retrieve the amino acid sequences and using these sequences, their\n    # masses.\n    print(\"Starting UniProt ID&lt;-&gt;Protein mass search using UniProt API...\")\n    uniprot_ids = list(uniprot_id_protein_id_mapping.keys())\n    batch_size = 15\n    batch_start = 0\n    while batch_start &lt; len(uniprot_ids):\n        # Create the batch with all UniProt IDs\n        prebatch = uniprot_ids[batch_start : batch_start + batch_size]\n        batch = []\n        # Remove all IDs which are present in the cache (i.e.,\n        # which were searched for already).\n        # The cache consists of pickled protein mass floats, each\n        # onein a file with the name of the associated protein.\n        for uniprot_id in prebatch:\n            if uniprot_id not in cache_json:\n                batch.append(uniprot_id)\n            else:\n                uniprot_id_protein_mass_mapping[uniprot_id] = cache_json[uniprot_id]\n                # print(uniprot_id + \":\", uniprot_id_protein_mass_mapping[uniprot_id])\n\n        # If all IDs could be found in the cache, continue with the next batch.\n        if len(batch) == 0:\n            batch_start += batch_size\n            continue\n\n        # Create the UniProt query for the batch\n        # With 'OR', all given IDs are searched, and subsequently in this script,\n        # the right associated masses are being picked.\n        query = \" OR \".join(batch)\n        uniprot_query_url = f\"https://rest.uniprot.org/uniprotkb/search?query={query}&amp;format=tsv&amp;fields=accession,id,mass\"\n        print(f\"UniProt batch search for: {query}\")\n\n        # Call UniProt's API :-)\n        uniprot_data = requests.get(uniprot_query_url, timeout=1e6).text.split(\"\\n\")\n        # Wait in order to cool down their server :-)\n        time.sleep(2.0)\n\n        # Read out the API-returned lines\n        found_ids = []\n        for line in uniprot_data[1:]:\n            if not line:\n                continue\n            accession_id = line.split(\"\\t\")[0].lstrip().rstrip()\n            entry_id = line.split(\"\\t\")[1].lstrip().rstrip()\n            mass_string = line.split(\"\\t\")[2].lstrip().rstrip()\n            try:\n                # Note that the mass entry from UniProt uses a comma as a thousand separator, so it has to be removed before parsing\n                mass = float(mass_string.replace(\",\", \"\"))\n            except ValueError:  # We may also risk the entry is missing\n                # print(f\"No protein mass obtainable for protein ID {uniprot_id}\")\n                continue\n            uniprot_id_protein_mass_mapping[accession_id] = float(mass)\n            uniprot_id_protein_mass_mapping[entry_id] = float(mass)\n            found_ids.extend((accession_id, entry_id))\n\n        # Create the pickled cache files for the searched protein masses\n        for uniprot_id in found_ids:\n            if (\n                uniprot_id in uniprot_id_protein_mass_mapping\n            ):  # Takes into account that we may fail to obtain a UniProt ID\n                cache_json[uniprot_id] = uniprot_id_protein_mass_mapping[uniprot_id]\n\n        # Continue with the next batch :D\n        batch_start += batch_size\n\n    # Create the final protein ID &lt;-&gt; mass mapping\n    protein_id_mass_mapping: dict[str, float] = {}\n    for uniprot_id in list(uniprot_id_protein_mass_mapping.keys()):\n        try:\n            protein_ids = uniprot_id_protein_id_mapping[uniprot_id]\n        except Exception:\n            continue\n        for protein_id in protein_ids:\n            protein_id_mass_mapping[protein_id] = (\n                uniprot_id_protein_mass_mapping[uniprot_id] * multiplication_factor\n            )\n\n    # Return protein mass list JSON :D\n    json_write(cache_filepath, cache_json)\n    return protein_id_mass_mapping\n</code></pre>"},{"location":"api.html#cobrak.utilities","title":"<code>utilities</code>","text":"<p>General utility functions for COBRAk dataclasses and more.</p> <p>This module does not include I/O functions which are found in COBRAk's \"io\" module.</p>"},{"location":"api.html#cobrak.utilities.add_objective_value_as_extra_linear_constraint","title":"<code>add_objective_value_as_extra_linear_constraint(cobrak_model, objective_value, objective_target, objective_sense)</code>","text":"<p>Adds a linear constraint to a COBRA-k model that enforces the objective value.</p> <p>This function creates an extra linear constraint that limits the objective value to be within a small range around the original objective value. This can be useful for enforcing constraints during model manipulation or optimization.</p> <p>Parameters:</p> Name Type Description Default <code>cobrak_model</code> <code>Model</code> <p>The COBRA-k Model object to be modified.</p> required <code>objective_value</code> <code>float</code> <p>The original objective value.</p> required <code>objective_target</code> <code>str | dict[str, float]</code> <p>A string representing the objective variable or a dictionary mapping variables to their coefficients in the objective function.</p> required <code>objective_sense</code> <code>int</code> <p>The sense of the objective function (1 for maximization, -1 for minimization).</p> required <p>Returns:</p> Type Description <code>Model</code> <p>The modified COBRA-k Model object with the extra linear constraint added.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef add_objective_value_as_extra_linear_constraint(\n    cobrak_model: Model,\n    objective_value: float,\n    objective_target: str | dict[str, float],\n    objective_sense: int,\n) -&gt; Model:\n    \"\"\"Adds a linear constraint to a COBRA-k model that enforces the objective value.\n\n    This function creates an extra linear constraint that limits the objective\n    value to be within a small range around the original objective value. This\n    can be useful for enforcing constraints during model manipulation or\n    optimization.\n\n    Args:\n        cobrak_model: The COBRA-k Model object to be modified.\n        objective_value: The original objective value.\n        objective_target: A string representing the objective variable or a dictionary\n            mapping variables to their coefficients in the objective function.\n        objective_sense: The sense of the objective function (1 for maximization, -1 for minimization).\n\n    Returns:\n        The modified COBRA-k Model object with the extra linear constraint added.\n    \"\"\"\n    if is_objsense_maximization(objective_sense):\n        lower_value = objective_value - 1e-12\n        upper_value = None\n    else:\n        lower_value = None\n        upper_value = objective_value + 1e-12\n\n    if type(objective_target) is str:\n        objective_target = {objective_target: 1.0}\n    cobrak_model.extra_linear_constraints = [\n        ExtraLinearConstraint(\n            stoichiometries=objective_target,\n            lower_value=lower_value,\n            upper_value=upper_value,\n        )\n    ]\n    return cobrak_model\n</code></pre>"},{"location":"api.html#cobrak.utilities.add_statuses_to_optimziation_dict","title":"<code>add_statuses_to_optimziation_dict(optimization_dict, pyomo_results)</code>","text":"<p>Adds solver statuses to the optimization dict.</p> <p>This includes: * SOLVER_STATUS_KEY's value, which is 0 for ok, 1 for warning    and higher values for problems. * TERMINATION_CONDITION_KEY's value, which is 0.1 for globally optimal,   0.2 for optimal, 0.3 for locally optimal and &gt;=1 for any result with problems. * ALL_OK_KEY's value, which is True if SOLVER_STATUS_KEY's value &lt; 0   and TERMINATION_CONDITION_KEY's value &lt; 1.</p> <p>Parameters:</p> Name Type Description Default <code>optimization_dict</code> <code>dict[str, float]</code> <p>The optimization dict</p> required <code>pyomo_results</code> <code>SolverResults</code> <p>The pyomo results object</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Unknown pyomo_results.solver.status or termination_condition</p> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>dict[str, float]: The pyomo results dict with the added statuses.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>def add_statuses_to_optimziation_dict(\n    optimization_dict: dict[str, float], pyomo_results: SolverResults\n) -&gt; dict[str, float]:\n    \"\"\"Adds solver statuses to the optimization dict.\n\n    This includes:\n    * SOLVER_STATUS_KEY's value, which is 0 for ok, 1 for warning\n       and higher values for problems.\n    * TERMINATION_CONDITION_KEY's value, which is 0.1 for globally optimal,\n      0.2 for optimal, 0.3 for locally optimal and &gt;=1 for any result with problems.\n    * ALL_OK_KEY's value, which is True if SOLVER_STATUS_KEY's value &lt; 0\n      and TERMINATION_CONDITION_KEY's value &lt; 1.\n\n    Args:\n        optimization_dict (dict[str, float]): The optimization dict\n        pyomo_results (SolverResults): The pyomo results object\n\n    Raises:\n        ValueError: Unknown pyomo_results.solver.status or termination_condition\n\n    Returns:\n        dict[str, float]: The pyomo results dict with the added statuses.\n    \"\"\"\n    solver_status = get_solver_status_from_pyomo_results(pyomo_results)\n\n    termination_condition = get_termination_condition_from_pyomo_results(pyomo_results)\n\n    optimization_dict[SOLVER_STATUS_KEY] = solver_status\n    optimization_dict[TERMINATION_CONDITION_KEY] = termination_condition\n    optimization_dict[ALL_OK_KEY] = (\n        termination_condition &gt;= 0 and termination_condition &lt; 1\n    ) and (solver_status == 0)\n\n    return optimization_dict\n</code></pre>"},{"location":"api.html#cobrak.utilities.apply_error_correction_on_model","title":"<code>apply_error_correction_on_model(cobrak_model, correction_result, min_abs_error_value=0.01, min_rel_error_value=0.01, verbose=False)</code>","text":"<p>Applies error corrections to a COBRAl model based on a correction result dictionary.</p> <p>This function iterates through the <code>correction_result</code> dictionary and applies corrections to reaction k_cat values, Michaelis-Menten constants (k_M), Gibbs free energy changes (\u0394\u1d63G'\u00b0) as well as the inhibition terms (k_I) and activation terms (k_A). The corrections are applied only if the (for all parameters except \u0394\u1d63G'\u00b0) relative or (for \u0394\u1d63G'\u00b0) absolute error exceeds specified thresholds.</p> <p>Parameters:</p> Name Type Description Default <code>cobrak_model</code> <code>Model</code> <p>The COBRAl model to be corrected.</p> required <code>correction_result</code> <code>dict[str, float]</code> <p>A dictionary containing error correction values.  Keys are expected to contain information about the reaction, metabolite or other variable value being corrected.</p> required <code>min_abs_error_value</code> <code>NonNegativeFloat</code> <p>The minimum absolute error value for applying corrections.</p> <code>0.01</code> <code>min_rel_error_value</code> <code>NonNegativeFloat</code> <p>The minimum relative error value for applying corrections.</p> <code>0.01</code> <code>verbose</code> <code>bool</code> <p>If True, prints details of the corrections being applied.</p> <code>False</code> <p>Returns:</p> Type Description <code>Model</code> <p>A deep copy of the COBRAk model with the error corrections applied.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef apply_error_correction_on_model(\n    cobrak_model: Model,\n    correction_result: dict[str, float],\n    min_abs_error_value: NonNegativeFloat = 0.01,\n    min_rel_error_value: NonNegativeFloat = 0.01,\n    verbose: bool = False,\n) -&gt; Model:\n    \"\"\"Applies error corrections to a COBRAl model based on a correction result dictionary.\n\n    This function iterates through the `correction_result` dictionary and applies corrections\n    to reaction k_cat values, Michaelis-Menten constants (k_M), Gibbs free energy changes (\u0394\u1d63G'\u00b0)\n    as well as the inhibition terms (k_I) and activation terms (k_A).\n    The corrections are applied only if the (for all parameters except \u0394\u1d63G'\u00b0) relative or (for \u0394\u1d63G'\u00b0) absolute\n    error exceeds specified thresholds.\n\n    Args:\n        cobrak_model: The COBRAl model to be corrected.\n        correction_result: A dictionary containing error correction values.  Keys are expected to\n            contain information about the reaction, metabolite or other variable value being corrected.\n        min_abs_error_value: The minimum absolute error value for applying corrections.\n        min_rel_error_value: The minimum relative error value for applying corrections.\n        verbose: If True, prints details of the corrections being applied.\n\n    Returns:\n        A deep copy of the COBRAk model with the error corrections applied.\n    \"\"\"\n    changed_model = deepcopy(cobrak_model)\n    error_entries = {\n        key: value\n        for key, value in correction_result.items()\n        if key.startswith(ERROR_VAR_PREFIX)\n    }\n    for key, value in error_entries.items():\n        if \"_kcat_times_e_\" in key:\n            reac_id = key.split(\"_kcat_times_e_\")[1]\n            enzyme_id = get_reaction_enzyme_var_id(\n                reac_id, cobrak_model.reactions[reac_id]\n            )\n            k_cat = cobrak_model.reactions[reac_id].enzyme_reaction_data.k_cat\n            enzyme_conc = correction_result[enzyme_id]\n            e_times_kcat = k_cat * enzyme_conc\n            if e_times_kcat == 0.0:\n                continue\n            kcat_correction = (e_times_kcat + value) / e_times_kcat\n            if (kcat_correction - 1.0) &lt; min_rel_error_value:\n                continue\n            changed_model.reactions[\n                reac_id\n            ].enzyme_reaction_data.k_cat *= kcat_correction\n            if verbose:\n                print(\n                    f\"Correct kcat of {reac_id} from {k_cat} to {changed_model.reactions[reac_id].enzyme_reaction_data.k_cat}\"\n                )\n        elif key.endswith((\"_substrate\", \"_product\")):\n            reac_id = key.split(\"____\")[0].replace(ERROR_VAR_PREFIX + \"_\", \"\")\n            met_id = (\n                key.split(\"____\")[1].replace(\"_substrate\", \"\").replace(\"_product\", \"\")\n            )\n            original_km = cobrak_model.reactions[reac_id].enzyme_reaction_data.k_ms[\n                met_id\n            ]\n            if key.endswith(\"_product\"):\n                new_value = exp(log(original_km) + value)\n                if new_value / original_km &lt; (min_rel_error_value + 1.0):\n                    continue\n                changed_model.reactions[reac_id].enzyme_reaction_data.k_ms[met_id] = (\n                    exp(log(original_km) + value)\n                )\n            else:\n                new_value = exp(log(original_km) - value)\n                if (original_km / new_value) &lt; (min_rel_error_value + 1.0):\n                    continue\n                changed_model.reactions[reac_id].enzyme_reaction_data.k_ms[met_id] = (\n                    exp(log(original_km) - value)\n                )\n            if verbose:\n                print(\n                    f\"Correct km of {met_id} in {reac_id} from {original_km} to {changed_model.reactions[reac_id].enzyme_reaction_data.k_ms[met_id]}\"\n                )\n        elif key.endswith(\"_iota\"):\n            reac_id = key.split(\"____\")[1]\n            met_id = key.split(\"____\")[2]\n            original_ki = cobrak_model.reactions[reac_id].enzyme_reaction_data.k_i[\n                met_id\n            ]\n            new_value = exp(log(original_ki) + value)\n            if new_value / original_ki &lt; (min_rel_error_value + 1.0):\n                continue\n            changed_model.reactions[reac_id].enzyme_reaction_data.k_is[met_id] = exp(\n                log(original_ki) + value\n            )\n            if verbose:\n                print(\n                    f\"Correct ki of {met_id} in {reac_id} from {original_ki} to {changed_model.reactions[reac_id].enzyme_reaction_data.k_is[met_id]}\"\n                )\n        elif key.endswith(\"_alpha\"):\n            reac_id = key.split(\"____\")[1]\n            met_id = key.split(\"____\")[2]\n            original_ka = cobrak_model.reactions[reac_id].enzyme_reaction_data.k_a[\n                met_id\n            ]\n            new_value = exp(log(original_ka) + value)\n            if new_value / original_ka &lt; (min_rel_error_value + 1.0):\n                continue\n            changed_model.reactions[reac_id].enzyme_reaction_data.k_as[met_id] = exp(\n                log(original_ka) + value\n            )\n            if verbose:\n                print(\n                    f\"Correct ka of {met_id} in {reac_id} from {original_ka} to {changed_model.reactions[reac_id].enzyme_reaction_data.k_as[met_id]}\"\n                )\n        elif \"dG0_\" in key:\n            if value &lt; min_abs_error_value:\n                continue\n            reac_id = key.split(\"dG0_\")[1]\n            changed_model.reactions[reac_id].dG0 -= value\n            if verbose:\n                original_dG0 = cobrak_model.reactions[reac_id].dG0\n                print(\n                    f\"Correct \u0394G'\u00b0 {reac_id} from {original_dG0} to {changed_model.reactions[reac_id].dG0}\"\n                )\n\n    return changed_model\n</code></pre>"},{"location":"api.html#cobrak.utilities.apply_variability_dict","title":"<code>apply_variability_dict(model, cobrak_model, variability_dict, error_scenario={}, abs_epsilon=1e-05)</code>","text":"<p>Applies the variability data as new variable bounds in the pyomo model</p> <p>I.e., if the variaility of a variable A is [-10;10], A is now set to be -10 &lt;= A &lt;= 10 by changing its lower and upper bound.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>ConcreteModel</code> <p>The pyomo model</p> required <code>variability_dict</code> <code>dict[str, tuple[float, float]]</code> <p>The variability data</p> required <code>abs_epsilon</code> <code>_type_</code> <p>Under this value, the given value is assumed to be 0.0. Defaults to 1e-9.</p> <code>1e-05</code> <p>Returns:</p> Name Type Description <code>ConcreteModel</code> <code>ConcreteModel</code> <p>The pyomo model with newly set variable bounds</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(config=ConfigDict(arbitrary_types_allowed=True), validate_return=True)\ndef apply_variability_dict(\n    model: ConcreteModel,\n    cobrak_model: Model,  # noqa: ARG001\n    variability_dict: dict[str, tuple[float, float]],\n    error_scenario: dict[str, tuple[float, float]] = {},\n    abs_epsilon: NonNegativeFloat = 1e-5,\n) -&gt; ConcreteModel:\n    \"\"\"Applies the variability data as new variable bounds in the pyomo model\n\n    I.e., if the variaility of a variable A is [-10;10],\n    A is now set to be -10 &lt;= A &lt;= 10 by changing\n    its lower and upper bound.\n\n    Args:\n        model (ConcreteModel): The pyomo model\n        variability_dict (dict[str, tuple[float, float]]): The variability data\n        abs_epsilon (_type_, optional): Under this value, the given value is assumed to be 0.0. Defaults to 1e-9.\n\n    Returns:\n        ConcreteModel: The pyomo model with newly set variable bounds\n    \"\"\"\n    model_varnames = get_model_var_names(model)\n    for var_id, variability in variability_dict.items():\n        if var_id in error_scenario:\n            continue\n        try:\n            if abs(variability[0]) &lt; abs_epsilon:\n                getattr(model, var_id).setlb(0.0)\n            else:\n                lbchange_var_id = f\"{ERROR_BOUND_LOWER_CHANGE_PREFIX}{var_id}\"\n                if lbchange_var_id in model_varnames:\n                    getattr(model, var_id).setlb(\n                        variability[0] - getattr(model, lbchange_var_id).value\n                    )\n                else:\n                    getattr(model, var_id).setlb(variability[0])\n            if abs(variability[1]) &lt; abs_epsilon:\n                getattr(model, var_id).setub(0.0)\n            else:\n                ubchange_var_id = f\"{ERROR_BOUND_UPPER_CHANGE_PREFIX}{var_id}\"\n                if ubchange_var_id in model_varnames:\n                    getattr(model, var_id).setub(\n                        variability[1] + getattr(model, ubchange_var_id).value\n                    )\n                else:\n                    getattr(model, var_id).setub(variability[1])\n        except AttributeError:\n            pass\n    return model\n</code></pre>"},{"location":"api.html#cobrak.utilities.combine_enzyme_reaction_datasets","title":"<code>combine_enzyme_reaction_datasets(datasets)</code>","text":"<p>Combines the enzyme reaction data from the given sources</p> <p>The first given dataset has precedence, meaning that its data (k_cats, k_ms, ...) will be set first. For any reaction/metabolite where data is missing, it is then looked up in the second given dataset, then in the third and so on.</p> <p>Parameters:</p> Name Type Description Default <code>datasets</code> <code>list[dict[str, EnzymeReactionData | None]]</code> <p>The enzyme reaction datasets</p> required <p>Returns:</p> Type Description <code>dict[str, EnzymeReactionData | None]</code> <p>dict[str, EnzymeReactionData | None]: The combined enzyme reaction data</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef combine_enzyme_reaction_datasets(\n    datasets: list[dict[str, EnzymeReactionData | None]],\n) -&gt; dict[str, EnzymeReactionData | None]:\n    \"\"\"Combines the enzyme reaction data from the given sources\n\n    The first given dataset has precedence, meaning that its data (k_cats, k_ms, ...)\n    will be set first. For any reaction/metabolite where data is missing, it is then looked\n    up in the second given dataset, then in the third and so on.\n\n    Args:\n        datasets (list[dict[str, EnzymeReactionData  |  None]]): The enzyme reaction datasets\n\n    Returns:\n        dict[str, EnzymeReactionData | None]: The combined enzyme reaction data\n    \"\"\"\n    combined_data: dict[str, EnzymeReactionData] = {}\n\n    for dataset in datasets:\n        for reac_id, enzyme_reaction_data in dataset.items():\n            if enzyme_reaction_data is None:\n                continue\n\n            if (reac_id not in combined_data) or (\n                combined_data[reac_id].k_cat_references[0].tax_distance\n                &gt; enzyme_reaction_data.k_cat_references[0].tax_distance\n            ):\n                combined_data[reac_id] = EnzymeReactionData(\n                    identifiers=enzyme_reaction_data.identifiers,\n                    k_cat=enzyme_reaction_data.k_cat,\n                    k_cat_references=enzyme_reaction_data.k_cat_references,\n                )\n\n            for met_id, k_m in enzyme_reaction_data.k_ms.items():\n                if met_id not in combined_data[reac_id].k_ms or (\n                    combined_data[reac_id].k_m_references[met_id][0].tax_distance\n                    &gt; enzyme_reaction_data.k_m_references[met_id][0].tax_distance\n                ):\n                    combined_data[reac_id].k_ms[met_id] = k_m\n                    combined_data[reac_id].k_m_references[met_id] = (\n                        enzyme_reaction_data.k_m_references[met_id]\n                    )\n\n            for met_id, k_i in enzyme_reaction_data.k_is.items():\n                if met_id not in combined_data[reac_id].k_is or (\n                    combined_data[reac_id].k_i_references[met_id][0].tax_distance\n                    &gt; enzyme_reaction_data.k_i_references[met_id][0].tax_distance\n                ):\n                    combined_data[reac_id].k_is[met_id] = k_i\n                    combined_data[reac_id].k_i_references[met_id] = (\n                        enzyme_reaction_data.k_i_references[met_id]\n                    )\n\n            for met_id, k_a in enzyme_reaction_data.k_as.items():\n                if met_id not in combined_data[reac_id].k_as or (\n                    combined_data[reac_id].k_a_references[met_id][0].tax_distance\n                    &gt; enzyme_reaction_data.k_a_references[met_id][0].tax_distance\n                ):\n                    combined_data[reac_id].k_as[met_id] = k_a\n                    combined_data[reac_id].k_a_references[met_id] = (\n                        enzyme_reaction_data.k_a_references[met_id]\n                    )\n\n            hills = enzyme_reaction_data.hill_coefficients\n            for met_id in hills.kappa:\n                if met_id not in combined_data[reac_id].hill_coefficients.kappa or (\n                    combined_data[reac_id]\n                    .hill_coefficient_references.kappa[met_id][0]\n                    .tax_distance\n                    &gt; enzyme_reaction_data.hill_coefficient_references.kappa[met_id][\n                        0\n                    ].tax_distance\n                ):\n                    combined_data[reac_id].hill_coefficients.kappa[met_id] = hills.kappa\n                    combined_data[reac_id].hill_coefficient_references.kappa[met_id] = (\n                        enzyme_reaction_data.hill_coefficient_references.kappa[met_id]\n                    )\n            for met_id in hills.iota:\n                if met_id not in combined_data[reac_id].hill_coefficients.iota or (\n                    combined_data[reac_id]\n                    .hill_coefficient_references.iota[met_id][0]\n                    .tax_distance\n                    &gt; enzyme_reaction_data.hill_coefficient_references.iota[met_id][\n                        0\n                    ].tax_distance\n                ):\n                    combined_data[reac_id].hill_coefficients.iota[met_id] = hills.iota\n                    combined_data[reac_id].hill_coefficient_references.iota[met_id] = (\n                        enzyme_reaction_data.hill_coefficient_references.iota[met_id]\n                    )\n            for met_id in hills.alpha:\n                if met_id not in combined_data[reac_id].hill_coefficients.alpha or (\n                    combined_data[reac_id]\n                    .hill_coefficient_references.alpha[met_id][0]\n                    .tax_distance\n                    &gt; enzyme_reaction_data.hill_coefficient_references.alpha[met_id][\n                        0\n                    ].tax_distance\n                ):\n                    combined_data[reac_id].hill_coefficients.alpha[met_id] = hills.alpha\n                    combined_data[reac_id].hill_coefficient_references.alpha[met_id] = (\n                        enzyme_reaction_data.hill_coefficient_references.alpha[met_id]\n                    )\n\n    return combined_data\n</code></pre>"},{"location":"api.html#cobrak.utilities.compare_multiple_results_to_best","title":"<code>compare_multiple_results_to_best(cobrak_model, results, is_maximization, min_reac_flux=1e-08)</code>","text":"<p>Compares multiple optimization results to the best result and returns a dictionary with statistics and comparisons.</p> <p>This function first identifies the best result based on the objective value. It then compares each result to the best result and calculates statistics and comparisons. The comparisons include the difference between the objective values and the reaction fluxes. Reactions with fluxes below the minimum reaction flux threshold are ignored.</p> <p>Args: cobrak_model (Model): The COBRA-k model used for the optimization. results (list[dict[str, float]]): A list of optimization results. is_maximization (bool): Whether the optimization is a maximization problem. min_reac_flux (float, optional): The minimum reaction flux to consider. Defaults to 1e-8.</p> <p>Returns: dict[int, tuple[dict[str, float], dict[int, list[str]]]]: A dictionary where each key is the index of a result and each value is a tuple containing: - A dictionary with reaction statistics, including: - \"min\": The minimum absolute flux difference. - \"max\": The maximum absolute flux difference. - \"sum\": The sum of all absolute flux differences. - \"mean\": The mean of all absolute flux differences. - \"median\": The median of all absolute flux differences. - \"obj_difference\": The difference between the objective value of the current result and the best result. - A dictionary with reaction comparisons, where each key is an integer indicating which result has a higher flux: - 0: The best result has a higher flux. - 1: The current result has a higher flux.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef compare_multiple_results_to_best(\n    cobrak_model: Model,\n    results: list[dict[str, float]],\n    is_maximization: bool,\n    min_reac_flux: float = 1e-8,\n) -&gt; dict[int, tuple[dict[str, float], dict[int, list[str]]]]:\n    \"\"\"Compares multiple optimization results to the best result and returns a dictionary with statistics and comparisons.\n\n    This function first identifies the best result based on the objective value.\n    It then compares each result to the best result and calculates statistics and comparisons.\n    The comparisons include the difference between the objective values and the reaction fluxes.\n    Reactions with fluxes below the minimum reaction flux threshold are ignored.\n\n    Args:\n    cobrak_model (Model): The COBRA-k model used for the optimization.\n    results (list[dict[str, float]]): A list of optimization results.\n    is_maximization (bool): Whether the optimization is a maximization problem.\n    min_reac_flux (float, optional): The minimum reaction flux to consider. Defaults to 1e-8.\n\n    Returns:\n    dict[int, tuple[dict[str, float], dict[int, list[str]]]]: A dictionary where each key is the index of a result and each value is a tuple containing:\n    - A dictionary with reaction statistics, including:\n    - \"min\": The minimum absolute flux difference.\n    - \"max\": The maximum absolute flux difference.\n    - \"sum\": The sum of all absolute flux differences.\n    - \"mean\": The mean of all absolute flux differences.\n    - \"median\": The median of all absolute flux differences.\n    - \"obj_difference\": The difference between the objective value of the current result and the best result.\n    - A dictionary with reaction comparisons, where each key is an integer indicating which result has a higher flux:\n    - 0: The best result has a higher flux.\n    - 1: The current result has a higher flux.\n    \"\"\"\n    objective_values = [x[OBJECTIVE_VAR_NAME] for x in results]\n    best_objective = max(objective_values) if is_maximization else min(objective_values)\n    best_idx = objective_values.index(best_objective)\n\n    comparisons: dict[int, tuple[dict[str, float], dict[int, list[str]]]] = {}\n    for idx in range(len(results)):\n        if idx == best_idx:\n            continue\n        obj_difference = (\n            objective_values[idx] - best_objective\n            if is_maximization\n            else best_objective - objective_values[idx]\n        )\n        reac_statistics, reac_comparisons = _compare_two_results_with_statistics(\n            cobrak_model,\n            results[idx],\n            results[best_idx],\n            min_reac_flux,\n        )\n        reac_statistics[\"obj_difference\"] = obj_difference\n        comparisons[idx] = (reac_statistics, reac_comparisons)\n\n    return comparisons\n</code></pre>"},{"location":"api.html#cobrak.utilities.compare_optimization_result_fluxes","title":"<code>compare_optimization_result_fluxes(cobrak_model, result_1, result_2, min_reac_flux=1e-08)</code>","text":"<p>Compares the fluxes of two optimization results and returns a dictionary with the absolute differences and indicators of which result has a higher flux.</p> <p>This function first corrects the fluxes of the two results by considering the forward and reverse reactions. It then calculates the absolute differences between the corrected fluxes and determines which result has a higher flux for each reaction. Reactions with fluxes below the minimum reaction flux threshold are ignored.</p> <p>Args: cobrak_model (Model): The COBRA-k model used for the optimization. result_1 (dict[str, float]): The first optimization result. result_2 (dict[str, float]): The second optimization result. min_reac_flux (float, optional): The minimum reaction flux to consider. Defaults to 1e-8.</p> <p>Returns: dict[str, tuple[float, int]]: A dictionary where each key is a reaction ID and each value is a tuple containing: - The absolute difference between the fluxes of the two results. - An indicator of which result has a higher flux: - 0: Both results have the same flux. - 1: The first result has a higher flux. - 2: The second result has a higher flux.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef compare_optimization_result_fluxes(\n    cobrak_model: Model,\n    result_1: dict[str, float],\n    result_2: dict[str, float],\n    min_reac_flux: float = 1e-8,\n) -&gt; dict[str, tuple[float, int]]:\n    \"\"\"Compares the fluxes of two optimization results and returns a dictionary with the absolute differences and indicators of which result has a higher flux.\n\n    This function first corrects the fluxes of the two results by considering the forward and reverse reactions.\n    It then calculates the absolute differences between the corrected fluxes and determines which result has a higher flux for each reaction.\n    Reactions with fluxes below the minimum reaction flux threshold are ignored.\n\n    Args:\n    cobrak_model (Model): The COBRA-k model used for the optimization.\n    result_1 (dict[str, float]): The first optimization result.\n    result_2 (dict[str, float]): The second optimization result.\n    min_reac_flux (float, optional): The minimum reaction flux to consider. Defaults to 1e-8.\n\n    Returns:\n    dict[str, tuple[float, int]]: A dictionary where each key is a reaction ID and each value is a tuple containing:\n    - The absolute difference between the fluxes of the two results.\n    - An indicator of which result has a higher flux:\n    - 0: Both results have the same flux.\n    - 1: The first result has a higher flux.\n    - 2: The second result has a higher flux.\n    \"\"\"\n    corrected_result_1: dict[str, float] = {}\n    corrected_result_2: dict[str, float] = {}\n    for result, corrected_result in [\n        (result_1, corrected_result_1),\n        (result_2, corrected_result_2),\n    ]:\n        for var_id in result:\n            if var_id not in cobrak_model.reactions:\n                continue\n            flux = get_fwd_rev_corrected_flux(\n                var_id,\n                list(result.keys()),\n                result,\n                cobrak_model.fwd_suffix,\n                cobrak_model.rev_suffix,\n            )\n            if flux &gt;= min_reac_flux:\n                corrected_result[var_id] = flux\n\n    abs_results = {}\n    for reac_id in cobrak_model.reactions:\n        if (reac_id in corrected_result_1) and (reac_id in corrected_result_2):\n            flux_1, flux_2 = corrected_result_1[reac_id], corrected_result_2[reac_id]\n            # if other_id not in abs_results:\n            abs_results[reac_id] = (abs(flux_1 - flux_2), 0)\n        elif reac_id in corrected_result_1:\n            flux_1 = corrected_result_1[reac_id]\n            # if other_id not in abs_results:\n            abs_results[reac_id] = (flux_1, 1)\n        elif reac_id in corrected_result_2:\n            flux_2 = corrected_result_2[reac_id]\n            # if other_id not in abs_results:\n            abs_results[reac_id] = (flux_2, 2)\n\n    return abs_results\n</code></pre>"},{"location":"api.html#cobrak.utilities.compare_optimization_result_reaction_uses","title":"<code>compare_optimization_result_reaction_uses(cobrak_model, results, min_abs_flux=1e-06)</code>","text":"<p>Compares the usage of reactions across multiple optimization (e.g. FBA) results.</p> <p>This function analyzes the frequency of reaction usage in a set of optimization results from a COBRAk Model. It identifies which reactions are used in each solution and prints the number of solutions in which each reaction is active, considering a minimum absolute flux threshold.</p> <p>Parameters: - cobrak_model (Model): The COBRAk model containing the reactions to be analyzed. - results (list[dict[str, float]]): A list of dictionaries, each representing an optimization   result with reaction IDs as keys and their corresponding flux values as values. - min_abs_flux (float, optional): The minimum absolute flux value to consider a reaction as used.   Reactions with absolute flux values below this threshold are ignored. Defaults to 1e-6.</p> <ul> <li>None: This function does not return a value. It prints the number of solutions in which each   reaction is used, grouped by the number of solutions.</li> </ul> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef compare_optimization_result_reaction_uses(\n    cobrak_model: Model,\n    results: list[dict[str, float]],\n    min_abs_flux: NonNegativeFloat = 1e-6,\n) -&gt; None:\n    \"\"\"Compares the usage of reactions across multiple optimization (e.g. FBA) results.\n\n    This function analyzes the frequency of reaction usage in a set of optimization results\n    from a COBRAk Model. It identifies which reactions are used in each solution and prints\n    the number of solutions in which each reaction is active, considering a minimum absolute\n    flux threshold.\n\n    Parameters:\n    - cobrak_model (Model): The COBRAk model containing the reactions to be analyzed.\n    - results (list[dict[str, float]]): A list of dictionaries, each representing an optimization\n      result with reaction IDs as keys and their corresponding flux values as values.\n    - min_abs_flux (float, optional): The minimum absolute flux value to consider a reaction as used.\n      Reactions with absolute flux values below this threshold are ignored. Defaults to 1e-6.\n\n    Returns:\n    - None: This function does not return a value. It prints the number of solutions in which each\n      reaction is used, grouped by the number of solutions.\n    \"\"\"\n    results = deepcopy(results)\n    results = [\n        get_base_id_optimzation_result(\n            cobrak_model,\n            result,\n        )\n        for result in results\n    ]\n\n    reac_ids: list[str] = [\n        get_base_id(\n            reac_id,\n            cobrak_model.fwd_suffix,\n            cobrak_model.rev_suffix,\n            cobrak_model.reac_enz_separator,\n        )\n        for reac_id in cobrak_model.reactions\n    ]\n    reacs_to_uses: dict[str, list[int]] = {reac_id: [] for reac_id in reac_ids}\n    for num, result in enumerate(results):\n        for reac_id in reac_ids:\n            if reac_id not in result:\n                continue\n            if abs(result[reac_id]) &lt;= min_abs_flux:\n                continue\n            if num in reacs_to_uses[reac_id]:\n                continue\n            reacs_to_uses[reac_id].append(num)\n    min_num_results = min(len(i) for i in reacs_to_uses.values())\n    max_num_results = max(len(i) for i in reacs_to_uses.values())\n    print(min_num_results, max_num_results)\n    for num_results in range(min_num_results, max_num_results + 1):\n        print(f\"Reactions used in {num_results} solutions:\")\n        print(\n            [\n                (reac_id, uses)\n                for reac_id, uses in reacs_to_uses.items()\n                if len(uses) == num_results\n            ]\n        )\n        print(\"===\")\n</code></pre>"},{"location":"api.html#cobrak.utilities.count_last_equal_elements","title":"<code>count_last_equal_elements(lst)</code>","text":"<p>Counts the number of consecutive equal elements from the end of the list.</p> <p>Parameters: lst (list[Any]): A Python list.</p> <p>Returns: int: The number of consecutive equal elements from the end of the list.</p> <p>Examples:</p> <p>count_last_equal_elements([1.0, 2.0, 1.0, 3.0, 3.0, 3.0]) 3 count_last_equal_elements([1.0, 2.0, 2.0, 1.0]) 1 count_last_equal_elements([1.0, 1.0, 1.0, 1.0]) 4 count_last_equal_elements([]) 0</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef count_last_equal_elements(lst: list[Any]) -&gt; int:\n    \"\"\"Counts the number of consecutive equal elements from the end of the list.\n\n    Parameters:\n    lst (list[Any]): A Python list.\n\n    Returns:\n    int: The number of consecutive equal elements from the end of the list.\n\n    Examples:\n    &gt;&gt;&gt; count_last_equal_elements([1.0, 2.0, 1.0, 3.0, 3.0, 3.0])\n    3\n    &gt;&gt;&gt; count_last_equal_elements([1.0, 2.0, 2.0, 1.0])\n    1\n    &gt;&gt;&gt; count_last_equal_elements([1.0, 1.0, 1.0, 1.0])\n    4\n    &gt;&gt;&gt; count_last_equal_elements([])\n    0\n    \"\"\"\n    if not lst:\n        return 0  # Return 0 if the list is empty\n\n    count = 1  # Start with the last element\n    last_element = lst[-1]\n\n    # Iterate from the second last element to the beginning\n    for i in range(len(lst) - 2, -1, -1):\n        if lst[i] == last_element:\n            count += 1\n        else:\n            break  # Stop counting when a different element is found\n\n    return count\n</code></pre>"},{"location":"api.html#cobrak.utilities.create_cnapy_scenario_out_of_optimization_dict","title":"<code>create_cnapy_scenario_out_of_optimization_dict(path, cobrak_model, optimization_dict, desplit_reactions=True)</code>","text":"<p>Create a CNApy scenario file from an optimization dictionary and a COBRAk Model.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The file path where the CNApy scenario will be saved.</p> required <code>cobrak_model</code> <code>Model</code> <p>The COBRAk Model.</p> required <code>optimization_dict</code> <code>dict[str, float]</code> <p>An optimization result dict.</p> required <code>desplit_reactions</code> <code>bool</code> <p>bool: Whether or not the fluxes of split reversible reaction                      shall be recombined. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>The function saves the CNApy scenario to the specified path.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef create_cnapy_scenario_out_of_optimization_dict(\n    path: str,\n    cobrak_model: Model,\n    optimization_dict: dict[str, float],\n    desplit_reactions: bool = True,\n) -&gt; None:\n    \"\"\"Create a CNApy scenario file from an optimization dictionary and a COBRAk Model.\n\n    Args:\n        path (str): The file path where the CNApy scenario will be saved.\n        cobrak_model (Model): The COBRAk Model.\n        optimization_dict (dict[str, float]): An optimization result dict.\n        desplit_reactions: bool: Whether or not the fluxes of split reversible reaction\n                                 shall be recombined. Defaults to True.\n\n    Returns:\n        None: The function saves the CNApy scenario to the specified path.\n    \"\"\"\n    base_id_result = (\n        get_base_id_optimzation_result(\n            cobrak_model,\n            optimization_dict,\n        )\n        if desplit_reactions\n        else optimization_dict\n    )\n    cnapy_scenario: dict[str, tuple[float, float]] = {\n        key: (value, value) for key, value in base_id_result.items()\n    }\n    json_write(path, cnapy_scenario)\n</code></pre>"},{"location":"api.html#cobrak.utilities.create_cnapy_scenario_out_of_variability_dict","title":"<code>create_cnapy_scenario_out_of_variability_dict(path, cobrak_model, variability_dict, desplit_reactions=True)</code>","text":"<p>Create a CNApy scenario file from a variability dictionary and a COBRAk model.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The file path where the CNApy scenario file will be saved.</p> required <code>cobrak_model</code> <code>Model</code> <p>The COBRA-k model containing reactions.</p> required <code>variability_dict</code> <code>dict[str, list[float]]</code> <p>A dictionary mapping reaction IDs to their minimum and maximum flux values.</p> required <code>desplit_reactions</code> <code>bool</code> <p>bool: Whether or not the fluxes of split reversible reaction                      shall be recombined. Defaults to True.</p> <code>True</code> <p>Returns:     None: The function saves the CNApy scenario to the specified path.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef create_cnapy_scenario_out_of_variability_dict(\n    path: str,\n    cobrak_model: Model,\n    variability_dict: dict[str, tuple[float, float]],\n    desplit_reactions: bool = True,\n) -&gt; None:\n    \"\"\"Create a CNApy scenario file from a variability dictionary and a COBRAk model.\n\n    Args:\n        path (str): The file path where the CNApy scenario file will be saved.\n        cobrak_model (Model): The COBRA-k model containing reactions.\n        variability_dict (dict[str, list[float]]): A dictionary mapping reaction IDs to their minimum and maximum flux values.\n        desplit_reactions: bool: Whether or not the fluxes of split reversible reaction\n                                 shall be recombined. Defaults to True.\n    Returns:\n        None: The function saves the CNApy scenario to the specified path.\n    \"\"\"\n    cnapy_scenario: dict[str, list[float]] = {}\n\n    for reac_id in cobrak_model.reactions:\n        if reac_id not in variability_dict:\n            continue\n        base_id = (\n            get_base_id(\n                reac_id,\n                cobrak_model.fwd_suffix,\n                cobrak_model.rev_suffix,\n                cobrak_model.reac_enz_separator,\n            )\n            if desplit_reactions\n            else reac_id\n        )\n\n        multiplier = 1 if reac_id.endswith(cobrak_model.fwd_suffix) else -1\n        min_flux = variability_dict[reac_id][0]\n        max_flux = variability_dict[reac_id][0]\n\n        if base_id not in cnapy_scenario:\n            cnapy_scenario[base_id] = [0.0, 0.0]\n\n        cnapy_scenario[base_id][0] += multiplier * min_flux\n        cnapy_scenario[base_id][1] += multiplier * max_flux\n\n    json_write(path, cnapy_scenario)\n</code></pre>"},{"location":"api.html#cobrak.utilities.delete_orphaned_metabolites_and_enzymes","title":"<code>delete_orphaned_metabolites_and_enzymes(cobrak_model)</code>","text":"<p>Removes orphaned metabolites and enzymes from a COBRAk model.</p> <p>This function cleans up a COBRAk model by deleting metabolites and enzymes that are not used in any reactions. A metabolite is considered orphaned if it does not appear in the stoichiometries of any reactions. Similarly, an enzyme is considered orphaned if it is not associated with any enzyme reaction data in the model's reactions.</p> <ul> <li>cobrak_model (Model): The COBRAk model to be cleaned. This model contains reactions,   metabolites, and enzymes that may include unused entries.</li> </ul> <p>Returns: - Model: The cleaned COBRAk model with orphaned metabolites and enzymes removed.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef delete_orphaned_metabolites_and_enzymes(cobrak_model: Model) -&gt; Model:\n    \"\"\"Removes orphaned metabolites and enzymes from a COBRAk model.\n\n    This function cleans up a COBRAk model by deleting metabolites and enzymes that are not used\n    in any reactions. A metabolite is considered orphaned if it does not appear in the stoichiometries\n    of any reactions. Similarly, an enzyme is considered orphaned if it is not associated with any\n    enzyme reaction data in the model's reactions.\n\n    Parameters:\n    - cobrak_model (Model): The COBRAk model to be cleaned. This model contains reactions,\n      metabolites, and enzymes that may include unused entries.\n\n    Returns:\n    - Model: The cleaned COBRAk model with orphaned metabolites and enzymes removed.\n    \"\"\"\n    used_metabolites = []\n    used_enzyme_ids = []\n    for reaction in cobrak_model.reactions.values():\n        used_metabolites += list(reaction.stoichiometries.keys())\n\n        if reaction.enzyme_reaction_data is not None:\n            used_enzyme_ids += reaction.enzyme_reaction_data.identifiers\n\n    # Delete metabolites\n    mets_to_delete = [\n        met_id for met_id in cobrak_model.metabolites if met_id not in used_metabolites\n    ]\n    for met_to_delete in mets_to_delete:\n        del cobrak_model.metabolites[met_to_delete]\n\n    # Delete enzymes\n    enzymes_to_delete = [\n        enzyme_id\n        for enzyme_id in cobrak_model.enzymes\n        if enzyme_id not in used_enzyme_ids\n    ]\n    for enzyme_to_delete in enzymes_to_delete:\n        del cobrak_model.enzymes[enzyme_to_delete]\n\n    return cobrak_model\n</code></pre>"},{"location":"api.html#cobrak.utilities.delete_unused_reactions_in_optimization_dict","title":"<code>delete_unused_reactions_in_optimization_dict(cobrak_model, optimization_dict, exception_prefix='', delete_missing_reactions=True, min_abs_flux=1e-15, do_not_delete_with_z_var_one=True)</code>","text":"<p>Delete unused reactions in a COBRAk model based on an optimization dictionary.</p> <p>This function creates a deep copy of the provided COBRAk model and removes reactions that are either not present in the optimization dictionary or have flux values below a specified threshold. Optionally, reactions with a specific prefix can be excluded from deletion. Additionally, orphaned metabolites (those not used in any remaining reactions) are also removed.</p> <p>Parameters:</p> Name Type Description Default <code>cobrak_model</code> <code>Model</code> <p>COBRAk model containing reactions and metabolites.</p> required <code>optimization_dict</code> <code>dict[str, float]</code> <p>Dictionary mapping reaction IDs to their optimized flux values.</p> required <code>exception_prefix</code> <code>str</code> <p>A prefix for reaction IDs that should not be deleted. Defaults to \"\".</p> <code>''</code> <code>delete_missing_reactions</code> <code>bool</code> <p>Whether to delete reactions not present in the optimization dictionary. Defaults to True.</p> <code>True</code> <code>min_abs_flux</code> <code>float</code> <p>The minimum absolute flux value below which reactions are considered unused. Defaults to 1e-10.</p> <code>1e-15</code> <p>Returns:</p> Name Type Description <code>Model</code> <code>Model</code> <p>A new COBRAk model with unused reactions and orphaned metabolites removed.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef delete_unused_reactions_in_optimization_dict(\n    cobrak_model: Model,\n    optimization_dict: dict[str, float],\n    exception_prefix: str = \"\",\n    delete_missing_reactions: bool = True,\n    min_abs_flux: NonNegativeFloat = 1e-15,\n    do_not_delete_with_z_var_one: bool = True,\n) -&gt; Model:\n    \"\"\"Delete unused reactions in a COBRAk model based on an optimization dictionary.\n\n    This function creates a deep copy of the provided COBRAk model and removes reactions that are either not present\n    in the optimization dictionary or have flux values below a specified threshold. Optionally,\n    reactions with a specific prefix can be excluded from deletion.\n    Additionally, orphaned metabolites (those not used in any remaining reactions) are also removed.\n\n    Args:\n        cobrak_model (Model): COBRAk model containing reactions and metabolites.\n        optimization_dict (dict[str, float]): Dictionary mapping reaction IDs to their optimized flux values.\n        exception_prefix (str, optional): A prefix for reaction IDs that should not be deleted. Defaults to \"\".\n        delete_missing_reactions (bool, optional): Whether to delete reactions not present in the optimization dictionary. Defaults to True.\n        min_abs_flux (float, optional): The minimum absolute flux value below which reactions are considered unused. Defaults to 1e-10.\n\n    Returns:\n        Model: A new COBRAk model with unused reactions and orphaned metabolites removed.\n    \"\"\"\n    cobrak_model = deepcopy(cobrak_model)\n    reacs_to_delete: list[str] = []\n    for reac_id in cobrak_model.reactions:\n        to_delete = False\n        if (reac_id not in optimization_dict) and delete_missing_reactions:\n            to_delete = True\n        elif (reac_id in optimization_dict) and abs(\n            optimization_dict[reac_id]\n        ) &lt;= min_abs_flux:\n            z_var_id = f\"{Z_VAR_PREFIX}{reac_id}\"\n            if z_var_id in optimization_dict:\n                if do_not_delete_with_z_var_one and (\n                    optimization_dict[z_var_id] &lt;= 1e-6\n                ):\n                    to_delete = True\n                else:\n                    to_delete = True\n            else:\n                to_delete = True\n        if to_delete:\n            reacs_to_delete.append(reac_id)\n    for reac_to_delete in reacs_to_delete:\n        if (exception_prefix) and (reac_to_delete.startswith(exception_prefix)):\n            continue\n        del cobrak_model.reactions[reac_to_delete]\n    return delete_orphaned_metabolites_and_enzymes(cobrak_model)\n</code></pre>"},{"location":"api.html#cobrak.utilities.delete_unused_reactions_in_variability_dict","title":"<code>delete_unused_reactions_in_variability_dict(cobrak_model, variability_dict, extra_reacs_to_delete=[])</code>","text":"<p>Delete unused reactions in a COBRAk model based on a variability dictionary.</p> <p>This function creates a deep copy of the provided COBRA-k model and removes reactions that have both minimum and maximum flux values equal to zero, as indicated in the variability dictionary. Additionally, any extra reactions specified in the <code>extra_reacs_to_delete</code> list are also removed. Orphaned metabolites (those not used in any remaining reactions) are subsequently deleted, too.</p> <p>Parameters:</p> Name Type Description Default <code>cobrak_model</code> <code>Model</code> <p>The COBRAk model containing reactions and metabolites.</p> required <code>variability_dict</code> <code>dict[str, tuple[float, float]]</code> <p>A dictionary mapping reaction IDs to their minimum and maximum flux values.</p> required <code>extra_reacs_to_delete</code> <code>list[str]</code> <p>A list of additional reaction IDs to be deleted. Defaults to an empty list.</p> <code>[]</code> <p>Returns:</p> Name Type Description <code>Model</code> <code>Model</code> <p>A new COBRAk model with unused reactions and orphaned metabolites removed.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef delete_unused_reactions_in_variability_dict(\n    cobrak_model: Model,\n    variability_dict: dict[str, tuple[float, float]],\n    extra_reacs_to_delete: list[str] = [],\n) -&gt; Model:\n    \"\"\"Delete unused reactions in a COBRAk model based on a variability dictionary.\n\n    This function creates a deep copy of the provided COBRA-k model and removes reactions that have both minimum and maximum flux values\n    equal to zero, as indicated in the variability dictionary.\n    Additionally, any extra reactions specified in the `extra_reacs_to_delete` list are also removed.\n    Orphaned metabolites (those not used in any remaining reactions) are subsequently deleted, too.\n\n    Args:\n        cobrak_model (Model): The COBRAk model containing reactions and metabolites.\n        variability_dict (dict[str, tuple[float, float]]): A dictionary mapping reaction IDs to their minimum and maximum flux values.\n        extra_reacs_to_delete (list[str], optional): A list of additional reaction IDs to be deleted. Defaults to an empty list.\n\n    Returns:\n        Model: A new COBRAk model with unused reactions and orphaned metabolites removed.\n    \"\"\"\n    cobrak_model = deepcopy(cobrak_model)\n    reacs_to_delete: list[str] = [] + extra_reacs_to_delete\n    for reac_id in cobrak_model.reactions:\n        if (variability_dict[reac_id][0] == 0.0) and (\n            variability_dict[reac_id][1] == 0.0\n        ):\n            reacs_to_delete.append(reac_id)\n    for reac_to_delete in reacs_to_delete:\n        del cobrak_model.reactions[reac_to_delete]\n\n    return delete_orphaned_metabolites_and_enzymes(cobrak_model)\n</code></pre>"},{"location":"api.html#cobrak.utilities.get_active_reacs_from_optimization_dict","title":"<code>get_active_reacs_from_optimization_dict(cobrak_model, fba_dict)</code>","text":"<p>Get a list of active reactions from an optimization (e.g. FBA (Flux Balance Analysis)) dictionary.</p> <p>This function iterates through the reactions in a COBRAk model and identifies those that have a positive flux value in the provided FBA dictionary. Only reactions present in the optimization dictionary and with a flux greater than zero are considered active.</p> <p>Parameters:</p> Name Type Description Default <code>cobrak_model</code> <code>Model</code> <p>The COBRAk model containing reactions.</p> required <code>fba_dict</code> <code>dict[str, float]</code> <p>A dictionary mapping reaction IDs to their flux values from an optimization.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: A list of reaction IDs that are active (i.e., have a positive flux) according to the optimization dictionary.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef get_active_reacs_from_optimization_dict(\n    cobrak_model: Model,\n    fba_dict: dict[str, float],\n) -&gt; list[str]:\n    \"\"\"Get a list of active reactions from an optimization (e.g. FBA (Flux Balance Analysis)) dictionary.\n\n    This function iterates through the reactions in a COBRAk model and identifies those that have a positive flux value in the provided FBA dictionary.\n    Only reactions present in the optimization dictionary and with a flux greater than zero are considered active.\n\n    Args:\n        cobrak_model (Model): The COBRAk model containing reactions.\n        fba_dict (dict[str, float]): A dictionary mapping reaction IDs to their flux values from an optimization.\n\n    Returns:\n        list[str]: A list of reaction IDs that are active (i.e., have a positive flux) according to the optimization dictionary.\n    \"\"\"\n    active_reacs: list[str] = []\n    for reac_id in cobrak_model.reactions:\n        if reac_id not in fba_dict:\n            continue\n        if fba_dict[reac_id] &gt; 0.0:\n            active_reacs.append(reac_id)\n    return active_reacs\n</code></pre>"},{"location":"api.html#cobrak.utilities.get_base_id","title":"<code>get_base_id(reac_id, fwd_suffix=REAC_FWD_SUFFIX, rev_suffix=REAC_REV_SUFFIX, reac_enz_separator=REAC_ENZ_SEPARATOR)</code>","text":"<p>Extract the base ID from a reaction ID by removing specified suffixes and separators.</p> <p>Processes a reaction ID to remove forward and reverse suffixes as well as any enzyme separators, to obtain the base reaction ID.</p> <p>Parameters:</p> Name Type Description Default <code>reac_id</code> <code>str</code> <p>The reaction ID to be processed.</p> required <code>fwd_suffix</code> <code>str</code> <p>The suffix indicating forward reactions. Defaults to REAC_FWD_SUFFIX.</p> <code>REAC_FWD_SUFFIX</code> <code>rev_suffix</code> <code>str</code> <p>The suffix indicating reverse reactions. Defaults to REAC_REV_SUFFIX.</p> <code>REAC_REV_SUFFIX</code> <code>reac_enz_separator</code> <code>str</code> <p>The separator used between reaction and enzyme identifiers. Defaults to REAC_ENZ_SEPARATOR.</p> <code>REAC_ENZ_SEPARATOR</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The base reaction ID with specified suffixes and separators removed.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef get_base_id(\n    reac_id: str,\n    fwd_suffix: str = REAC_FWD_SUFFIX,\n    rev_suffix: str = REAC_REV_SUFFIX,\n    reac_enz_separator: str = REAC_ENZ_SEPARATOR,\n) -&gt; str:\n    \"\"\"Extract the base ID from a reaction ID by removing specified suffixes and separators.\n\n    Processes a reaction ID to remove forward and reverse suffixes\n    as well as any enzyme separators, to obtain the base reaction ID.\n\n    Args:\n        reac_id (str): The reaction ID to be processed.\n        fwd_suffix (str, optional): The suffix indicating forward reactions. Defaults to REAC_FWD_SUFFIX.\n        rev_suffix (str, optional): The suffix indicating reverse reactions. Defaults to REAC_REV_SUFFIX.\n        reac_enz_separator (str, optional): The separator used between reaction and enzyme identifiers. Defaults to REAC_ENZ_SEPARATOR.\n\n    Returns:\n        str: The base reaction ID with specified suffixes and separators removed.\n    \"\"\"\n    reac_id_split = reac_id.split(reac_enz_separator)\n    return (\n        (reac_id_split[0] + \"\\b\")\n        .replace(f\"{fwd_suffix}\\b\", \"\")\n        .replace(f\"{rev_suffix}\\b\", \"\")\n        .replace(\"\\b\", \"\")\n    )\n</code></pre>"},{"location":"api.html#cobrak.utilities.get_base_id_optimzation_result","title":"<code>get_base_id_optimzation_result(cobrak_model, optimization_dict)</code>","text":"<p>Converts an optimization result to a base reaction ID format in a COBRAk model.</p> <p>This function processes an optimization result dictionary, which contains reaction IDs with their corresponding flux values, and consolidates these fluxes into base reaction IDs. It accounts for forward and reverse reaction suffixes to ensure that the net flux for each base reaction ID is calculated correctly.</p> <p>Parameters: - cobrak_model (Model): The COBRAk model containing the reactions to be processed. - optimization_dict (dict[str, float]): A dictionary mapping reaction IDs to their flux values   from an optimization result.</p> <ul> <li>dict[str, float]: A dictionary mapping base reaction IDs to their net flux values, consolidating   forward and reverse reactions.</li> </ul> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef get_base_id_optimzation_result(\n    cobrak_model: Model,\n    optimization_dict: dict[str, float],\n) -&gt; dict[str, float]:\n    \"\"\"Converts an optimization result to a base reaction ID format in a COBRAk model.\n\n    This function processes an optimization result dictionary, which contains reaction IDs with\n    their corresponding flux values, and consolidates these fluxes into base reaction IDs. It\n    accounts for forward and reverse reaction suffixes to ensure that the net flux for each base\n    reaction ID is calculated correctly.\n\n    Parameters:\n    - cobrak_model (Model): The COBRAk model containing the reactions to be processed.\n    - optimization_dict (dict[str, float]): A dictionary mapping reaction IDs to their flux values\n      from an optimization result.\n\n    Returns:\n    - dict[str, float]: A dictionary mapping base reaction IDs to their net flux values, consolidating\n      forward and reverse reactions.\n    \"\"\"\n    base_id_scenario: dict[str, float] = {}\n\n    for reac_id in cobrak_model.reactions:\n        if reac_id not in optimization_dict:\n            continue\n        base_id = get_base_id(\n            reac_id,\n            cobrak_model.fwd_suffix,\n            cobrak_model.rev_suffix,\n            cobrak_model.reac_enz_separator,\n        )\n\n        multiplier = -1 if reac_id.endswith(cobrak_model.rev_suffix) else +1\n        flux = optimization_dict[reac_id]\n\n        if base_id not in base_id_scenario:\n            base_id_scenario[base_id] = 0.0\n\n        base_id_scenario[base_id] += multiplier * flux\n\n    return base_id_scenario\n</code></pre>"},{"location":"api.html#cobrak.utilities.get_cobrak_enzyme_reactions_string","title":"<code>get_cobrak_enzyme_reactions_string(cobrak_model, enzyme_id)</code>","text":"<p>Get string of reaction IDs associated with a specific enzyme in the COBRAk model.</p> <p>This function iterates through the reactions in a COBRAk model and collects the IDs of reaction that involve the specified enzyme. The collected reaction IDs are then concatenated into a single string, separated by semicolons.</p> <p>Parameters:</p> Name Type Description Default <code>cobrak_model</code> <code>Model</code> <p>The COBRAk model containing reactions and enzyme data.</p> required <code>enzyme_id</code> <code>str</code> <p>The ID of the enzyme for which associated reactions are to be found.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A semicolon-separated string of reaction IDs that involve the specified enzyme.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef get_cobrak_enzyme_reactions_string(cobrak_model: Model, enzyme_id: str) -&gt; str:\n    \"\"\"Get string of reaction IDs associated with a specific enzyme in the COBRAk model.\n\n    This function iterates through the reactions in a COBRAk model and collects the IDs of reaction\n    that involve the specified enzyme.\n    The collected reaction IDs are then concatenated into a single string, separated by semicolons.\n\n    Args:\n        cobrak_model (Model): The COBRAk model containing reactions and enzyme data.\n        enzyme_id (str): The ID of the enzyme for which associated reactions are to be found.\n\n    Returns:\n        str: A semicolon-separated string of reaction IDs that involve the specified enzyme.\n    \"\"\"\n    enzyme_reactions = []\n    for reac_id, reaction in cobrak_model.reactions.items():\n        if reaction.enzyme_reaction_data is None:\n            continue\n        if enzyme_id in reaction.enzyme_reaction_data.identifiers:\n            enzyme_reactions.append(reac_id)\n    return \"; \".join(enzyme_reactions)\n</code></pre>"},{"location":"api.html#cobrak.utilities.get_df_and_efficiency_factors_sorted_lists","title":"<code>get_df_and_efficiency_factors_sorted_lists(cobrak_model, result, min_flux=0.0)</code>","text":"<p>Extracts and sorts lists of flux values (df) and \u03ba, \u03b3, \u03b9, \u03b1 values from a result dictionary.</p> <p>This function processes a dictionary of results of a COBRA-k optimization to extract and sort lists of flux values (df) and \u03ba, \u03b3, \u03b9, \u03b1 values values. It filters these values based on a minimum flux threshold and returns them as sorted dictionaries. The function also calculates and returns a dictionary of kappa times gamma values, along with a status indicator representing the number of these values present for each reaction.</p> <p>Parameters:</p> Name Type Description Default <code>cobrak_model</code> <code>Model</code> <p>The COBRA-k Model object.</p> required <code>result</code> <code>dict[str, float]</code> <p>A dictionary containing optimization results.  Keys are expected to start with prefixes like 'DF_VAR_PREFIX', 'KAPPA_VAR_PREFIX', and 'GAMMA_VAR_PREFIX'.</p> required <code>min_flux</code> <code>NonNegativeFloat</code> <p>The minimum flux value to consider when filtering the results.  Values below this threshold are excluded.  Defaults to 0.0.</p> <code>0.0</code> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>A tuple containing four dictionaries:</p> <code>dict[str, float]</code> <ol> <li>A dictionary of sorted flux values (df) above the minimum flux.</li> </ol> <code>dict[str, float]</code> <ol> <li>A dictionary of sorted \u03ba values above the minimum flux.</li> </ol> <code>dict[str, float]</code> <ol> <li>A dictionary of sorted \u03b3 values above the minimum flux.</li> </ol> <code>dict[str, float]</code> <ol> <li>A dictionary of sorted \u03b9 values above the minimum flux.</li> </ol> <code>dict[str, tuple[float, int]]</code> <ol> <li>A dictionary of sorted \u03b1 values above the minimum flux.</li> </ol> <code>tuple[dict[str, float], dict[str, float], dict[str, float], dict[str, float], dict[str, float], dict[str, tuple[float, int]]]</code> <ol> <li>A dictionary of sorted \u03ba\u22c5\u03b3\u22c5\u03b9\u22c5\u03b1 values, along with a status indicator. If, for a reaction, one or more of these efficiency factors is missing, the respective factor is assumed to be 1.0 thus having no effect on the multiplied value.</li> </ol> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef get_df_and_efficiency_factors_sorted_lists(\n    cobrak_model: Model,\n    result: dict[str, float],\n    min_flux: NonNegativeFloat = 0.0,\n) -&gt; tuple[\n    dict[str, float],\n    dict[str, float],\n    dict[str, float],\n    dict[str, float],\n    dict[str, float],\n    dict[str, tuple[float, int]],\n]:\n    \"\"\"Extracts and sorts lists of flux values (df) and \u03ba, \u03b3, \u03b9, \u03b1 values from a result dictionary.\n\n    This function processes a dictionary of results of a COBRA-k optimization\n    to extract and sort lists of flux values (df) and \u03ba, \u03b3, \u03b9, \u03b1 values values. It filters\n    these values based on a minimum flux threshold and returns them as sorted dictionaries.\n    The function also calculates and returns a dictionary of kappa times gamma values,\n    along with a status indicator representing the number of these values present for each reaction.\n\n    Args:\n        cobrak_model: The COBRA-k Model object.\n        result: A dictionary containing optimization results.  Keys are expected to\n            start with prefixes like 'DF_VAR_PREFIX', 'KAPPA_VAR_PREFIX', and 'GAMMA_VAR_PREFIX'.\n        min_flux: The minimum flux value to consider when filtering the results.  Values below this\n            threshold are excluded.  Defaults to 0.0.\n\n    Returns:\n        A tuple containing four dictionaries:\n        1. A dictionary of sorted flux values (df) above the minimum flux.\n        2. A dictionary of sorted \u03ba values above the minimum flux.\n        3. A dictionary of sorted \u03b3 values above the minimum flux.\n        4. A dictionary of sorted \u03b9 values above the minimum flux.\n        5. A dictionary of sorted \u03b1 values above the minimum flux.\n        6. A dictionary of sorted \u03ba\u22c5\u03b3\u22c5\u03b9\u22c5\u03b1 values, along with a status indicator. If, for a reaction,\n           one or more of these efficiency factors is missing, the respective factor is assumed to be 1.0\n           thus having no effect on the multiplied value.\n    \"\"\"\n    dfs: dict[str, float] = {}\n    kappas: dict[str, float] = {}\n    gammas: dict[str, float] = {}\n    iotas: dict[str, float] = {}\n    alphas: dict[str, float] = {}\n    for var_id, value in result.items():\n        if var_id.startswith(DF_VAR_PREFIX):\n            reac_id = var_id[len(DF_VAR_PREFIX) :]\n            dfs[reac_id] = value\n        if var_id.startswith(KAPPA_VAR_PREFIX):\n            reac_id = var_id[len(KAPPA_VAR_PREFIX) :]\n            kappas[reac_id] = value\n        elif var_id.startswith(GAMMA_VAR_PREFIX):\n            reac_id = var_id[len(GAMMA_VAR_PREFIX) :]\n            gammas[reac_id] = value\n        elif var_id.startswith(IOTA_VAR_PREFIX):\n            reac_id = var_id[len(IOTA_VAR_PREFIX) :]\n            iotas[reac_id] = value\n        elif var_id.startswith(ALPHA_VAR_PREFIX):\n            reac_id = var_id[len(ALPHA_VAR_PREFIX) :]\n            alphas[reac_id] = value\n\n    all_multiplied_dict: dict[str, tuple[float, int]] = {}\n    for reac_id in cobrak_model.reactions:\n        status = 0\n        product = 1.0\n        if reac_id in kappas:\n            product *= kappas[reac_id]\n            status += 1\n        if reac_id in gammas:\n            product *= gammas[reac_id]\n            status += 1\n        if reac_id in iotas:\n            product *= iotas[reac_id]\n            status += 1\n        if reac_id in alphas:\n            product *= alphas[reac_id]\n            status += 1\n        all_multiplied_dict[reac_id] = (product, status)\n\n    sorted_df_keys = sorted(dfs, key=lambda k: dfs[k], reverse=False)\n    sorted_kappa_keys = sorted(kappas, key=lambda k: kappas[k], reverse=False)\n    sorted_gamma_keys = sorted(gammas, key=lambda k: gammas[k], reverse=False)\n    sorted_iota_keys = sorted(iotas, key=lambda k: iotas[k], reverse=False)\n    sorted_alpha_keys = sorted(alphas, key=lambda k: alphas[k], reverse=False)\n    sorted_product_keys = sorted(\n        all_multiplied_dict, key=lambda k: all_multiplied_dict[k], reverse=False\n    )\n    return (\n        {key: dfs[key] for key in sorted_df_keys if result[key] &gt; min_flux},\n        {key: kappas[key] for key in sorted_kappa_keys if result[key] &gt; min_flux},\n        {key: gammas[key] for key in sorted_gamma_keys if result[key] &gt; min_flux},\n        {key: iotas[key] for key in sorted_iota_keys if result[key] &gt; min_flux},\n        {key: alphas[key] for key in sorted_alpha_keys if result[key] &gt; min_flux},\n        {\n            key: all_multiplied_dict[key]\n            for key in sorted_product_keys\n            if key in result and result[key] &gt; min_flux\n        },\n    )\n</code></pre>"},{"location":"api.html#cobrak.utilities.get_elementary_conservation_relations","title":"<code>get_elementary_conservation_relations(cobrak_model)</code>","text":"<p>Calculate and return the elementary conservation relations (ECRs) of a COBRAk model as a string.</p> <p>Computes the null space of the stoichiometric matrix of a COBRAk model to determine the elementary conservation relations. It then formats these relations into a human-readable string such as \"1 ATP * 1 ADP\"</p> <p>Parameters:</p> Name Type Description Default <code>cobrak_model</code> <code>Model</code> <p>The COBRAk model containing reactions and metabolites.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string representation of the elementary conservation relations, where each relation is expressed as a linear combination of metabolites.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef get_elementary_conservation_relations(\n    cobrak_model: Model,\n) -&gt; str:\n    \"\"\"Calculate and return the elementary conservation relations (ECRs) of a COBRAk model as a string.\n\n    Computes the null space of the stoichiometric matrix of a COBRAk model to determine the elementary conservation relations.\n    It then formats these relations into a human-readable string such as \"1 ATP * 1 ADP\"\n\n    Args:\n        cobrak_model (Model): The COBRAk model containing reactions and metabolites.\n\n    Returns:\n        str: A string representation of the elementary conservation relations, where each relation is expressed as a linear combination of metabolites.\n    \"\"\"\n    # Convert the list of lists to a sympy Matrix\n    S_matrix = Matrix(get_stoichiometric_matrix(cobrak_model)).T  # type: ignore\n\n    # Calculate the null space of the stoichiometric matrix\n    null_space = S_matrix.nullspace()\n\n    # Convert the null space vectors to a NumPy array\n    ECRs = np.array([ns.T.tolist()[0] for ns in null_space], dtype=float)\n\n    ecrs_list = ECRs.tolist()\n    met_ids = list(cobrak_model.metabolites)\n    conservation_relations = \"\"\n    for current_ecr in range(len(ecrs_list)):\n        ecr = ecrs_list[current_ecr]\n        for current_met in range(len(met_ids)):\n            value = ecr[current_met]\n            if value != 0.0:\n                conservation_relations += f\" {value} * {met_ids[current_met]} \"\n        conservation_relations += \"\\n\"\n\n    return conservation_relations\n</code></pre>"},{"location":"api.html#cobrak.utilities.get_enzyme_usage_by_protein_pool_fraction","title":"<code>get_enzyme_usage_by_protein_pool_fraction(cobrak_model, result, min_conc=1e-12, rounding=5)</code>","text":"<p>Return enzyme usage as a fraction of the total protein pool in a COBRAk model.</p> <p>This function computes the fraction of the total protein pool used by each enzyme based on the given result dictionary. It filters out enzymes with concentrations below a specified minimum and groups the reactions by their protein pool fractions. The dictionary is sorted, i.e., low fractions occur first and high fractions last as keys.</p> <p>Parameters:</p> Name Type Description Default <code>cobrak_model</code> <code>Model</code> <p>The COBRAk model containing reactions and enzyme data.</p> required <code>result</code> <code>dict[str, float]</code> <p>A dictionary mapping variable names to their values, typically from an optimization result.</p> required <code>min_conc</code> <code>float</code> <p>The minimum concentration threshold for considering enzyme usage. Defaults to 1e-12.</p> <code>1e-12</code> <code>rounding</code> <code>int</code> <p>The number of decimal places to round the protein pool fractions. Defaults to 5.</p> <code>5</code> <p>Returns:</p> Type Description <code>dict[NonNegativeFloat, list[str]]</code> <p>dict[NonNegativeFloat, list[str]]: A dictionary where the keys are protein pool fractions and the values are lists of                     reaction IDs that use that fraction of the protein pool.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef get_enzyme_usage_by_protein_pool_fraction(\n    cobrak_model: Model,\n    result: dict[str, float],\n    min_conc: NonNegativeFloat = 1e-12,\n    rounding: NonNegativeInt = 5,\n) -&gt; dict[NonNegativeFloat, list[str]]:\n    \"\"\"Return enzyme usage as a fraction of the total protein pool in a COBRAk model.\n\n    This function computes the fraction of the total protein pool used by each enzyme based on the given result dictionary.\n    It filters out enzymes with concentrations below a specified minimum and groups the reactions by their protein pool fractions.\n    The dictionary is sorted, i.e., low fractions occur first and high fractions last as keys.\n\n    Args:\n        cobrak_model (Model): The COBRAk model containing reactions and enzyme data.\n        result (dict[str, float]): A dictionary mapping variable names to their values, typically from an optimization result.\n        min_conc (float, optional): The minimum concentration threshold for considering enzyme usage. Defaults to 1e-12.\n        rounding (int, optional): The number of decimal places to round the protein pool fractions. Defaults to 5.\n\n    Returns:\n        dict[NonNegativeFloat, list[str]]: A dictionary where the keys are protein pool fractions and the values are lists of\n                                reaction IDs that use that fraction of the protein pool.\n    \"\"\"\n    protein_pool_fractions: dict[float, list[str]] = {}\n    for var_name, value in result.items():\n        if not var_name.startswith(ENZYME_VAR_PREFIX):\n            continue\n        reac_id = var_name.split(ENZYME_VAR_INFIX)[-1]\n        full_mw = get_full_enzyme_mw(cobrak_model, cobrak_model.reactions[reac_id])\n        if value &gt; min_conc:\n            protein_pool_fraction = round(\n                (full_mw * value) / cobrak_model.max_prot_pool, rounding\n            )\n        else:\n            continue\n        if protein_pool_fraction not in protein_pool_fractions:\n            protein_pool_fractions[protein_pool_fraction] = []\n        protein_pool_fractions[protein_pool_fraction].append(reac_id)\n\n    return dict(sorted(protein_pool_fractions.items()))\n</code></pre>"},{"location":"api.html#cobrak.utilities.get_extra_linear_constraint_string","title":"<code>get_extra_linear_constraint_string(extra_linear_constraint)</code>","text":"<p>Returns a string representation of an extra linear constraint.</p> <p>The returned format is: \"lower_value \u2264 stoichiometry * var_id + ... \u2264 upper_value\"</p> <p>Parameters:</p> Name Type Description Default <code>extra_linear_constraint</code> <code>ExtraLinearConstraint</code> <p>The extra linear constraint to convert to a string.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string representation of the extra linear constraint</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef get_extra_linear_constraint_string(\n    extra_linear_constraint: ExtraLinearConstraint,\n) -&gt; str:\n    \"\"\"Returns a string representation of an extra linear constraint.\n\n    The returned format is:\n    \"lower_value \u2264 stoichiometry * var_id + ... \u2264 upper_value\"\n\n    Args:\n        extra_linear_constraint (ExtraLinearConstraint): The extra linear constraint to convert to a string.\n\n    Returns:\n        str: A string representation of the extra linear constraint\n    \"\"\"\n    string = \"\"\n\n    if extra_linear_constraint.lower_value is not None:\n        string += f\"{extra_linear_constraint.lower_value} \u2264 \"\n\n    for var_id, stoichiometry in sort_dict_keys(\n        extra_linear_constraint.stoichiometries\n    ).items():\n        if stoichiometry &gt; 0:\n            printed_stoichiometry = f\" + {stoichiometry}\"\n        else:\n            printed_stoichiometry = f\" - {abs(stoichiometry)}\"\n        string += f\"{printed_stoichiometry} {var_id}\"\n\n    if extra_linear_constraint.upper_value is not None:\n        string += f\"\u2264 {extra_linear_constraint.upper_value}\"\n\n    return string.lstrip()\n</code></pre>"},{"location":"api.html#cobrak.utilities.get_full_enzyme_id","title":"<code>get_full_enzyme_id(identifiers)</code>","text":"<p>Generate a full enzyme ID by concatenating the list of enzyme identifiers with a specific separator.</p> <p>Parameters:</p> Name Type Description Default <code>identifiers</code> <code>list[str]</code> <p>A list of enzyme identifiers.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A single string representing the full enzyme ID, with single identifiers separated by \"AND\".</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef get_full_enzyme_id(identifiers: list[str]) -&gt; str:\n    \"\"\"Generate a full enzyme ID by concatenating the list of enzyme identifiers with a specific separator.\n\n    Args:\n        identifiers (list[str]): A list of enzyme identifiers.\n\n    Returns:\n        str: A single string representing the full enzyme ID, with single identifiers separated by \"_AND_\".\n    \"\"\"\n    return \"_AND_\".join(identifiers)\n</code></pre>"},{"location":"api.html#cobrak.utilities.get_full_enzyme_mw","title":"<code>get_full_enzyme_mw(cobrak_model, reaction)</code>","text":"<p>Calculate the full molecular weight of enzymes (in kDa) involved in a given reaction.</p> <p>This function computes the total molecular weight of all enzymes associated with a specified reaction in the COBRAk model. If the reaction does not have any enzyme reaction data, a ValueError is raised.</p> <ul> <li>If special (i.e. non-1) stoichiometries are provided in the reaction's <code>enzyme_reaction_data</code>, they are used to scale the molecular weights accordingly.</li> <li>If no special stoichiometry is provided for an enzyme, a default stoichiometry of 1 is assumed.</li> <li>The function sums up the molecular weights of all enzymes, multiplied by their respective stoichiometries, to compute the total.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>cobrak_model</code> <code>Model</code> <p>The COBRA-k model containing enzyme data.</p> required <code>reaction</code> <code>Reaction</code> <p>The reaction for which the full enzyme molecular weight is to be calculated.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The total molecular weight of all enzymes involved in the reaction in kDa</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the reaction does not have any enzyme reaction data.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef get_full_enzyme_mw(cobrak_model: Model, reaction: Reaction) -&gt; float:\n    \"\"\"Calculate the full molecular weight of enzymes (in kDa) involved in a given reaction.\n\n    This function computes the total molecular weight of all enzymes associated with a specified reaction in the COBRAk model.\n    If the reaction does not have any enzyme reaction data, a ValueError is raised.\n\n    - If special (i.e. non-1) stoichiometries are provided in the reaction's `enzyme_reaction_data`, they are used to scale the molecular weights accordingly.\n    - If no special stoichiometry is provided for an enzyme, a default stoichiometry of 1 is assumed.\n    - The function sums up the molecular weights of all enzymes, multiplied by their respective stoichiometries, to compute the total.\n\n    Args:\n        cobrak_model (Model): The COBRA-k model containing enzyme data.\n        reaction (Reaction): The reaction for which the full enzyme molecular weight is to be calculated.\n\n    Returns:\n        float: The total molecular weight of all enzymes involved in the reaction in kDa\n\n    Raises:\n        ValueError: If the reaction does not have any enzyme reaction data.\n    \"\"\"\n    if reaction.enzyme_reaction_data is None:\n        raise ValueError\n    full_mw = 0.0\n    for identifier in reaction.enzyme_reaction_data.identifiers:\n        if identifier in reaction.enzyme_reaction_data.special_stoichiometries:\n            stoichiometry = reaction.enzyme_reaction_data.special_stoichiometries[\n                identifier\n            ]\n        else:\n            stoichiometry = 1\n        full_mw += stoichiometry * cobrak_model.enzymes[identifier].molecular_weight\n    return full_mw\n</code></pre>"},{"location":"api.html#cobrak.utilities.get_fwd_rev_corrected_flux","title":"<code>get_fwd_rev_corrected_flux(reac_id, usable_reac_ids, result, fwd_suffix=REAC_FWD_SUFFIX, rev_suffix=REAC_REV_SUFFIX)</code>","text":"<p>Calculates the direction-corrected flux for a reaction, taking into account the flux of its reverse reaction.</p> <p>If the reverse reaction exists and its flux is greater than the flux of the forward reaction, the corrected flux is set to 0.0. Otherwise, the corrected flux is calculated as the difference between the flux of the forward reaction and the flux of the reverse reaction. If the reverse reaction does not exist or is not usable, the corrected flux is set to the flux of the forward reaction.</p> <p>Args: reac_id (str): The ID of the reaction. usable_reac_ids (list[str] | set[str]): A list or set of IDs of reactions that can be used for correction. result (dict[str, float]): A dictionary containing the flux values for each reaction. fwd_suffix (str, optional): The suffix used to identify forward reactions. Defaults to REAC_FWD_SUFFIX. rev_suffix (str, optional): The suffix used to identify reverse reactions. Defaults to REAC_REV_SUFFIX.</p> <p>Returns: float: The corrected flux value for the reaction.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef get_fwd_rev_corrected_flux(\n    reac_id: str,\n    usable_reac_ids: list[str] | set[str],\n    result: dict[str, float],\n    fwd_suffix: str = REAC_FWD_SUFFIX,\n    rev_suffix: str = REAC_REV_SUFFIX,\n) -&gt; float:\n    \"\"\"Calculates the direction-corrected flux for a reaction, taking into account the flux of its reverse reaction.\n\n    If the reverse reaction exists and its flux is greater than the flux of the forward reaction, the corrected flux is set to 0.0.\n    Otherwise, the corrected flux is calculated as the difference between the flux of the forward reaction and the flux of the reverse reaction.\n    If the reverse reaction does not exist or is not usable, the corrected flux is set to the flux of the forward reaction.\n\n    Args:\n    reac_id (str): The ID of the reaction.\n    usable_reac_ids (list[str] | set[str]): A list or set of IDs of reactions that can be used for correction.\n    result (dict[str, float]): A dictionary containing the flux values for each reaction.\n    fwd_suffix (str, optional): The suffix used to identify forward reactions. Defaults to REAC_FWD_SUFFIX.\n    rev_suffix (str, optional): The suffix used to identify reverse reactions. Defaults to REAC_REV_SUFFIX.\n\n    Returns:\n    float: The corrected flux value for the reaction.\n    \"\"\"\n    other_id = get_reverse_reac_id_if_existing(\n        reac_id,\n        fwd_suffix,\n        rev_suffix,\n    )\n    if other_id in usable_reac_ids:\n        other_flux = result[other_id]\n        this_flux = result[reac_id]\n        flux = 0.0 if other_flux &gt; this_flux else this_flux - other_flux\n    else:\n        flux = result[reac_id]\n\n    return flux\n</code></pre>"},{"location":"api.html#cobrak.utilities.get_metabolite_consumption_and_production","title":"<code>get_metabolite_consumption_and_production(cobrak_model, met_id, optimization_dict)</code>","text":"<p>Calculate the consumption and production rates of a metabolite in a COBRAk model.</p> <p>This function computes the total consumption and production of a specified metabolite based on the flux values provided in an optimization dictionary. It iterates through the reactions in the COBRAk model, checking the stoichiometries to determine the metabolite's consumption or production in each reaction.</p> <p>Parameters:</p> Name Type Description Default <code>cobrak_model</code> <code>Model</code> <p>The COBRAk model containing reactions and metabolites.</p> required <code>met_id</code> <code>str</code> <p>The ID of the metabolite for which consumption and production rates are to be calculated.</p> required <code>optimization_dict</code> <code>dict[str, float]</code> <p>A dictionary mapping reaction IDs to their optimized flux values.</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: A tuple containing the total consumption and production rates of the specified metabolite.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef get_metabolite_consumption_and_production(\n    cobrak_model: Model, met_id: str, optimization_dict: dict[str, float]\n) -&gt; tuple[float, float]:\n    \"\"\"Calculate the consumption and production rates of a metabolite in a COBRAk model.\n\n    This function computes the total consumption and production of a specified metabolite\n    based on the flux values provided in an optimization dictionary.\n    It iterates through the reactions in the COBRAk model, checking the stoichiometries to determine the metabolite's\n    consumption or production in each reaction.\n\n    Args:\n        cobrak_model (Model): The COBRAk model containing reactions and metabolites.\n        met_id (str): The ID of the metabolite for which consumption and production rates are to be calculated.\n        optimization_dict (dict[str, float]): A dictionary mapping reaction IDs to their optimized flux values.\n\n    Returns:\n        tuple[float, float]: A tuple containing the total consumption and production rates of the specified metabolite.\n    \"\"\"\n    consumption = 0.0\n    production = 0.0\n    for reac_id, reaction in cobrak_model.reactions.items():\n        if reac_id not in optimization_dict:\n            continue\n        if met_id not in reaction.stoichiometries:\n            continue\n        stoichiometry = reaction.stoichiometries[met_id]\n        if stoichiometry &lt; 0.0:\n            consumption += optimization_dict[reac_id] * stoichiometry\n        else:\n            production += optimization_dict[reac_id] * stoichiometry\n    return consumption, production\n</code></pre>"},{"location":"api.html#cobrak.utilities.get_metabolites_in_elementary_conservation_relations","title":"<code>get_metabolites_in_elementary_conservation_relations(cobrak_model)</code>","text":"<p>Identify metabolites involved in elementary conservation relations (ECRs) in a COBRAk model.</p> <p>Calculates the null space of the stoichiometric matrix of a COBRAk model to determine the elementary conservation relations. It then identifies the metabolites that are part of these relations.</p> <p>Parameters:</p> Name Type Description Default <code>cobrak_model</code> <code>Model</code> <p>The COBRAk model containing reactions and metabolites.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: A list of metabolite IDs that are involved in elementary conservation relations.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef get_metabolites_in_elementary_conservation_relations(\n    cobrak_model: Model,\n) -&gt; list[str]:\n    \"\"\"Identify metabolites involved in elementary conservation relations (ECRs) in a COBRAk model.\n\n    Calculates the null space of the stoichiometric matrix of a COBRAk model to determine the elementary conservation relations.\n    It then identifies the metabolites that are part of these relations.\n\n    Args:\n        cobrak_model (Model): The COBRAk model containing reactions and metabolites.\n\n    Returns:\n        list[str]: A list of metabolite IDs that are involved in elementary conservation relations.\n    \"\"\"\n    # Convert the list of lists to a sympy Matrix\n    S_matrix = array(get_stoichiometric_matrix(cobrak_model)).T\n\n    # Calculate the null space of the stoichiometric matrix using Gaussian elimination\n    null_spacex = null_space(S_matrix)\n\n    # Convert the null space vectors to a NumPy array\n    ECRs = (\n        null_spacex.T\n    )  # np.array([ns.T.tolist()[0] for ns in null_spacex], dtype=float)\n\n    # Simplify the ECRs by removing near-zero elements\n    threshold = 1e-10\n    ECRs[np.abs(ECRs) &lt; threshold] = 0\n    met_ids = list(cobrak_model.metabolites)\n\n    dependencies = []\n    for ecr in ECRs.tolist():\n        for entry_num in range(len(ecr)):\n            if ecr[entry_num] != 0.0:\n                dependencies.append(met_ids[entry_num])\n    return list(set(dependencies))\n</code></pre>"},{"location":"api.html#cobrak.utilities.get_model_dG0s","title":"<code>get_model_dG0s(cobrak_model, abs_values=False)</code>","text":"<p>Extracts standard Gibbs free energy changes (dG0) from reactions in the model.</p> <p>Parameters:</p> Name Type Description Default <code>cobrak_model</code> <code>Model</code> <p>The COBRAk model containing reactions with thermodynamic data.</p> required <code>abs_values</code> <code>bool</code> <p>If True, returns absolute values of dG0. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: A list of dG0 values, possibly as absolute values if specified.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef get_model_dG0s(cobrak_model: Model, abs_values: bool = False) -&gt; list[float]:\n    \"\"\"Extracts standard Gibbs free energy changes (dG0) from reactions in the model.\n\n    Args:\n        cobrak_model (Model): The COBRAk model containing reactions with thermodynamic data.\n        abs_values (bool, optional): If True, returns absolute values of dG0. Defaults to False.\n\n    Returns:\n        list[float]: A list of dG0 values, possibly as absolute values if specified.\n    \"\"\"\n    dG0s = []\n    for reac_id, reaction in cobrak_model.reactions.items():\n        if reac_id.endswith(\"_bw\"):\n            continue\n        if reaction.dG0 is not None:\n            dG0s.append(abs(reaction.dG0) if abs_values else reaction.dG0)\n    return dG0s\n</code></pre>"},{"location":"api.html#cobrak.utilities.get_model_hill_coefficients","title":"<code>get_model_hill_coefficients(cobrak_model, return_only_values_with_reference=False)</code>","text":"<p>Collects k_A values from a COBRA-k model.</p> <p>This function iterates through the reactions in a COBRA-k model and extracts the k_A values associated with each metabolite</p> <p>Parameters:</p> Name Type Description Default <code>cobrak_model</code> <code>Model</code> <p>The COBRA-k Model object.</p> required <code>return_only_values_with_reference</code> <code>bool</code> <p>Returns only values with a given database reference. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[PositiveFloat]</code> <p>A tuple containing three lists: the first list contains \u03ba Hill coefficients, the second</p> <code>list[PositiveFloat]</code> <p>\u03b9 Hill coefficients, the third \u03b1 Hill coefficients.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef get_model_hill_coefficients(\n    cobrak_model: Model,\n    return_only_values_with_reference: bool = False,\n) -&gt; list[PositiveFloat]:\n    \"\"\"Collects k_A values from a COBRA-k model.\n\n    This function iterates through the reactions in a COBRA-k model and extracts the\n    k_A values associated with each metabolite\n\n    Args:\n        cobrak_model: The COBRA-k Model object.\n        return_only_values_with_reference: Returns only values with a given database reference. Defaults to False.\n\n    Returns:\n        A tuple containing three lists: the first list contains \u03ba Hill coefficients, the second\n        \u03b9 Hill coefficients, the third \u03b1 Hill coefficients.\n    \"\"\"\n    kappa_hills: list[PositiveFloat] = []\n    iota_hills: list[PositiveFloat] = []\n    alpha_hills: list[PositiveFloat] = []\n    for reaction in cobrak_model.reactions.values():\n        if reaction.enzyme_reaction_data is None:\n            continue\n\n        # \u03ba Hills\n        for (\n            met_id,\n            hill_coefficient,\n        ) in reaction.enzyme_reaction_data.hill_coefficients.kappa.items():\n            if return_only_values_with_reference:\n                references = (\n                    reaction.enzyme_reaction_data.hill_coefficient_references.kappa\n                )\n                if (met_id not in references) or (len(references[met_id]) == 0):\n                    tax_distance = -1\n                else:\n                    tax_distance = references[met_id][0].tax_distance\n                if tax_distance &lt; 0:\n                    continue\n            kappa_hills.append(hill_coefficient)\n\n        # \u03b9 Hills\n        for (\n            met_id,\n            hill_coefficient,\n        ) in reaction.enzyme_reaction_data.hill_coefficients.iota.items():\n            if return_only_values_with_reference:\n                references = (\n                    reaction.enzyme_reaction_data.hill_coefficient_references.iota\n                )\n                if (met_id not in references) or (len(references[met_id]) == 0):\n                    tax_distance = -1\n                else:\n                    tax_distance = references[met_id][0].tax_distance\n                if tax_distance &lt; 0:\n                    continue\n            iota_hills.append(hill_coefficient)\n\n        # \u03b1 Hills\n        for (\n            met_id,\n            hill_coefficient,\n        ) in reaction.enzyme_reaction_data.hill_coefficients.alpha.items():\n            if return_only_values_with_reference:\n                references = (\n                    reaction.enzyme_reaction_data.hill_coefficient_references.alpha\n                )\n                if (met_id not in references) or (len(references[met_id]) == 0):\n                    tax_distance = -1\n                else:\n                    tax_distance = references[met_id][0].tax_distance\n                if tax_distance &lt; 0:\n                    continue\n            alpha_hills.append(hill_coefficient)\n\n    return kappa_hills, iota_hills, alpha_hills\n</code></pre>"},{"location":"api.html#cobrak.utilities.get_model_kas","title":"<code>get_model_kas(cobrak_model, return_only_values_with_reference=False)</code>","text":"<p>Collects k_A values from a COBRA-k model.</p> <p>This function iterates through the reactions in a COBRA-k model and extracts the k_A values associated with each metabolite</p> <p>Parameters:</p> Name Type Description Default <code>cobrak_model</code> <code>Model</code> <p>The COBRA-k Model object.</p> required <code>return_only_values_with_reference</code> <code>bool</code> <p>Returns only values with a given database reference. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[PositiveFloat]</code> <p>A list containing the k_A values</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef get_model_kas(\n    cobrak_model: Model,\n    return_only_values_with_reference: bool = False,\n) -&gt; list[PositiveFloat]:\n    \"\"\"Collects k_A values from a COBRA-k model.\n\n    This function iterates through the reactions in a COBRA-k model and extracts the\n    k_A values associated with each metabolite\n\n    Args:\n        cobrak_model: The COBRA-k Model object.\n        return_only_values_with_reference: Returns only values with a given database reference. Defaults to False.\n\n    Returns:\n        A list containing the k_A values\n    \"\"\"\n    all_kas: list[PositiveFloat] = []\n    for reaction in cobrak_model.reactions.values():\n        if reaction.enzyme_reaction_data is None:\n            continue\n        for met_id, k_a in reaction.enzyme_reaction_data.k_as.items():\n            if return_only_values_with_reference:\n                references = reaction.enzyme_reaction_data.k_a_references\n                if (met_id not in references) or (len(references[met_id]) == 0):\n                    tax_distance = -1\n                else:\n                    tax_distance = references[met_id][0].tax_distance\n                if tax_distance &lt; 0:\n                    continue\n            all_kas.append(k_a)\n    return all_kas\n</code></pre>"},{"location":"api.html#cobrak.utilities.get_model_kcats","title":"<code>get_model_kcats(cobrak_model)</code>","text":"<p>Extracts k_cat values from reactions with enzyme data in the model.</p> <p>Parameters:</p> Name Type Description Default <code>cobrak_model</code> <code>Model</code> <p>The COBRAk model containing reactions with enzyme data.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: A list of k_cat values for reactions with available enzyme data.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef get_model_kcats(cobrak_model: Model) -&gt; list[float]:\n    \"\"\"Extracts k_cat values from reactions with enzyme data in the model.\n\n    Args:\n        cobrak_model (Model): The COBRAk model containing reactions with enzyme data.\n\n    Returns:\n        list[float]: A list of k_cat values for reactions with available enzyme data.\n    \"\"\"\n    kcats = []\n    for reaction in cobrak_model.reactions.values():\n        if reaction.enzyme_reaction_data is not None:\n            kcats.append(reaction.enzyme_reaction_data.k_cat)\n    return kcats\n</code></pre>"},{"location":"api.html#cobrak.utilities.get_model_kis","title":"<code>get_model_kis(cobrak_model, return_only_values_with_reference=False)</code>","text":"<p>Collects k_I values from a COBRA-k model.</p> <p>This function iterates through the reactions in a COBRA-k model and extracts the k_I values associated with each metabolite</p> <p>Parameters:</p> Name Type Description Default <code>cobrak_model</code> <code>Model</code> <p>The COBRA-k Model object.</p> required <code>return_only_values_with_reference</code> <code>bool</code> <p>Returns only values with a given database reference. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[PositiveFloat]</code> <p>A list containing the k_I values</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef get_model_kis(\n    cobrak_model: Model,\n    return_only_values_with_reference: bool = False,\n) -&gt; list[PositiveFloat]:\n    \"\"\"Collects k_I values from a COBRA-k model.\n\n    This function iterates through the reactions in a COBRA-k model and extracts the\n    k_I values associated with each metabolite\n\n    Args:\n        cobrak_model: The COBRA-k Model object.\n        return_only_values_with_reference: Returns only values with a given database reference. Defaults to False.\n\n    Returns:\n        A list containing the k_I values\n    \"\"\"\n    all_kis: list[PositiveFloat] = []\n    for reaction in cobrak_model.reactions.values():\n        if reaction.enzyme_reaction_data is None:\n            continue\n        for met_id, k_i in reaction.enzyme_reaction_data.k_is.items():\n            if return_only_values_with_reference:\n                references = reaction.enzyme_reaction_data.k_i_references\n                if (met_id not in references) or (len(references[met_id]) == 0):\n                    tax_distance = -1\n                else:\n                    tax_distance = references[met_id][0].tax_distance\n                if tax_distance &lt; 0:\n                    continue\n            all_kis.append(k_i)\n    return all_kis\n</code></pre>"},{"location":"api.html#cobrak.utilities.get_model_kms","title":"<code>get_model_kms(cobrak_model)</code>","text":"<p>Extracts k_m values from reactions with enzyme data in the model.</p> <p>Parameters:</p> Name Type Description Default <code>cobrak_model</code> <code>Model</code> <p>The COBRAk model containing reactions with enzyme data.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: A flat list of k_m values from all reactions with available enzyme data.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef get_model_kms(cobrak_model: Model) -&gt; list[float]:\n    \"\"\"Extracts k_m values from reactions with enzyme data in the model.\n\n    Args:\n        cobrak_model (Model): The COBRAk model containing reactions with enzyme data.\n\n    Returns:\n        list[float]: A flat list of k_m values from all reactions with available enzyme data.\n    \"\"\"\n    kms = []\n    for reaction in cobrak_model.reactions.values():\n        if reaction.enzyme_reaction_data is not None:\n            kms.extend(list(reaction.enzyme_reaction_data.k_ms.values()))\n    return kms\n</code></pre>"},{"location":"api.html#cobrak.utilities.get_model_kms_by_usage","title":"<code>get_model_kms_by_usage(cobrak_model, return_only_values_with_reference=False)</code>","text":"<p>Collects k_M values from a COBRA-k model, separating them into substrate and product lists.</p> <p>This function iterates through the reactions in a COBRA-k model and extracts the k_M values associated with each metabolite. It distinguishes between substrates (metabolites with negative stoichiometry) and products (metabolites with positive stoichiometry) and separates the corresponding Kms values into two lists.</p> <p>Parameters:</p> Name Type Description Default <code>cobrak_model</code> <code>Model</code> <p>The COBRA-k Model object.</p> required <code>return_only_values_with_reference</code> <code>bool</code> <p>Returns only values with a given database reference. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[PositiveFloat]</code> <p>A tuple containing two lists: the first list contains k_M values for substrates,</p> <code>list[PositiveFloat]</code> <p>and the second list contains k_M values for products.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef get_model_kms_by_usage(\n    cobrak_model: Model,\n    return_only_values_with_reference: bool = False,\n) -&gt; tuple[list[PositiveFloat], list[PositiveFloat]]:\n    \"\"\"Collects k_M values from a COBRA-k model, separating them into substrate and product lists.\n\n    This function iterates through the reactions in a COBRA-k model and extracts the\n    k_M values associated with each metabolite. It distinguishes between substrates\n    (metabolites with negative stoichiometry) and products (metabolites with positive\n    stoichiometry) and separates the corresponding Kms values into two lists.\n\n    Args:\n        cobrak_model: The COBRA-k Model object.\n        return_only_values_with_reference: Returns only values with a given database reference. Defaults to False.\n\n    Returns:\n        A tuple containing two lists: the first list contains k_M values for substrates,\n        and the second list contains k_M values for products.\n    \"\"\"\n    substrate_kms: list[PositiveFloat] = []\n    product_kms: list[PositiveFloat] = []\n    for reaction in cobrak_model.reactions.values():\n        if reaction.enzyme_reaction_data is None:\n            continue\n        for met_id, stoichiometry in reaction.stoichiometries.items():\n            if met_id not in reaction.enzyme_reaction_data.k_ms:\n                continue\n            if return_only_values_with_reference:\n                references = reaction.enzyme_reaction_data.k_m_references\n                if (met_id not in references) or (len(references[met_id]) == 0):\n                    tax_distance = -1\n                else:\n                    tax_distance = references[met_id][0].tax_distance\n                if tax_distance &lt; 0:\n                    continue\n            met_km = reaction.enzyme_reaction_data.k_ms[met_id]\n            if stoichiometry &lt; 0:\n                substrate_kms.append(met_km)\n            else:\n                product_kms.append(met_km)\n    return substrate_kms, product_kms\n</code></pre>"},{"location":"api.html#cobrak.utilities.get_model_max_kcat_times_e_values","title":"<code>get_model_max_kcat_times_e_values(cobrak_model)</code>","text":"<p>Calculates the maximum k_cat * E (enzyme concentration in terms of its molecular weight) for each reaction with enzyme data and returns these values.</p> <p>The maximal k_catE is \u03a9k_cat/W, with \u03a9 as protein pool and W as enzyme molecular weight.</p> <p>Parameters:</p> Name Type Description Default <code>cobrak_model</code> <code>Model</code> <p>A metabolic model instance that includes enzymatic constraints,                   which must contain Reaction instances with enzyme_reaction_data.</p> required <p>Returns:</p> Type Description <code>list[NonNegativeFloat]</code> <p>List[float]: A list containing the calculated maximum k_cat * E values for reactions          having enzyme reaction data.</p> Notes <ul> <li>The function requires 'reaction.enzyme_reaction_data.k_cat' and   'get_full_enzyme_mw(cobrak_model, reaction)' to be non-zero.</li> <li>If a reaction lacks enzyme reaction data, it is skipped in the calculation.</li> </ul> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef get_model_max_kcat_times_e_values(cobrak_model: Model) -&gt; list[NonNegativeFloat]:\n    \"\"\"Calculates the maximum k_cat * E (enzyme concentration in terms of its molecular weight)\n    for each reaction with enzyme data and returns these values.\n\n    The maximal k_cat*E is \u03a9*k_cat/W, with \u03a9 as protein pool and W as enzyme molecular weight.\n\n    Parameters:\n        cobrak_model (Model): A metabolic model instance that includes enzymatic constraints,\n                              which must contain Reaction instances with enzyme_reaction_data.\n\n    Returns:\n        List[float]: A list containing the calculated maximum k_cat * E values for reactions\n                     having enzyme reaction data.\n\n    Notes:\n        - The function requires 'reaction.enzyme_reaction_data.k_cat' and\n          'get_full_enzyme_mw(cobrak_model, reaction)' to be non-zero.\n        - If a reaction lacks enzyme reaction data, it is skipped in the calculation.\n    \"\"\"\n    max_kcat_times_e_values: list[float] = []\n    for reaction in cobrak_model.reactions.values():\n        if reaction.enzyme_reaction_data is None:\n            continue\n        max_kcat_times_e_values.append(\n            reaction.enzyme_reaction_data.k_cat\n            * cobrak_model.max_prot_pool\n            / get_full_enzyme_mw(cobrak_model, reaction)\n        )\n    return max_kcat_times_e_values\n</code></pre>"},{"location":"api.html#cobrak.utilities.get_model_mws","title":"<code>get_model_mws(cobrak_model)</code>","text":"<p>Extracts molecular weights of enzymes from the model.</p> <p>Parameters:</p> Name Type Description Default <code>cobrak_model</code> <code>Model</code> <p>The COBRAk model containing enzyme data.</p> required <p>Returns:</p> Type Description <code>list[PositiveFloat]</code> <p>list[PositiveFloat]: A list of molecular weights for each enzyme in the model.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef get_model_mws(cobrak_model: Model) -&gt; list[PositiveFloat]:\n    \"\"\"Extracts molecular weights of enzymes from the model.\n\n    Args:\n        cobrak_model (Model): The COBRAk model containing enzyme data.\n\n    Returns:\n        list[PositiveFloat]: A list of molecular weights for each enzyme in the model.\n    \"\"\"\n    mws = []\n    for enzyme in cobrak_model.enzymes.values():\n        mws.append(enzyme.molecular_weight)\n    return mws\n</code></pre>"},{"location":"api.html#cobrak.utilities.get_model_with_filled_missing_parameters","title":"<code>get_model_with_filled_missing_parameters(cobrak_model, add_dG0_extra_constraints=False, param_percentile=90, ignore_prefixes=['EX_'], use_median_for_kms=True, use_median_for_kcats=True)</code>","text":"<p>Fills missing parameters in a COBRA-k model, including dG0, k_cat, and k_ms values.</p> <p>This function iterates through the reactions in a COBRA-k model and fills in missing parameters based on percentile values from the entire model.  Missing dG0 values are filled using a percentile of the absolute dG0 values.  Missing k_cat values are filled using a percentile or median of the k_cat values.  Missing k_ms values are filled using a percentile or median of the k_ms values, depending on whether the metabolite is a substrate or a product.  Optionally, extra linear constraints can be added to enforce consistency between the dG0 values of coupled reversible reactions.</p> <p>Parameters:</p> Name Type Description Default <code>cobrak_model</code> <code>Model</code> <p>The COBRA-k Model object to be modified.</p> required <code>add_dG0_extra_constraints</code> <code>bool</code> <p>Whether to add extra linear constraints for reversible reactions. Defaults to False.</p> <code>False</code> <code>param_percentile</code> <code>conint(ge=0, le=100)</code> <p>The percentile to use for filling missing parameters. Defaults to 90.</p> <code>90</code> <code>ignore_prefixes</code> <code>list[str]</code> <p>List of prefixes to ignore when processing reactions. Defaults to [\"EX_\"] (i.e. exchange reactions).</p> <code>['EX_']</code> <code>use_median_for_kms</code> <code>bool</code> <p>Whether to use the median instead of the percentile for k_ms values. Defaults to True.</p> <code>True</code> <code>use_median_for_kcats</code> <code>bool</code> <p>Whether to use the median instead of the percentile for k_cat values. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Model</code> <p>A deep copy of the input COBRA-k model with missing parameters filled.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef get_model_with_filled_missing_parameters(\n    cobrak_model: Model,\n    add_dG0_extra_constraints: bool = False,\n    param_percentile: conint(ge=0, le=100) = 90,\n    ignore_prefixes: list[str] = [\"EX_\"],\n    use_median_for_kms: bool = True,\n    use_median_for_kcats: bool = True,\n) -&gt; Model:\n    \"\"\"Fills missing parameters in a COBRA-k model, including dG0, k_cat, and k_ms values.\n\n    This function iterates through the reactions in a COBRA-k model and fills in missing\n    parameters based on percentile values from the entire model.  Missing dG0 values\n    are filled using a percentile of the absolute dG0 values.  Missing k_cat values\n    are filled using a percentile or median of the k_cat values.  Missing k_ms values\n    are filled using a percentile or median of the k_ms values, depending on whether\n    the metabolite is a substrate or a product.  Optionally, extra linear constraints\n    can be added to enforce consistency between the dG0 values of coupled reversible\n    reactions.\n\n    Args:\n        cobrak_model: The COBRA-k Model object to be modified.\n        add_dG0_extra_constraints: Whether to add extra linear constraints for reversible reactions. Defaults to False.\n        param_percentile: The percentile to use for filling missing parameters. Defaults to 90.\n        ignore_prefixes: List of prefixes to ignore when processing reactions. Defaults to [\"EX_\"] (i.e. exchange reactions).\n        use_median_for_kms: Whether to use the median instead of the percentile for k_ms values. Defaults to True.\n        use_median_for_kcats: Whether to use the median instead of the percentile for k_cat values. Defaults to True.\n\n    Returns:\n        A deep copy of the input COBRA-k model with missing parameters filled.\n    \"\"\"\n    cobrak_model = deepcopy(cobrak_model)\n\n    all_mws = get_model_mws(cobrak_model)\n    all_kcats = get_model_kcats(cobrak_model)\n    substrate_kms, product_kms = get_model_kms_by_usage(cobrak_model)\n    all_abs_dG0s = [abs(dG0) for dG0 in get_model_dG0s(cobrak_model)]\n    dG0_reverse_couples: set[tuple[str]] = set()\n    for reac_id in cobrak_model.reactions:\n        if sum(reac_id.startswith(ignore_prefix) for ignore_prefix in ignore_prefixes):\n            continue\n        if cobrak_model.reactions[reac_id].dG0 is None:\n            reverse_id = get_reverse_reac_id_if_existing(\n                reac_id, cobrak_model.fwd_suffix, cobrak_model.rev_suffix\n            )\n            reverse_id = reverse_id if reverse_id in cobrak_model.reactions else \"\"\n            if add_dG0_extra_constraints and reverse_id:\n                dG0_reverse_couples.add(tuple(sorted([reac_id, reverse_id])))\n                cobrak_model.reactions[reac_id].dG0 = 0.0\n                cobrak_model.reactions[reac_id].dG0_uncertainty = percentile(\n                    all_abs_dG0s, param_percentile\n                )\n            else:\n                cobrak_model.reactions[reac_id].dG0 = -percentile(\n                    all_abs_dG0s, param_percentile\n                )\n        if (cobrak_model.reactions[reac_id].enzyme_reaction_data is None) or (\n            \"\" in cobrak_model.reactions[reac_id].enzyme_reaction_data.identifiers\n        ):\n            enzyme_substitue_id = f\"{reac_id}_enzyme_substitute\"\n            if not use_median_for_kcats:\n                cobrak_model.reactions[\n                    reac_id\n                ].enzyme_reaction_data = EnzymeReactionData(\n                    identifiers=[enzyme_substitue_id],\n                    k_cat=percentile(all_kcats, param_percentile),\n                )\n            else:\n                cobrak_model.reactions[\n                    reac_id\n                ].enzyme_reaction_data = EnzymeReactionData(\n                    identifiers=[enzyme_substitue_id],\n                    k_cat=median(all_kcats),\n                )\n            cobrak_model.enzymes[enzyme_substitue_id] = Enzyme(\n                molecular_weight=percentile(all_mws, 100 - param_percentile),\n            )\n        if not have_all_unignored_km(\n            cobrak_model.reactions[reac_id], cobrak_model.kinetic_ignored_metabolites\n        ):\n            existing_kms: list[str] = list(\n                cobrak_model.reactions[reac_id].enzyme_reaction_data.k_ms.keys()\n            )\n            for met_id, stoichiometry in cobrak_model.reactions[\n                reac_id\n            ].stoichiometries.items():\n                if (met_id in cobrak_model.kinetic_ignored_metabolites) or (\n                    met_id in existing_kms\n                ):\n                    continue\n                if not use_median_for_kms:\n                    cobrak_model.reactions[reac_id].enzyme_reaction_data.k_ms[\n                        met_id\n                    ] = float(\n                        percentile(\n                            product_kms if stoichiometry &gt; 0.0 else substrate_kms,\n                            param_percentile\n                            if stoichiometry &gt; 0.0\n                            else 100 - param_percentile,\n                        )\n                    )\n                else:\n                    cobrak_model.reactions[reac_id].enzyme_reaction_data.k_ms[\n                        met_id\n                    ] = (\n                        median(substrate_kms)\n                        if stoichiometry &lt; 0.0\n                        else median(product_kms)\n                    )\n\n    for dG0_reverse_couple in dG0_reverse_couples:\n        reac_id_1, reac_id_2 = dG0_reverse_couple\n        cobrak_model.extra_linear_constraints.append(\n            ExtraLinearConstraint(\n                stoichiometries={\n                    f\"{DG0_VAR_PREFIX}{reac_id_1}\": 1.0,\n                    f\"{DG0_VAR_PREFIX}{reac_id_2}\": 1.0,\n                },\n                lower_value=0.0,\n                upper_value=0.0,\n            )\n        )\n\n    return cobrak_model\n</code></pre>"},{"location":"api.html#cobrak.utilities.get_model_with_varied_parameters","title":"<code>get_model_with_varied_parameters(model, max_km_variation=None, max_kcat_variation=None, max_ki_variation=None, max_ka_variation=None, max_dG0_variation=None, varied_reacs=[], change_unknown_values=True, change_known_values=True, use_shuffling_instead_of_uniform_random=False, shuffle_using_distribution_of_values_with_reference=True)</code>","text":"<p>Generates a modified copy of the input Model with varied reaction parameters.</p> <p>This function creates a deep copy of the input Model and introduces random variations to several reaction parameters, including dG0, k_cat, k_ms, k_is, and k_as.  The magnitude of the variation is controlled by the provided <code>max_..._variation</code> parameters.  If a <code>max_..._variation</code> parameter is not provided (i.e., is None), the corresponding parameter will not be varied.  Variations are applied randomly using a uniform distribution.  For reactions with a reverse reaction, the dG0 values of the forward and reverse reactions are updated to maintain thermodynamic consistency.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The Model object to be modified.</p> required <code>max_km_variation</code> <code>NonNegativeFloat | None</code> <p>Maximum factor by which to vary Kms.  Defaults to None. No effect (except if it is None, then nothing happens) if <code>use_shuffling_instead_of_uniform_random=True</code>.</p> <code>None</code> <code>max_kcat_variation</code> <code>NonNegativeFloat | None</code> <p>Maximum factor by which to vary k_cat. Defaults to None. No effect (except if it is None, then nothing happens) if <code>use_shuffling_instead_of_uniform_random=True</code>.</p> <code>None</code> <code>max_ki_variation</code> <code>NonNegativeFloat | None</code> <p>Maximum factor by which to vary k_is. Defaults to None. No effect (except if it is None, then nothing happens) if <code>use_shuffling_instead_of_uniform_random=True</code>.</p> <code>None</code> <code>max_ka_variation</code> <code>NonNegativeFloat | None</code> <p>Maximum factor by which to vary k_as. Defaults to None. No effect (except if it is None, then nothing happens) if <code>use_shuffling_instead_of_uniform_random=True</code>.</p> <code>None</code> <code>max_dG0_variation</code> <code>NonNegativeFloat | None</code> <p>Maximum factor by which to vary dG0. Defaults to None. No effect (except if it is None, then nothing happens) if <code>use_shuffling_instead_of_uniform_random=True</code>.</p> <code>None</code> <code>varied_reacs</code> <code>list[str]</code> <p>If not [], only reactions with IDs in this list are varied. Defaults to [].</p> <code>[]</code> <code>change_known_values</code> <code>bool</code> <p>Change values if they are set with a taxonomic distance in their reference. Defaults to True.</p> <code>True</code> <code>change_unknown_values</code> <code>bool</code> <p>Change values if they are not set with a taxonomic distance in their reference. Defaults to True.</p> <code>True</code> <code>use_shuffling_instead_of_uniform_random</code> <code>bool</code> <p>Overwrites max variation parameters, and switches to shuffling inside the known kcats, educt kms, product kms and so on.</p> <code>False</code> <code>shuffle_using_distribution_of_values_with_reference</code> <code>bool</code> <p>If True (the default), the shuffling will only choose values with a reference for the shuffling; note that if <code>change_unknown_values=True</code>, the unknown values will still be shuffled, but if ```shuffle_using_distribution_of_values_with_reference=True```` just using the distribution with values with references.</p> <code>True</code> <p>Returns:</p> Type Description <code>Model</code> <p>A deep copy of the input model with varied reaction parameters.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef get_model_with_varied_parameters(\n    model: Model,\n    max_km_variation: NonNegativeFloat | None = None,\n    max_kcat_variation: NonNegativeFloat | None = None,\n    max_ki_variation: NonNegativeFloat | None = None,\n    max_ka_variation: NonNegativeFloat | None = None,\n    max_dG0_variation: NonNegativeFloat | None = None,\n    varied_reacs: list[str] = [],\n    change_unknown_values: bool = True,\n    change_known_values: bool = True,\n    use_shuffling_instead_of_uniform_random: bool = False,\n    shuffle_using_distribution_of_values_with_reference: bool = True,\n) -&gt; Model:\n    \"\"\"Generates a modified copy of the input Model with varied reaction parameters.\n\n    This function creates a deep copy of the input Model and introduces random variations\n    to several reaction parameters, including dG0, k_cat, k_ms, k_is, and k_as.  The\n    magnitude of the variation is controlled by the provided `max_..._variation`\n    parameters.  If a `max_..._variation` parameter is not provided (i.e., is None),\n    the corresponding parameter will not be varied.  Variations are applied randomly\n    using a uniform distribution.  For reactions with a reverse reaction, the dG0 values\n    of the forward and reverse reactions are updated to maintain thermodynamic consistency.\n\n    Args:\n        model: The Model object to be modified.\n        max_km_variation: Maximum factor by which to vary Kms.  Defaults to None.\n            No effect (except if it is None, then nothing happens) if ```use_shuffling_instead_of_uniform_random=True```.\n        max_kcat_variation: Maximum factor by which to vary k_cat. Defaults to None.\n            No effect (except if it is None, then nothing happens) if ```use_shuffling_instead_of_uniform_random=True```.\n        max_ki_variation: Maximum factor by which to vary k_is. Defaults to None.\n            No effect (except if it is None, then nothing happens) if ```use_shuffling_instead_of_uniform_random=True```.\n        max_ka_variation: Maximum factor by which to vary k_as. Defaults to None.\n            No effect (except if it is None, then nothing happens) if ```use_shuffling_instead_of_uniform_random=True```.\n        max_dG0_variation: Maximum factor by which to vary dG0. Defaults to None.\n            No effect (except if it is None, then nothing happens) if ```use_shuffling_instead_of_uniform_random=True```.\n        varied_reacs: If not [], only reactions with IDs in this list are varied. Defaults to [].\n        change_known_values: Change values if they *are* set with a\n            taxonomic distance in their reference. Defaults to True.\n        change_unknown_values: Change values if they are *not* set with a\n            taxonomic distance in their reference. Defaults to True.\n        use_shuffling_instead_of_uniform_random: Overwrites max variation parameters, and switches\n            to shuffling inside the known kcats, educt kms, product kms and so on.\n        shuffle_using_distribution_of_values_with_reference: If True (the default), the shuffling will only\n            choose values with a reference for the shuffling; note that if ```change_unknown_values=True```,\n            the unknown values will still be shuffled, but if ```shuffle_using_distribution_of_values_with_reference=True````\n            just using the distribution with values with references.\n\n    Returns:\n        A deep copy of the input model with varied reaction parameters.\n    \"\"\"\n    varied_model = deepcopy(model)\n    tested_rev_reacs: list[str] = []\n    if use_shuffling_instead_of_uniform_random:\n        substrate_kms, product_kms = get_model_kms_by_usage(\n            model,\n            return_only_values_with_reference=shuffle_using_distribution_of_values_with_reference,\n        )\n        if max_dG0_variation is not None:\n            all_dG0s = get_model_dG0s(model)\n        if max_kcat_variation is not None:\n            all_kcats = get_model_kcats(model)\n        if max_ki_variation is not None:\n            all_kis = get_model_kis(model)\n        if max_ka_variation is not None:\n            all_kas = get_model_kas(model)\n    for reac_id, reaction in varied_model.reactions.items():\n        if (varied_reacs != []) and (reac_id not in varied_reacs):\n            continue\n        if (\n            max_dG0_variation is not None\n            and reaction.dG0 is not None\n            and reac_id not in tested_rev_reacs\n        ):\n            if use_shuffling_instead_of_uniform_random:\n                reaction.dG0 = choice(all_dG0s)\n            else:\n                reaction.dG0 += uniform(-max_dG0_variation, +max_dG0_variation)  # noqa: NPY002\n            rev_id = get_reverse_reac_id_if_existing(\n                reac_id=reac_id,\n                fwd_suffix=varied_model.fwd_suffix,\n                rev_suffix=varied_model.rev_suffix,\n            )\n            if rev_id in varied_model.reactions:\n                varied_model.reactions[rev_id].dG0 = -reaction.dG0\n                tested_rev_reacs.append(rev_id)\n        if reaction.enzyme_reaction_data is not None:\n            if max_kcat_variation is not None:\n                kcat_tax_distance = (\n                    -1\n                    if len(reaction.enzyme_reaction_data.k_cat_references) == 0\n                    else reaction.enzyme_reaction_data.k_cat_references[0].tax_distance\n                )\n                if (change_known_values and kcat_tax_distance &gt;= 0) or (\n                    change_unknown_values and kcat_tax_distance &lt; 0\n                ):\n                    if use_shuffling_instead_of_uniform_random:\n                        reaction.enzyme_reaction_data.k_cat = choice(all_kcats)\n                    else:\n                        reaction.enzyme_reaction_data.k_cat *= max_kcat_variation ** (\n                            uniform(-1, 1)  # noqa: NPY002\n                        )  # noqa: NPY002\n            if max_km_variation is not None:\n                for met_id in reaction.enzyme_reaction_data.k_ms:\n                    references = reaction.enzyme_reaction_data.k_m_references\n                    km_tax_distance = (\n                        -1\n                        if met_id not in references or len(references[met_id]) == 0\n                        else references[met_id][0].tax_distance\n                    )\n                    if not (\n                        (change_known_values and km_tax_distance &gt;= 0)\n                        or (change_unknown_values and km_tax_distance &lt; 0)\n                    ):\n                        continue\n                    if (\n                        met_id in reaction.stoichiometries\n                        and reaction.stoichiometries[met_id] &lt; 0.0\n                    ):  # Substrate k_ms\n                        if use_shuffling_instead_of_uniform_random:\n                            reaction.enzyme_reaction_data.k_ms[met_id] = choice(\n                                substrate_kms\n                            )\n                        else:\n                            reaction.enzyme_reaction_data.k_ms[met_id] *= (\n                                max_km_variation ** (uniform(-1, 1))  # noqa: NPY002\n                            )  # noqa: NPY002\n                    else:  # Product k_ms\n                        if use_shuffling_instead_of_uniform_random:\n                            reaction.enzyme_reaction_data.k_ms[met_id] = choice(\n                                product_kms\n                            )\n                        else:\n                            reaction.enzyme_reaction_data.k_ms[met_id] *= (\n                                max_km_variation ** (uniform(-1, 1))  # noqa: NPY002\n                            )  # noqa: NPY002\n            if max_ki_variation is not None:\n                references = reaction.enzyme_reaction_data.k_i_references\n                ki_tax_distance = (\n                    -1\n                    if met_id not in references or len(references[met_id]) == 0\n                    else references[met_id][0].tax_distance\n                )\n                if not (\n                    (change_known_values and ki_tax_distance &gt;= 0)\n                    or (change_unknown_values and ki_tax_distance &lt; 0)\n                ):\n                    continue\n                for met_id in reaction.enzyme_reaction_data.k_is:\n                    if use_shuffling_instead_of_uniform_random:\n                        reaction.enzyme_reaction_data.k_is[met_id] = choice(all_kis)\n                    else:\n                        reaction.enzyme_reaction_data.k_is[met_id] *= (\n                            max_ki_variation\n                            ** (\n                                uniform(-1, 1)  # noqa: NPY002\n                            )\n                        )  # noqa: NPY002\n            if max_ka_variation is not None:\n                references = reaction.enzyme_reaction_data.k_a_references\n                ka_tax_distance = (\n                    -1\n                    if met_id not in references or len(references[met_id]) == 0\n                    else references[met_id][0].tax_distance\n                )\n                if not (\n                    (change_known_values and ka_tax_distance &gt;= 0)\n                    or (change_unknown_values and ka_tax_distance &lt; 0)\n                ):\n                    continue\n                for met_id in reaction.enzyme_reaction_data.k_as:\n                    if use_shuffling_instead_of_uniform_random:\n                        reaction.enzyme_reaction_data.k_as[met_id] = choice(all_kas)\n                    else:\n                        reaction.enzyme_reaction_data.k_as[met_id] *= (\n                            max_ka_variation\n                            ** (\n                                uniform(-1, 1)  # noqa: NPY002\n                            )\n                        )  # noqa: NPY002\n    return varied_model\n</code></pre>"},{"location":"api.html#cobrak.utilities.get_potentially_active_reactions_in_variability_dict","title":"<code>get_potentially_active_reactions_in_variability_dict(cobrak_model, variability_dict)</code>","text":"<p>Identify potentially active reactions in a COBRAk model based on a variability dictionary.</p> <p>This function returns a list of reaction IDs that are present in both the COBRAk model and the variability dictionary, and have a maximum flux greater than zero while having a minimum flux equal to zero. These reactions are considered potentially active.</p> <p>Parameters:</p> Name Type Description Default <code>cobrak_model</code> <code>Model</code> <p>The COBRAk model containing reactions.</p> required <code>variability_dict</code> <code>dict[str, tuple[float, float]]</code> <p>A dictionary mapping reaction IDs to their minimum and maximum flux values.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: A list of reaction IDs that are potentially active.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef get_potentially_active_reactions_in_variability_dict(\n    cobrak_model: Model, variability_dict: dict[str, tuple[float, float]]\n) -&gt; list[str]:\n    \"\"\"Identify potentially active reactions in a COBRAk model based on a variability dictionary.\n\n    This function returns a list of reaction IDs that are present in both the COBRAk model and the variability dictionary,\n    and have a maximum flux greater than zero while having a minimum flux equal to zero. These reactions are considered potentially active.\n\n    Args:\n        cobrak_model (Model): The COBRAk model containing reactions.\n        variability_dict (dict[str, tuple[float, float]]): A dictionary mapping reaction IDs to their minimum and maximum flux values.\n\n    Returns:\n        list[str]: A list of reaction IDs that are potentially active.\n    \"\"\"\n    return [\n        reac_id\n        for reac_id in variability_dict\n        if (reac_id in cobrak_model.reactions)\n        and (variability_dict[reac_id][1] &gt; 0.0)\n        and (variability_dict[reac_id][0] &lt;= 0.0)\n    ]\n</code></pre>"},{"location":"api.html#cobrak.utilities.get_pyomo_solution_as_dict","title":"<code>get_pyomo_solution_as_dict(model)</code>","text":"<p>Returns the pyomo solution as a dictionary of { \"\\(VAR_NAME\": \"\\)VAR_VALUE\", ... }</p> <p>Value is None for all uninitialized variables.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>ConcreteModel</code> <p>The pyomo model</p> required <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>dict[str, float]: The solution dictionary</p> Source code in <code>cobrak/utilities.py</code> <pre><code>def get_pyomo_solution_as_dict(model: ConcreteModel) -&gt; dict[str, float]:\n    \"\"\"Returns the pyomo solution as a dictionary of { \"$VAR_NAME\": \"$VAR_VALUE\", ... }\n\n    Value is None for all uninitialized variables.\n\n    Args:\n        model (ConcreteModel): The pyomo model\n\n    Returns:\n        dict[str, float]: The solution dictionary\n    \"\"\"\n    model_var_names = [v.name for v in model.component_objects(Var)]\n    solution_dict = {}\n    for model_var_name in model_var_names:\n        try:\n            var_value = getattr(model, model_var_name).value\n        except ValueError:\n            var_value = None  # Uninitialized variable (e.g., x_Biomass)\n        solution_dict[model_var_name] = var_value\n    return solution_dict\n</code></pre>"},{"location":"api.html#cobrak.utilities.get_reaction_enzyme_var_id","title":"<code>get_reaction_enzyme_var_id(reac_id, reaction)</code>","text":"<p>Returns the pyomo model name of the reaction's enzyme</p> <p>Parameters:</p> Name Type Description Default <code>reac_id</code> <code>str</code> <p>Reaction ID</p> required <code>reaction</code> <code>Reaction</code> <p>Reaction instance</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Reaction enzyme's name</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef get_reaction_enzyme_var_id(reac_id: str, reaction: Reaction) -&gt; str:\n    \"\"\"Returns the pyomo model name of the reaction's enzyme\n\n    Args:\n        reac_id (str): Reaction ID\n        reaction (Reaction): Reaction instance\n\n    Returns:\n        str: Reaction enzyme's name\n    \"\"\"\n    if reaction.enzyme_reaction_data is None:\n        return \"\"\n    return (\n        ENZYME_VAR_PREFIX\n        + get_full_enzyme_id(reaction.enzyme_reaction_data.identifiers)\n        + ENZYME_VAR_INFIX\n        + reac_id\n    )\n</code></pre>"},{"location":"api.html#cobrak.utilities.get_reaction_string","title":"<code>get_reaction_string(cobrak_model, reac_id)</code>","text":"<p>Generate a string representation of a reaction in a COBRAk model.</p> <p>This function constructs a string that represents the stoichiometry of a specified reaction, including the direction of the reaction based on its flux bounds. E.g., a reaction R1: A \u21d2 B, [0, 1000] is returned as \"1 A \u21d2 1 B\"</p> <p>Parameters:</p> Name Type Description Default <code>cobrak_model</code> <code>Model</code> <p>The COBRAk model containing the reaction.</p> required <code>reac_id</code> <code>str</code> <p>The ID of the reaction to be represented as a string.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string representation of the reaction, showing educts, products, and the reaction direction.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef get_reaction_string(cobrak_model: Model, reac_id: str) -&gt; str:\n    \"\"\"Generate a string representation of a reaction in a COBRAk model.\n\n    This function constructs a string that represents the stoichiometry of a specified reaction,\n    including the direction of the reaction based on its flux bounds. E.g., a reaction\n    R1: A \u21d2 B, [0, 1000]\n    is returned\n    as \"1 A \u21d2 1 B\"\n\n    Args:\n        cobrak_model (Model): The COBRAk model containing the reaction.\n        reac_id (str): The ID of the reaction to be represented as a string.\n\n    Returns:\n        str: A string representation of the reaction, showing educts, products, and the reaction direction.\n    \"\"\"\n    reaction = cobrak_model.reactions[reac_id]\n    educt_parts = []\n    product_parts = []\n    for met_id, stoichiometry in reaction.stoichiometries.items():\n        met_string = f\"{stoichiometry} {met_id}\"\n        if stoichiometry &gt; 0:\n            product_parts.append(met_string)\n        else:\n            educt_parts.append(met_string)\n    if (reaction.min_flux &lt; 0) and (reaction.max_flux &gt; 0):\n        arrow = \"\u21d4\"\n    elif (reaction.min_flux &lt; 0) and (reaction.max_flux &lt;= 0):\n        arrow = \"\u21d0\"\n    else:\n        arrow = \"\u21d2\"\n\n    return \" + \".join(educt_parts) + \" \" + arrow + \" \" + \" + \".join(product_parts)\n</code></pre>"},{"location":"api.html#cobrak.utilities.get_reverse_reac_id_if_existing","title":"<code>get_reverse_reac_id_if_existing(reac_id, fwd_suffix=REAC_FWD_SUFFIX, rev_suffix=REAC_REV_SUFFIX)</code>","text":"<p>Returns the ID of the reverse reaction if it exists, otherwise returns an empty string.</p> <p>Args: reac_id (str): The ID of the reaction. fwd_suffix (str, optional): The suffix used to identify forward reactions. Defaults to REAC_FWD_SUFFIX. rev_suffix (str, optional): The suffix used to identify reverse reactions. Defaults to REAC_REV_SUFFIX.</p> <p>Returns: str: The ID of the reverse reaction if it exists, otherwise an empty string.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef get_reverse_reac_id_if_existing(\n    reac_id: str,\n    fwd_suffix: str = REAC_FWD_SUFFIX,\n    rev_suffix: str = REAC_REV_SUFFIX,\n) -&gt; str:\n    \"\"\"Returns the ID of the reverse reaction if it exists, otherwise returns an empty string.\n\n    Args:\n    reac_id (str): The ID of the reaction.\n    fwd_suffix (str, optional): The suffix used to identify forward reactions. Defaults to REAC_FWD_SUFFIX.\n    rev_suffix (str, optional): The suffix used to identify reverse reactions. Defaults to REAC_REV_SUFFIX.\n\n    Returns:\n    str: The ID of the reverse reaction if it exists, otherwise an empty string.\n    \"\"\"\n    if reac_id.endswith(fwd_suffix):\n        return reac_id.replace(fwd_suffix, rev_suffix)\n    if reac_id.endswith(rev_suffix):\n        return reac_id.replace(rev_suffix, fwd_suffix)\n    return \"\"\n</code></pre>"},{"location":"api.html#cobrak.utilities.get_solver_status_from_pyomo_results","title":"<code>get_solver_status_from_pyomo_results(pyomo_results)</code>","text":"<p>Returns the solver status from the pyomo results as an integer code.</p> <p>This function interprets the solver status from a <code>SolverResults</code> object and returns a corresponding integer code. The mapping is as follows: - 0 for <code>SolverStatus.ok</code> - 1 for <code>SolverStatus.warning</code> - 2 for <code>SolverStatus.error</code> - 3 for <code>SolverStatus.aborted</code> - 4 for <code>SolverStatus.unknown</code></p> <p>Parameters:</p> Name Type Description Default <code>pyomo_results</code> <code>SolverResults</code> <p>The results object from a Pyomo solver containing the solver status.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the solver status is not recognized.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>NonNegativeInt</code> <p>An integer code representing the solver status.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(config=ConfigDict(arbitrary_types_allowed=True), validate_return=True)\ndef get_solver_status_from_pyomo_results(\n    pyomo_results: SolverResults,\n) -&gt; NonNegativeInt:\n    \"\"\"Returns the solver status from the pyomo results as an integer code.\n\n    This function interprets the solver status from a `SolverResults` object and returns a corresponding integer code.\n    The mapping is as follows:\n    - 0 for `SolverStatus.ok`\n    - 1 for `SolverStatus.warning`\n    - 2 for `SolverStatus.error`\n    - 3 for `SolverStatus.aborted`\n    - 4 for `SolverStatus.unknown`\n\n    Args:\n        pyomo_results (SolverResults): The results object from a Pyomo solver containing the solver status.\n\n    Raises:\n        ValueError: If the solver status is not recognized.\n\n    Returns:\n        int: An integer code representing the solver status.\n    \"\"\"\n    match pyomo_results.solver.status:\n        case SolverStatus.ok:\n            return 0\n        case SolverStatus.warning:\n            return 1\n        case SolverStatus.error:\n            return 2\n        case SolverStatus.aborted:\n            return 3\n        case SolverStatus.unknown:\n            return 4\n        case _:\n            raise ValueError\n</code></pre>"},{"location":"api.html#cobrak.utilities.get_stoichiometric_matrix","title":"<code>get_stoichiometric_matrix(cobrak_model)</code>","text":"<p>Returns the model's stoichiometric matrix.</p> <p>The matrix is returned as a list of float lists, where each float list stands for a reaction and each entry in the float list for a metabolite.</p> <p>Parameters:</p> Name Type Description Default <code>cobrak_model</code> <code>Model</code> <p>The model</p> required <p>Returns:</p> Type Description <code>list[list[float]]</code> <p>list[list[float]]: The stoichiometric matrix</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef get_stoichiometric_matrix(cobrak_model: Model) -&gt; list[list[float]]:\n    \"\"\"Returns the model's stoichiometric matrix.\n\n    The matrix is returned as a list of float lists, where each float list\n    stands for a reaction and each entry in the float list for a metabolite.\n\n    Args:\n        cobrak_model (Model): The model\n\n    Returns:\n        list[list[float]]: The stoichiometric matrix\n    \"\"\"\n    matrix: list[list[float]] = []\n    for met_id in cobrak_model.metabolites:\n        met_row: list[float] = []\n        for reac_data in cobrak_model.reactions.values():\n            if met_id in reac_data.stoichiometries:\n                met_row.append(reac_data.stoichiometries[met_id])\n            else:\n                met_row.append(0.0)\n        matrix.append(met_row.copy())\n    return matrix\n</code></pre>"},{"location":"api.html#cobrak.utilities.get_stoichiometrically_coupled_reactions","title":"<code>get_stoichiometrically_coupled_reactions(cobrak_model, rounding=10)</code>","text":"<p>Returns stoichiometrically coupled reactions.</p> <p>The returned format is as follows: Say that reactions (R1 &amp; R2) as well as (R5 &amp; R6 &amp; R7) are stoichiometrically coupled (i.e, their fluxes are in a strict linear relationship to each other), then this function returns [[\"R1\", \"R2\"], [\"R5\", \"R6\", \"R7\"].</p> <p>The identification of stoichiometrically coupled reactions happens through the calculation of the model's stoichiometric matrix nullspace.</p> <p>Parameters:</p> Name Type Description Default <code>cobrak_model</code> <code>Model</code> <p>The model</p> required <code>rounding</code> <code>int</code> <p>Precision for the calculation of the nullspace. Defaults to 10.</p> <code>10</code> <p>Returns:</p> Type Description <code>list[list[str]]</code> <p>list[list[str]]: The stoichiometrically coupled reactions</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef get_stoichiometrically_coupled_reactions(\n    cobrak_model: Model, rounding: NonNegativeInt = 10\n) -&gt; list[list[str]]:\n    \"\"\"Returns stoichiometrically coupled reactions.\n\n    The returned format is as follows: Say that reactions (R1 &amp; R2) as well\n    as (R5 &amp; R6 &amp; R7) are stoichiometrically coupled (i.e, their fluxes are\n    in a strict linear relationship to each other), then this function\n    returns [[\"R1\", \"R2\"], [\"R5\", \"R6\", \"R7\"].\n\n    The identification of stoichiometrically coupled reactions happens through\n    the calculation of the model's stoichiometric matrix nullspace.\n\n    Args:\n        cobrak_model (Model): The model\n        rounding (int, optional): Precision for the calculation of the nullspace. Defaults to 10.\n\n    Returns:\n        list[list[str]]: The stoichiometrically coupled reactions\n    \"\"\"\n    # Calculate nullspace and convert each row to rounded tuples\n    null_space_matrix = null_space(get_stoichiometric_matrix(cobrak_model))\n    null_space_tuples = [\n        tuple(round(value, rounding) for value in row) for row in null_space_matrix\n    ]\n\n    # Map the null space tuples to reaction indices\n    occcurences: dict[tuple[float, ...], list[int]] = {}\n    for reac_idx, null_space_tuple in enumerate(null_space_tuples):\n        if null_space_tuple not in occcurences:\n            occcurences[null_space_tuple] = []\n        occcurences[null_space_tuple].append(reac_idx)\n\n    # Map the reaction indices to the final couples reactions list\n    coupled_reacs: list[list[str]] = []\n    reac_ids = list(cobrak_model.reactions.keys())\n    for coupled_indices in occcurences.values():\n        coupled_reacs.append([reac_ids[reac_idx] for reac_idx in coupled_indices])\n\n    return coupled_reacs\n</code></pre>"},{"location":"api.html#cobrak.utilities.get_substrate_and_product_exchanges","title":"<code>get_substrate_and_product_exchanges(cobrak_model, optimization_dict={})</code>","text":"<p>Identifies and categorizes reactions as substrate or product exchanges based on reaction stoichiometries.</p> <p>This function analyzes each reaction in the provided COBRAk model to determine whether it primarily represents substrate consumption or product formation. It categorizes reactions into substrate reactions (where all stoichiometries are positive, indicating metabolite consumption) and product reactions (where all stoichiometries are negative, indicating metabolite production).</p> <ul> <li>A reaction is classified as a substrate reaction if all its stoichiometries are positive, indicating that all metabolites involved are being consumed.</li> <li>A reaction is classified as a product reaction if all its stoichiometries are negative, indicating that all metabolites involved are being produced.</li> <li>If the <code>optimization_dict</code> is provided, only the reactions listed in this dictionary are considered for classification.</li> <li>The function returns tuples of reaction IDs, which can be used for further processing or analysis of substrate and product reactions.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>cobrak_model</code> <code>Model</code> <p>The COBRAk model containing reactions to be analyzed.</p> required <code>optimization_dict</code> <code>dict[str, Any]</code> <p>An optional dictionary to filter reactions. Only reactions whose IDs are present in this dictionary will be considered.</p> <code>{}</code> <p>Returns:</p> Type Description <code>tuple[tuple[str, ...], tuple[str, ...]]</code> <p>tuple[tuple[str, ...], tuple[str, ...]]: A tuple containing two elements: - The first element is a tuple of reaction IDs identified as substrate reactions. - The second element is a tuple of reaction IDs identified as product reactions.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef get_substrate_and_product_exchanges(\n    cobrak_model: Model, optimization_dict: dict[str, Any] = {}\n) -&gt; tuple[tuple[str, ...], tuple[str, ...]]:\n    \"\"\"Identifies and categorizes reactions as substrate or product exchanges based on reaction stoichiometries.\n\n    This function analyzes each reaction in the provided COBRAk model to determine whether it primarily represents substrate consumption or product formation.\n    It categorizes reactions into substrate reactions (where all stoichiometries are positive, indicating metabolite consumption) and product reactions\n    (where all stoichiometries are negative, indicating metabolite production).\n\n    * A reaction is classified as a substrate reaction if all its stoichiometries are positive, indicating that all metabolites involved are being consumed.\n    * A reaction is classified as a product reaction if all its stoichiometries are negative, indicating that all metabolites involved are being produced.\n    * If the `optimization_dict` is provided, only the reactions listed in this dictionary are considered for classification.\n    * The function returns tuples of reaction IDs, which can be used for further processing or analysis of substrate and product reactions.\n\n    Args:\n        cobrak_model (Model): The COBRAk model containing reactions to be analyzed.\n        optimization_dict (dict[str, Any], optional): An optional dictionary to filter reactions. Only reactions whose IDs are present in this dictionary will be considered.\n        Defaults to {}.\n\n    Returns:\n        tuple[tuple[str, ...], tuple[str, ...]]: A tuple containing two elements:\n            - The first element is a tuple of reaction IDs identified as substrate reactions.\n            - The second element is a tuple of reaction IDs identified as product reactions.\n    \"\"\"\n    substrate_reac_ids: list[str] = []\n    product_reac_ids: list[str] = []\n    for reac_id, reaction in cobrak_model.reactions.items():\n        if optimization_dict != {} and reac_id not in optimization_dict:\n            continue\n        stoichiometries = list(reaction.stoichiometries.values())\n        if min(stoichiometries) &gt; 0 and max(stoichiometries) &gt; 0:\n            substrate_reac_ids.append(reac_id)\n        elif min(stoichiometries) &lt; 0 and max(stoichiometries) &lt; 0:\n            product_reac_ids.append(reac_id)\n    return tuple(substrate_reac_ids), tuple(product_reac_ids)\n</code></pre>"},{"location":"api.html#cobrak.utilities.get_termination_condition_from_pyomo_results","title":"<code>get_termination_condition_from_pyomo_results(pyomo_results)</code>","text":"<p>Returns the termination condition from the pyomo results as a float code.</p> <p>This function interprets the termination condition from a <code>SolverResults</code> object and returns a corresponding float code. The mapping is as follows: - 0.1 for <code>TerminationCondition.globallyOptimal</code> - 0.2 for <code>TerminationCondition.optimal</code> - 0.3 for <code>TerminationCondition.locallyOptimal</code> - 1 for <code>TerminationCondition.maxTimeLimit</code> - 2 for <code>TerminationCondition.maxIterations</code> - 3 for <code>TerminationCondition.minFunctionValue</code> - 4 for <code>TerminationCondition.minStepLength</code> - 5 for <code>TerminationCondition.maxEvaluations</code> - 6 for <code>TerminationCondition.other</code> - 7 for <code>TerminationCondition.unbounded</code> - 8 for <code>TerminationCondition.infeasible</code> - 9 for <code>TerminationCondition.invalidProblem</code> - 10 for <code>TerminationCondition.solverFailure</code> - 11 for <code>TerminationCondition.internalSolverError</code> - 12 for <code>TerminationCondition.error</code> - 13 for <code>TerminationCondition.userInterrupt</code> - 14 for <code>TerminationCondition.resourceInterrupt</code> - 15 for <code>TerminationCondition.licensingProblem</code></p> <p>Parameters:</p> Name Type Description Default <code>pyomo_results</code> <code>SolverResults</code> <p>The results object from a Pyomo solver containing the termination condition.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the termination condition is not recognized.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>NonNegativeFloat</code> <p>A float code representing the termination condition.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(config=ConfigDict(arbitrary_types_allowed=True), validate_return=True)\ndef get_termination_condition_from_pyomo_results(\n    pyomo_results: SolverResults,\n) -&gt; NonNegativeFloat:\n    \"\"\"Returns the termination condition from the pyomo results as a float code.\n\n    This function interprets the termination condition from a `SolverResults` object and returns a corresponding float code.\n    The mapping is as follows:\n    - 0.1 for `TerminationCondition.globallyOptimal`\n    - 0.2 for `TerminationCondition.optimal`\n    - 0.3 for `TerminationCondition.locallyOptimal`\n    - 1 for `TerminationCondition.maxTimeLimit`\n    - 2 for `TerminationCondition.maxIterations`\n    - 3 for `TerminationCondition.minFunctionValue`\n    - 4 for `TerminationCondition.minStepLength`\n    - 5 for `TerminationCondition.maxEvaluations`\n    - 6 for `TerminationCondition.other`\n    - 7 for `TerminationCondition.unbounded`\n    - 8 for `TerminationCondition.infeasible`\n    - 9 for `TerminationCondition.invalidProblem`\n    - 10 for `TerminationCondition.solverFailure`\n    - 11 for `TerminationCondition.internalSolverError`\n    - 12 for `TerminationCondition.error`\n    - 13 for `TerminationCondition.userInterrupt`\n    - 14 for `TerminationCondition.resourceInterrupt`\n    - 15 for `TerminationCondition.licensingProblem`\n\n    Args:\n        pyomo_results (SolverResults): The results object from a Pyomo solver containing the termination condition.\n\n    Raises:\n        ValueError: If the termination condition is not recognized.\n\n    Returns:\n        float: A float code representing the termination condition.\n    \"\"\"\n    match pyomo_results.solver.termination_condition:\n        case TerminationCondition.globallyOptimal:\n            return 0.1\n        case TerminationCondition.optimal:\n            return 0.2\n        case TerminationCondition.locallyOptimal:\n            return 0.3\n        case TerminationCondition.maxTimeLimit:\n            return 1\n        case TerminationCondition.maxIterations:\n            return 2\n        case TerminationCondition.minFunctionValue:\n            return 3\n        case TerminationCondition.minStepLength:\n            return 4\n        case TerminationCondition.maxEvaluations:\n            return 5\n        case TerminationCondition.other:\n            return 6\n        case TerminationCondition.unbounded:\n            return 7\n        case TerminationCondition.infeasible:\n            return 8\n        case TerminationCondition.invalidProblem:\n            return 9\n        case TerminationCondition.solverFailure:\n            return 10\n        case TerminationCondition.internalSolverError:\n            return 11\n        case TerminationCondition.error:\n            return 12\n        case TerminationCondition.userInterrupt:\n            return 13\n        case TerminationCondition.resourceInterrupt:\n            return 14\n        case TerminationCondition.licensingProblems:\n            return 15\n        case TerminationCondition.intermediateNonInteger:\n            return 16\n        case _:\n            raise ValueError\n</code></pre>"},{"location":"api.html#cobrak.utilities.get_unoptimized_reactions_in_nlp_solution","title":"<code>get_unoptimized_reactions_in_nlp_solution(cobrak_model, solution, verbose=False, regard_iota=False, regard_alpha=False)</code>","text":"<p>Identify unoptimized reactions in the NLP (Non-Linear Programming) solution.</p> <p>This function checks each reaction in the COBRAk model to determine if the flux values in the provided NLP solution match the expected values based on enzyme kinetics and thermodynamics. Reactions with discrepancies are considered unoptimized and are returned in a dictionary.</p> <p>Discrepancies occur because, in COBRAk, the saturation term and the thermodynamic restriction are set as maximal values (&lt;=), they are not fixed.</p> <p>Parameters:</p> Name Type Description Default <code>cobrak_model</code> <code>Model</code> <p>The COBRAk model containing reactions and enzyme data.</p> required <code>solution</code> <code>dict[str, float]</code> <p>A dictionary mapping variable names to their values from an NLP solution.</p> required <code>verbose</code> <code>bool</code> <p>bool: Whether or not to print the discrepancies for each reaction</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, tuple[float, float]]</code> <p>dict[str, tuple[float, float]]: Dictionary where the keys are reaction IDs and the values are                             tuples containing the NLP solution flux and the real flux for unoptimized reactions.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef get_unoptimized_reactions_in_nlp_solution(\n    cobrak_model: Model,\n    solution: dict[str, float],\n    verbose: bool = False,\n    regard_iota: bool = False,\n    regard_alpha: bool = False,\n) -&gt; dict[str, tuple[float, float]]:\n    \"\"\"Identify unoptimized reactions in the NLP (Non-Linear Programming) solution.\n\n    This function checks each reaction in the COBRAk model to determine if the flux values in the provided NLP solution match\n    the expected values based on enzyme kinetics and thermodynamics.\n    Reactions with discrepancies are considered unoptimized and are returned in a dictionary.\n\n    Discrepancies occur because, in COBRAk, the saturation term and the thermodynamic restriction are set as maximal values (&lt;=),\n    they are not fixed.\n\n    Args:\n        cobrak_model (Model): The COBRAk model containing reactions and enzyme data.\n        solution (dict[str, float]): A dictionary mapping variable names to their values from an NLP solution.\n        verbose: bool: Whether or not to print the discrepancies for each reaction\n\n    Returns:\n        dict[str, tuple[float, float]]: Dictionary where the keys are reaction IDs and the values are\n                                        tuples containing the NLP solution flux and the real flux for unoptimized reactions.\n    \"\"\"\n    unoptimized_reactions: dict[str, tuple[float, float]] = {}\n    RT = cobrak_model.R * cobrak_model.T\n\n    for reac_id, reaction in cobrak_model.reactions.items():\n        if reac_id not in solution:\n            continue\n        if reaction.enzyme_reaction_data is None:\n            continue\n        if reaction.enzyme_reaction_data.identifiers == [\"\"]:\n            continue\n\n        nlp_flux = solution[reac_id]\n        has_problem = False\n\n        # Kappa check\n        if have_all_unignored_km(reaction, cobrak_model.kinetic_ignored_metabolites):\n            kappa_substrates = 1.0\n            kappa_products = 1.0\n            for met_id, raw_stoichiometry in reaction.stoichiometries.items():\n                if met_id in cobrak_model.kinetic_ignored_metabolites:\n                    continue\n\n                stoichiometry = (\n                    raw_stoichiometry\n                    * reaction.enzyme_reaction_data.hill_coefficients.kappa.get(\n                        met_id, 1.0\n                    )\n                )\n                expconc = exp(solution[f\"{LNCONC_VAR_PREFIX}{met_id}\"])\n                multiplier = (\n                    expconc / reaction.enzyme_reaction_data.k_ms[met_id]\n                ) ** abs(stoichiometry)\n                if stoichiometry &lt; 0.0:\n                    kappa_substrates *= multiplier\n                else:\n                    kappa_products *= multiplier\n\n            real_kappa = kappa_substrates / (1 + kappa_substrates + kappa_products)\n            nlp_kappa = solution[f\"{KAPPA_VAR_PREFIX}{reac_id}\"]\n\n            if abs(nlp_kappa - real_kappa) &gt; 0.001:\n                has_problem = True\n                if verbose:\n                    print(\n                        f\"\u03ba problem in {reac_id}: Real is {real_kappa}, NLP value is {nlp_kappa}\"\n                    )\n        else:\n            real_kappa = 1.0\n            nlp_kappa = 1.0\n\n        # Iota and alpha check\n        real_iota = 1.0\n        real_alpha = 1.0\n        if (\n            reac_id in solution\n            and reaction.enzyme_reaction_data is not None\n            and reaction.enzyme_reaction_data.identifiers != [\"\"]\n        ):\n            alpha_and_iota_mets = set(\n                list(reaction.enzyme_reaction_data.k_is.keys())\n                + list(reaction.enzyme_reaction_data.k_as.keys())\n            )\n            for met_id in alpha_and_iota_mets:\n                met_var_id = f\"{LNCONC_VAR_PREFIX}{met_id}\"\n                if met_var_id not in solution:\n                    continue\n                expconc = exp(solution[met_var_id])\n                stoichiometry_iota = abs(\n                    reaction.stoichiometries.get(met_id, 1.0)\n                ) * reaction.enzyme_reaction_data.hill_coefficients.iota.get(\n                    met_id, 1.0\n                )\n                stoichiometry_alpha = abs(\n                    reaction.stoichiometries.get(met_id, 1.0)\n                ) * reaction.enzyme_reaction_data.hill_coefficients.alpha.get(\n                    met_id, 1.0\n                )\n\n                if met_id in reaction.enzyme_reaction_data.k_is and regard_iota:\n                    real_iota *= 1 / (\n                        1\n                        + (expconc / reaction.enzyme_reaction_data.k_is[met_id])\n                        ** stoichiometry_iota\n                    )\n                if met_id in reaction.enzyme_reaction_data.k_as and regard_alpha:\n                    real_alpha *= 1 / (\n                        1\n                        + (reaction.enzyme_reaction_data.k_as[met_id] / expconc)\n                        ** stoichiometry_alpha\n                    )\n\n        nlp_iota = (\n            solution.get(f\"{IOTA_VAR_PREFIX}{reac_id}\", 1.0) if regard_iota else 1.0\n        )\n        if abs(nlp_iota - real_iota) &gt; 0.001:\n            has_problem = True\n            if verbose:\n                print(\n                    f\"\u03b9 problem in {reac_id}: Real is {real_iota}, NLP value is {nlp_iota}\"\n                )\n        nlp_alpha = (\n            solution.get(f\"{ALPHA_VAR_PREFIX}{reac_id}\", 1.0) if regard_alpha else 1.0\n        )\n        if abs(nlp_alpha - real_alpha) &gt; 0.001:\n            has_problem = True\n            if verbose:\n                print(\n                    f\"\u03b1 problem in {reac_id}: Real is {real_alpha}, NLP value is {nlp_alpha}\"\n                )\n\n        # Gamma check\n        if reaction.dG0 is not None:\n            gamma_substrates = 1.0\n            gamma_products = 1.0\n\n            for met_id, stoichiometry in reaction.stoichiometries.items():\n                multiplier = exp(solution[f\"{LNCONC_VAR_PREFIX}{met_id}\"]) ** abs(\n                    stoichiometry\n                )\n                if stoichiometry &lt; 0.0:\n                    gamma_substrates *= multiplier\n                else:\n                    gamma_products *= multiplier\n\n            dg = -(reaction.dG0 + RT * log(gamma_products) - RT * log(gamma_substrates))\n            real_gamma = 1 - exp(-dg / RT)\n            nlp_gamma = solution[f\"{GAMMA_VAR_PREFIX}{reac_id}\"]\n\n            if abs(nlp_gamma - real_gamma) &gt; 0.001:\n                has_problem = True\n                if verbose:\n                    print(\n                        f\"\u03b3 problem in {reac_id}: Real is {real_gamma}, NLP value is {nlp_gamma}\"\n                    )\n                    print(\n                        f\"\u0394G': Real is {dg}, NLP value is {solution[DF_VAR_PREFIX + reac_id]}\"\n                    )\n                    print(\"E\", solution[get_reaction_enzyme_var_id(reac_id, reaction)])\n                    print(\n                        \"E_use\",\n                        solution[get_reaction_enzyme_var_id(reac_id, reaction)]\n                        * get_full_enzyme_mw(cobrak_model, reaction),\n                    )\n        else:\n            real_gamma = 1.0\n            nlp_gamma = 1.0\n\n        # V plus\n        enzyme_conc = solution[get_reaction_enzyme_var_id(reac_id, reaction)]\n        v_plus = enzyme_conc * reaction.enzyme_reaction_data.k_cat\n\n        nlp_flux = v_plus * nlp_gamma * nlp_kappa * nlp_alpha * nlp_iota\n        real_flux = v_plus * real_gamma * real_kappa * real_alpha * real_iota\n        if has_problem and verbose:\n            print(nlp_flux, real_flux, solution[reac_id])\n\n        if real_flux != solution[reac_id]:\n            unoptimized_reactions[reac_id] = (solution[reac_id], real_flux)\n\n    return unoptimized_reactions\n</code></pre>"},{"location":"api.html#cobrak.utilities.have_all_unignored_km","title":"<code>have_all_unignored_km(reaction, kinetic_ignored_metabolites)</code>","text":"<p>Check if all non-ignored metabolites in a reaction have associated Michaelis-Menten constants (k_m).</p> <p>This function checks whether all substrates and products of a reaction, excluding those specified in the kinetically ignored metabolites list, have associated Km values. It also ensures that there is at least one substrate and one product with a k_m value.</p> <p>Parameters:</p> Name Type Description Default <code>reaction</code> <code>Reaction</code> <p>The reaction to be checked.</p> required <code>kinetic_ignored_metabolites</code> <code>list[str]</code> <p>A list of metabolite IDs to be ignored in the k_m check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all non-ignored metabolites have Km values and there is at least one substrate and one product with Km values, False otherwise.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef have_all_unignored_km(\n    reaction: Reaction, kinetic_ignored_metabolites: list[str]\n) -&gt; bool:\n    \"\"\"Check if all non-ignored metabolites in a reaction have associated Michaelis-Menten constants (k_m).\n\n    This function checks whether all substrates and products of a reaction, excluding those specified in the kinetically ignored metabolites list,\n    have associated Km values. It also ensures that there is at least one substrate and one product with a k_m value.\n\n    Args:\n        reaction (Reaction): The reaction to be checked.\n        kinetic_ignored_metabolites (list[str]): A list of metabolite IDs to be ignored in the k_m check.\n\n    Returns:\n        bool: True if all non-ignored metabolites have Km values and there is at least one substrate and one product with Km values, False otherwise.\n    \"\"\"\n    if reaction.enzyme_reaction_data is None:\n        return False\n\n    eligible_mets = [\n        met_id\n        for met_id, stoichiometry in reaction.stoichiometries.items()\n        if met_id not in kinetic_ignored_metabolites\n    ]\n    for eligible_met in eligible_mets:\n        if eligible_met not in reaction.enzyme_reaction_data.k_ms:\n            return False\n\n    substrates_with_km = [\n        met_id\n        for met_id in eligible_mets\n        if (met_id in reaction.enzyme_reaction_data.k_ms)\n        and (reaction.stoichiometries[met_id] &lt; 0)\n    ]\n    products_with_km = [\n        met_id\n        for met_id in eligible_mets\n        if (met_id in reaction.enzyme_reaction_data.k_ms)\n        and (reaction.stoichiometries[met_id] &gt; 0)\n    ]\n    return not (len(substrates_with_km) == 0 or len(products_with_km) == 0)\n</code></pre>"},{"location":"api.html#cobrak.utilities.is_any_error_term_active","title":"<code>is_any_error_term_active(correction_config)</code>","text":"<p>Checks if any error term is active in the correction configuration.</p> <p>This function determines whether any of the error terms specified in the <code>CorrectionConfig</code> object are enabled.  It sums the boolean values of the flags indicating whether each error term is active.  If the sum is greater than zero, it means at least one error term is active.</p> <p>Parameters:</p> Name Type Description Default <code>correction_config</code> <code>CorrectionConfig</code> <p>The CorrectionConfig object to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if at least one error term is active, False otherwise.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef is_any_error_term_active(correction_config: CorrectionConfig) -&gt; bool:\n    \"\"\"Checks if any error term is active in the correction configuration.\n\n    This function determines whether any of the error terms specified in the\n    `CorrectionConfig` object are enabled.  It sums the boolean values of the\n    flags indicating whether each error term is active.  If the sum is greater\n    than zero, it means at least one error term is active.\n\n    Args:\n        correction_config: The CorrectionConfig object to check.\n\n    Returns:\n        True if at least one error term is active, False otherwise.\n    \"\"\"\n    return bool(\n        sum(\n            [\n                correction_config.add_flux_error_term,\n                correction_config.add_met_logconc_error_term,\n                correction_config.add_enzyme_conc_error_term,\n                correction_config.add_kcat_times_e_error_term,\n                correction_config.add_dG0_error_term,\n                correction_config.add_km_error_term,\n            ]\n        )\n    )\n</code></pre>"},{"location":"api.html#cobrak.utilities.is_objsense_maximization","title":"<code>is_objsense_maximization(objsense)</code>","text":"<p>Checks if the objective sense is maximization.</p> <p>Args: objsense (int): The objective sense, where in this function's definition: - &gt;0: Maximization - \u22640: Minimization</p> <p>Returns: bool: True if the objective sense is maximization, False otherwise.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef is_objsense_maximization(objsense: int) -&gt; bool:\n    \"\"\"Checks if the objective sense is maximization.\n\n    Args:\n    objsense (int): The objective sense, where in this function's definition:\n    - &gt;0: Maximization\n    - \u22640: Minimization\n\n    Returns:\n    bool: True if the objective sense is maximization, False otherwise.\"\"\"\n    return objsense &gt; 0\n</code></pre>"},{"location":"api.html#cobrak.utilities.last_n_elements_equal","title":"<code>last_n_elements_equal(lst, n)</code>","text":"<p>Check if the last n elements of a list are equal.</p> <p>Parameters:</p> Name Type Description Default <code>lst</code> <code>list[Any]</code> <p>The list to check.</p> required <code>n</code> <code>int</code> <p>The number of elements from the end of the list to compare.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the last n elements are equal, False otherwise.</p> Example <p>last_n_elements_equal([1, 2, 3, 4, 4, 4], 3) True last_n_elements_equal([1, 2, 3, 4, 5, 6], 3) False</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(config=ConfigDict(arbitrary_types_allowed=True), validate_return=True)\ndef last_n_elements_equal(lst: list[Any], n: int | float) -&gt; bool:\n    \"\"\"Check if the last n elements of a list are equal.\n\n    Args:\n        lst (list[Any]): The list to check.\n        n (int): The number of elements from the end of the list to compare.\n\n    Returns:\n        bool: True if the last n elements are equal, False otherwise.\n\n    Example:\n        &gt;&gt;&gt; last_n_elements_equal([1, 2, 3, 4, 4, 4], 3)\n        True\n        &gt;&gt;&gt; last_n_elements_equal([1, 2, 3, 4, 5, 6], 3)\n        False\n    \"\"\"\n    return (n == 0) or (len(lst) &gt;= n and all(x == lst[-n] for x in lst[-n:]))\n</code></pre>"},{"location":"api.html#cobrak.utilities.make_kms_better_by_factor","title":"<code>make_kms_better_by_factor(cobrak_model, reac_id, factor)</code>","text":"<p>Adjusts the Michaelis constants (Km) for substrates and products of a specified reaction in the metabolic model.</p> <ul> <li>Substrate's Michaelis constants are divided by 'factor'.</li> <li>Product's Michaelis constants are multiplied by 'factor'.</li> <li>Only affects metabolites with existing enzyme reaction data.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>cobrak_model</code> <code>Model</code> <p>The metabolic model containing enzymatic constraints.</p> required <code>reac_id</code> <code>str</code> <p>The ID of the reaction to adjust the Km values for.</p> required <code>factor</code> <code>float</code> <p>The multiplication/division factor used to modify the Michaelis constants.</p> required <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>This function modifies the input Model object in place and does not return any value.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef make_kms_better_by_factor(\n    cobrak_model: Model, reac_id: str, factor: NonNegativeFloat\n) -&gt; None:\n    \"\"\"Adjusts the Michaelis constants (Km) for substrates and products of a specified reaction in the metabolic model.\n\n    - Substrate's Michaelis constants are divided by 'factor'.\n    - Product's Michaelis constants are multiplied by 'factor'.\n    - Only affects metabolites with existing enzyme reaction data.\n\n    Parameters:\n        cobrak_model (Model): The metabolic model containing enzymatic constraints.\n        reac_id (str): The ID of the reaction to adjust the Km values for.\n        factor (float): The multiplication/division factor used to modify the Michaelis constants.\n\n    Returns:\n        None: This function modifies the input Model object in place and does not return any value.\n    \"\"\"\n    reaction = cobrak_model.reactions[reac_id]\n\n    substrate_ids = [\n        met_id\n        for met_id in reaction.stoichiometries\n        if reaction.stoichiometries[met_id] &lt; 0\n    ]\n    for substrate_id in substrate_ids:\n        if substrate_id not in reaction.enzyme_reaction_data.k_ms:\n            continue\n        reaction.enzyme_reaction_data.k_ms[substrate_id] /= factor\n\n    product_ids = [\n        met_id\n        for met_id in reaction.stoichiometries\n        if reaction.stoichiometries[met_id] &gt; 0\n    ]\n    for product_id in product_ids:\n        if product_id not in reaction.enzyme_reaction_data.k_ms:\n            continue\n        reaction.enzyme_reaction_data.k_ms[product_id] *= factor\n</code></pre>"},{"location":"api.html#cobrak.utilities.parse_external_resources","title":"<code>parse_external_resources(path, brenda_version)</code>","text":"<p>Parse and verify the presence of external resource files required for a COBRAk model.</p> <p>This function checks if the necessary external resource files are present in the specified directory. If any required files are missing, it provides instructions on where to download them. Additionally, it processes certain files if their parsed versions are not found.</p> <p>The particular files that are lloked after are the NCBI TAXONOMY taxdump file and the BRENDA JSON TAR GZ as wel as the bigg_models_metabolites.txt file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The directory path where the external resource files are located.</p> required <code>brenda_version</code> <code>str</code> <p>The version of the BRENDA database to be used.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the specified path is not a directory.</p> <code>FileNotFoundError</code> <p>If any required files are missing from the specified directory.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef parse_external_resources(path: str, brenda_version: str) -&gt; None:\n    \"\"\"Parse and verify the presence of external resource files required for a COBRAk model.\n\n    This function checks if the necessary external resource files are present in the specified directory.\n    If any required files are missing, it provides instructions on where to download them. Additionally,\n    it processes certain files if their parsed versions are not found.\n\n    The particular files that are lloked after are the NCBI TAXONOMY taxdump file and\n    the BRENDA JSON TAR GZ as wel as the bigg_models_metabolites.txt file.\n\n    Args:\n        path (str): The directory path where the external resource files are located.\n        brenda_version (str): The version of the BRENDA database to be used.\n\n    Raises:\n        ValueError: If the specified path is not a directory.\n        FileNotFoundError: If any required files are missing from the specified directory.\n    \"\"\"\n    path = standardize_folder(path)\n    if not os.path.isdir(path):\n        print(\n            f\"ERROR: Given external resources path {path} does not seem to be a folder!\"\n        )\n        raise ValueError\n    filenames = get_files(path)\n\n    needed_filename_data = (\n        (\"taxdmp.zip\", \"https://ftp.ncbi.nih.gov/pub/taxonomy/\"),\n        (\"bigg_models_metabolites.txt\", \"http://bigg.ucsd.edu/data_access\"),\n        (\n            f\"brenda_{brenda_version}.json.tar.gz\",\n            \"https://www.brenda-enzymes.org/download.php\",\n        ),\n    )\n    for needed_filename, link in needed_filename_data:\n        if needed_filename not in filenames:\n            print(\n                f\"ERROR: File bigg_models_metabolites.txt not found in given external resources path {path}!\"\n            )\n            print(\n                \"Solution: Either change the path if it is wrong, or download the file from:\"\n            )\n            print(link)\n            print(\"(Accessed on Jun 24 2024, open link at your own risk!)\")\n            raise FileNotFoundError\n    if \"parsed_taxdmp.json.zip\" not in filenames:\n        parse_ncbi_taxonomy(f\"{path}taxdmp.zip\", f\"{path}parsed_taxdmp.json\")\n    if \"bigg_models_metabolites.json\" not in filenames:\n        bigg_parse_metabolites_file(\n            f\"{path}bigg_models_metabolites.txt\", f\"{path}bigg_models_metabolites.json\"\n        )\n</code></pre>"},{"location":"api.html#cobrak.utilities.print_model_parameter_statistics","title":"<code>print_model_parameter_statistics(cobrak_model)</code>","text":"<p>Prints statistics about reaction parameters (kcats and kms) in a COBRA-k model.</p> <p>This function calculates and prints statistics about the kcat and Km values associated with reactions in a COBRA-k model. It groups these values by their taxonomic distance (as indicated by references) and prints the counts for each distance group.  It also prints the median kcat and the median Km values for substrates and products separately.</p> <p>Parameters:</p> Name Type Description Default <code>cobrak_model</code> <code>Model</code> <p>The COBRA Model object.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None.  Prints statistics to the console.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(validate_return=True)\ndef print_model_parameter_statistics(cobrak_model: Model) -&gt; None:\n    \"\"\"Prints statistics about reaction parameters (kcats and kms) in a COBRA-k model.\n\n    This function calculates and prints statistics about the kcat and Km values\n    associated with reactions in a COBRA-k model. It groups these values by their\n    taxonomic distance (as indicated by references) and prints the counts for each\n    distance group.  It also prints the median kcat and the median Km values for\n    substrates and products separately.\n\n    Args:\n        cobrak_model: The COBRA Model object.\n\n    Returns:\n        None.  Prints statistics to the console.\n    \"\"\"\n    substrate_kms, product_kms = get_model_kms_by_usage(cobrak_model)\n    all_kms = substrate_kms + product_kms\n    all_kcats = get_model_kcats(cobrak_model)\n\n    kcats_by_taxonomy_score: dict[int, int] = {}\n    kms_by_taxonomy_score: dict[int, int] = {}\n    for reaction in cobrak_model.reactions.values():\n        if reaction.enzyme_reaction_data is None:\n            continue\n\n        enzdata = reaction.enzyme_reaction_data\n        if len(enzdata.k_cat_references) &gt; 0:\n            tax_distance = enzdata.k_cat_references[0].tax_distance\n        else:\n            tax_distance = -2\n        if tax_distance not in kcats_by_taxonomy_score:\n            kcats_by_taxonomy_score[tax_distance] = 0\n        kcats_by_taxonomy_score[tax_distance] += 1\n\n        for met_id in enzdata.k_ms:\n            if (met_id in enzdata.k_m_references) and len(\n                enzdata.k_m_references[met_id]\n            ) &gt; 0:\n                tax_distance = enzdata.k_m_references[met_id][0].tax_distance\n            else:\n                tax_distance = -2\n            if tax_distance not in kms_by_taxonomy_score:\n                kms_by_taxonomy_score[tax_distance] = 0\n            kms_by_taxonomy_score[tax_distance] += 1\n\n    print(\n        \"kcats:\",\n        sort_dict_keys(kcats_by_taxonomy_score),\n        sum(kcats_by_taxonomy_score.values()),\n        len(all_kcats),\n    )\n    print(\" -&gt;median:\", median(all_kcats))\n    print(\n        \"kms:\",\n        sort_dict_keys(kms_by_taxonomy_score),\n        sum(kms_by_taxonomy_score.values()),\n        len(all_kms),\n    )\n    print(\n        \" -&gt;median substrates:\",\n        median(substrate_kms),\n        \"-&gt;median products:\",\n        median(product_kms),\n    )\n    print(len(cobrak_model.reactions))\n</code></pre>"},{"location":"api.html#cobrak.utilities.sort_dict_keys","title":"<code>sort_dict_keys(dictionary)</code>","text":"<p>Sorts all keys in a dictionary alphabetically.</p> <p>Parameters:</p> Name Type Description Default <code>dictionary</code> <code>dict</code> <p>The dictionary to sort.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, T]</code> <p>A new dictionary with the keys sorted alphabetically.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(config=ConfigDict(arbitrary_types_allowed=True), validate_return=True)\ndef sort_dict_keys(dictionary: dict[str, T]) -&gt; dict[str, T]:\n    \"\"\"Sorts all keys in a dictionary alphabetically.\n\n    Args:\n        dictionary (dict): The dictionary to sort.\n\n    Returns:\n        dict: A new dictionary with the keys sorted alphabetically.\n    \"\"\"\n    return dict(sorted(dictionary.items()))\n</code></pre>"},{"location":"api.html#cobrak.utilities.split_list","title":"<code>split_list(lst, n)</code>","text":"<p>Split a list into <code>n</code> nearly equal parts.</p> <p>This function divides a given list into <code>n</code> sublists, distributing the elements as evenly as possible.</p> <p>Parameters: - lst (list[Any]): The list to be split. - n (int): The number of sublists to create.</p> <p>Returns: - list[list[Any]]: A list of <code>n</code> sublists, each containing a portion of the original list's elements.</p> <p>Example: <pre><code>result = _split_list([1, 2, 3, 4, 5], 3)\n# result: [[1, 2], [3, 4], [5]]\n</code></pre></p> <p>Raises: - ValueError: If <code>n</code> is less than or equal to 0.</p> Source code in <code>cobrak/utilities.py</code> <pre><code>@validate_call(config=ConfigDict(arbitrary_types_allowed=True), validate_return=True)\ndef split_list(lst: list[Any], n: PositiveInt) -&gt; list[list[Any]]:\n    \"\"\"Split a list into `n` nearly equal parts.\n\n    This function divides a given list into `n` sublists, distributing the elements as evenly as possible.\n\n    Parameters:\n    - lst (list[Any]): The list to be split.\n    - n (int): The number of sublists to create.\n\n    Returns:\n    - list[list[Any]]: A list of `n` sublists, each containing a portion of the original list's elements.\n\n    Example:\n    ```\n    result = _split_list([1, 2, 3, 4, 5], 3)\n    # result: [[1, 2], [3, 4], [5]]\n    ```\n\n    Raises:\n    - ValueError: If `n` is less than or equal to 0.\n    \"\"\"\n    k, m = divmod(len(lst), n)\n    return [lst[i * k + min(i, m) : (i + 1) * k + min(i + 1, m)] for i in range(n)]\n</code></pre>"},{"location":"construct_own.html","title":"Construct Own (MI)LPs or NLPs","text":"Quickstart code <pre><code>#%% Construct own MILP\nfrom cobrak.example_models import toy_model\n# Get the functionality that returns a basic (Mixed-Integer) Linear Program,\n# i.e. with steady-state constraint and variables for all reactions, and\n# if such constraints are chosen, also enzymes and metabolites.\nfrom cobrak.lps import get_lp_from_cobrak_model\n# Using COBRA-k's pyomo_functionality submodule, get the functions for setting\n# a custom objective and getting a pyomo solver\nfrom cobrak.pyomo_functionality import get_solver\n# Get a needed constants from COBRA-k\nfrom cobrak.constants import BIG_M\n# Get the function that converts pyomo solution states into a COBRA-k dictionary\nfrom cobrak.utilities import get_pyomo_solution_as_dict\n# Also get a pretty-printing function\nfrom cobrak.printing import print_dict\n# Get the needed classes from pyomo\nfrom pyomo.environ import Constraint, Binary, Var\n\n# Get the basic steady-state Linear Program, here with enzyme and thermodynamic\n# constraints.\n# This function has many more options that you can read in the\n# API reference.\n# The returned lp is a *pyomo* ConcreteModel object on which all operations\n# for pyomo models can be performed.\nlp = get_lp_from_cobrak_model(\n    cobrak_model=toy_model,\n    with_enzyme_constraints=True,\n    with_thermodynamic_constraints=True,\n    with_loop_constraints=False,\n)\n\n# Get all reaction IDs that start with \"EX_\"\nex_reac_ids = [reac_id for reac_id in toy_model.reactions if reac_id.startswith(\"EX_\")]\n\n# Now, add the EX_ reaction constraints in pyomo-style, i.e. using\n# Python's general getattr and setattr functions.\nfor ex_reac_id in ex_reac_ids:\n    # Get the *pyomo* LP flux variable\n    flux_var = getattr(lp, ex_reac_id)\n\n    # Now let's add a new binary variable for this EX_ reaction\n    # just as we would do it in pyomo\n    new_binary_var_id = f\"new_binary_{ex_reac_id}\"\n    setattr(lp, new_binary_var_id, Var(within=Binary))\n\n    # Finally, let's add an associated constraints through\n    # which the reaction can only run if the new binary variable &gt; 0\n    # We formulate it in Big-M style (i.e. if the binary variable\n    # = 1, the reaction flux can be &lt;= Big-M, whereby Big-M is just\n    # a large value)\n    setattr(\n        lp,\n        f\"new_constraint_{ex_reac_id}\",\n        Constraint(expr=flux_var &lt;= getattr(lp, new_binary_var_id) * BIG_M)\n    )\n\n# Now that we've added the constraints and variables, we can run the minimization :D\n# First, we manually choose a pyomo solver for this (here, the pre-packaged free solver SCIP)\n# (alternatively, we could also construct a Solver dataclass instance first and\n# send its data to get_solver).\npyomo_lp_solver = get_solver(\n    solver_name=\"scip\",\n    solver_options={},\n    solver_attrs={},\n)\n\n# With this solver, we can now solve the optimization :D\n# (here, in verbose style)\npyomo_lp_solver.solve(lp, tee=True)\n\n# We then retrieve the solution as a dictionary in the form of dict[str, float]\nlp_result_dict = get_pyomo_solution_as_dict(lp)\n\n# Finally, print the (unspecatular) result\nprint_dict(lp_result_dict)\n\n\n#%% Construct own NLP\n# (See previous example for more comments)\nfrom cobrak.example_models import toy_model\nfrom cobrak.nlps import get_nlp_from_cobrak_model\nfrom cobrak.pyomo_functionality import get_solver\nfrom cobrak.utilities import get_pyomo_solution_as_dict\nfrom cobrak.printing import print_dict\nfrom cobrak.constants import LNCONC_VAR_PREFIX\nfrom pyomo.environ import Constraint, Reals, Var\n\n# Get the basic steady-state Non-Linear Program, here with enzyme and thermodynamic\n# constraints.\n# This function has many more options that you can read in the\n# API reference.\n# Again, the returned nlp is a *pyomo* ConcreteModel object on which all operations\n# for pyomo models can be performed.\nnlp = get_nlp_from_cobrak_model(\n    cobrak_model=toy_model,\n    ignored_reacs=[],\n    with_kappa=True,\n    with_gamma=True,\n)\n\n# Get all logarithmic metabolite IDs\nlog_met_conc_ids = [f\"{LNCONC_VAR_PREFIX}{met_id}\" for met_id in toy_model.metabolites]\n\n# Now, create a sum that represents the squared sum\n# of logarithmic concentrations\nsquared_log_metconc_sum = 0.0\nfor log_met_conc_id in log_met_conc_ids:\n    # Get the *pyomo* NLP metabolite concentration variable\n    # and add its squared sum\n    squared_log_metconc_sum += getattr(nlp, log_met_conc_id) ** 2\n\n# Now let's add a new real variable for the squared sum that\n# is always equal to it (i.e. it represents this sum, making\n# it later possible to minimize it :-)\n# Also, set it to values &gt;=0\nsquared_met_logconc_sum_var_id = \"squared_met_logconc_sum\"\nsetattr(nlp, squared_met_logconc_sum_var_id, Var(within=Reals, bounds=(0.0, 1e6)))\n# Now fix this variable to the pyomo sum expression we created\nsetattr(\n    nlp,\n    \"squared_met_logconc_sum_constraint\",\n    Constraint(expr=getattr(nlp, squared_met_logconc_sum_var_id) == squared_log_metconc_sum)\n)\n\n# Now we get the NLP solver\npyomo_nlp_solver = get_solver(\n    solver_name=\"ipopt\",\n    solver_options={},\n    solver_attrs={},\n)\n\n# With this solver, we can now solve the optimization :D\n# (here, in verbose style)\npyomo_nlp_solver.solve(nlp, tee=True)\n\n# We then retrieve the solution as a dictionary in the form of dict[str, float]\nnlp_result_dict = get_pyomo_solution_as_dict(nlp)\n\n# Finally, print the (unspecatular) result\nprint_dict(nlp_result_dict)\n</code></pre>"},{"location":"construct_own.html#introduction","title":"Introduction","text":"<p>Up to now, we looked at the range of predefined (mixed-integer) linear programs (e.g. ecTFVA, bottleneck analyses, ...; see LP and MILP chapters) and non-linear programs (see NLP chapter) provided by COBRA-k, whereby...</p> <ul> <li>...the general optimization functions (such as <code>perform_lp_optimization</code>and <code>perform_nlp_optimization</code>) allow one to optimize any objective function in the model</li> <li>...and the special optimziation functions (such as <code>perform_lp_thermodynamic_bottleneck_analysis</code>) provide expanded programs with additional constraints and variables.</li> </ul> <p>But sometimes, for advanced optimizations, you need to add your own extra constraints and/or variables. Luckily, this is possible in COBRA-k thanks to its internal usage of pyomo WebsiteGitHub, as explained in the following subchapters :-)</p> <p>Alternative for simple cases: Extra (non-)linear watches and constraints</p> <p>If you just want to restrict a (non-)linear weighted sum of any kind of model variables, you can always use the <code>extra_linear_watches</code>, <code>extra_nonlinear_watches</code>, <code>extra_linear_constraints</code> and <code>extra_nonlinear_constraints</code> member variable as explained in the LP and NLP chapters and the API documentation.</p>"},{"location":"construct_own.html#example-1-construct-own-milps","title":"Example 1: Construct own (MI)LPs","text":"<p>Let's say that we want to minimize the number of used exchange reactions (i.e. reactions where a metabolite is consumed or produced \"out of nothing\"; commonly, their ID starts with \"EX_\"). As they do not have an associated \u0394\u1d63G'\u00b0 (see MILP chapter), we do not have binary variables for them which control whether they are active or not. So let's introduce these binary variables and performing the subsequent minimization as follows for our toy model:</p> <pre><code># Get our toy model\nfrom cobrak.example_models import toy_model\n# Get the functionality that returns a basic (Mixed-Integer) Linear Program,\n# i.e. with steady-state constraint and variables for all reactions, and\n# if such constraints are chosen, also enzymes and metabolites.\nfrom cobrak.lps import get_lp_from_cobrak_model\n# Using COBRA-k's pyomo_functionality submodule, get the functions for setting\n# a custom objective and getting a pyomo solver\nfrom cobrak.pyomo_functionality import get_solver\n# Get a needed constants from COBRA-k\nfrom cobrak.constants import BIG_M\n# Get the function that converts pyomo solution states into a COBRA-k dictionary\nfrom cobrak.utilities import get_pyomo_solution_as_dict\n# Also get a pretty-printing function\nfrom cobrak.printing import print_dict\n# Get the needed classes from pyomo\nfrom pyomo.environ import Constraint, Binary, Var\n\n# Get the basic steady-state Linear Program, here with enzyme and thermodynamic\n# constraints.\n# This function has many more options that you can read in the\n# API reference.\n# The returned lp is a *pyomo* ConcreteModel object on which all operations\n# for pyomo models can be performed.\nlp = get_lp_from_cobrak_model(\n    cobrak_model=toy_model,\n    with_enzyme_constraints=True,\n    with_thermodynamic_constraints=True,\n    with_loop_constraints=False,\n)\n\n# Get all reaction IDs that start with \"EX_\"\nex_reac_ids = [reac_id for reac_id in toy_model.reactions if reac_id.startswith(\"EX_\")]\n\n# Now, add the EX_ reaction constraints in pyomo-style, i.e. using\n# Python's general getattr and setattr functions.\nfor ex_reac_id in ex_reac_ids:\n    # Get the *pyomo* LP flux variable\n    flux_var = getattr(lp, ex_reac_id)\n\n    # Now let's add a new binary variable for this EX_ reaction\n    # just as we would do it in pyomo\n    new_binary_var_id = f\"new_binary_{ex_reac_id}\"\n    setattr(lp, new_binary_var_id, Var(within=Binary))\n\n    # Finally, let's add an associated constraints through\n    # which the reaction can only run if the new binary variable &gt; 0\n    # We formulate it in Big-M style (i.e. if the binary variable\n    # = 1, the reaction flux can be &lt;= Big-M, whereby Big-M is just\n    # a large value)\n    setattr(\n        lp,\n        f\"new_constraint_{ex_reac_id}\",\n        Constraint(expr=flux_var &lt;= getattr(lp, new_binary_var_id) * BIG_M)\n    )\n\n# Now that we've added the constraints and variables, we can run the minimization :D\n# First, we manually choose a pyomo solver for this (here, the pre-packaged free solver SCIP)\n# (alternatively, we could also construct a Solver dataclass instance first and\n# send its data to get_solver).\npyomo_lp_solver = get_solver(\n    solver_name=\"scip\",\n    solver_options={},\n    solver_attrs={},\n)\n\n# With this solver, we can now solve the optimization :D\n# (here, in verbose style)\npyomo_lp_solver.solve(lp, tee=True)\n\n# We then retrieve the solution as a dictionary in the form of dict[str, float]\nlp_result_dict = get_pyomo_solution_as_dict(lp)\n\n# Finally, print the (unspecatular) result\nprint_dict(lp_result_dict)\n</code></pre>"},{"location":"construct_own.html#example-2-construct-own-nlps","title":"Example 2: Construct own NLPs","text":"<p>Of course, we can also construct our own NLPs. Here's an example where we (for whatever reason xD) we try to minimize the squared logarithmic metabolite concentrations in our model:</p> <pre><code># (See previous example for more comments)\nfrom cobrak.example_models import toy_model\nfrom cobrak.nlps import get_nlp_from_cobrak_model\nfrom cobrak.pyomo_functionality import get_solver\nfrom cobrak.utilities import get_pyomo_solution_as_dict\nfrom cobrak.printing import print_dict\nfrom cobrak.constants import LNCONC_VAR_PREFIX\nfrom pyomo.environ import Constraint, Reals, Var\n\n# Get the basic steady-state Non-Linear Program, here with enzyme and thermodynamic\n# constraints.\n# This function has many more options that you can read in the\n# API reference.\n# Again, the returned nlp is a *pyomo* ConcreteModel object on which all operations\n# for pyomo models can be performed.\nnlp = get_nlp_from_cobrak_model(\n    cobrak_model=toy_model,\n    ignored_reacs=[],\n    with_kappa=True,\n    with_gamma=True,\n)\n\n# Get all logarithmic metabolite IDs\nlog_met_conc_ids = [f\"{LNCONC_VAR_PREFIX}{met_id}\" for met_id in toy_model.metabolites]\n\n# Now, create a sum that represents the squared sum\n# of logarithmic concentrations\nsquared_log_metconc_sum = 0.0\nfor log_met_conc_id in log_met_conc_ids:\n    # Get the *pyomo* NLP metabolite concentration variable\n    # and add its squared sum\n    squared_log_metconc_sum += getattr(nlp, log_met_conc_id) ** 2\n\n# Now let's add a new real variable for the squared sum that\n# is always equal to it (i.e. it represents this sum, making\n# it later possible to minimize it :-)\n# Also, set it to values &gt;=0\nsquared_met_logconc_sum_var_id = \"squared_met_logconc_sum\"\nsetattr(nlp, squared_met_logconc_sum_var_id, Var(within=Reals, bounds=(0.0, 1e6)))\n# Now fix this variable to the pyomo sum expression we created\nsetattr(\n    nlp,\n    \"squared_met_logconc_sum_constraint\",\n    Constraint(expr=getattr(nlp, squared_met_logconc_sum_var_id) == squared_log_metconc_sum)\n)\n\n# Now we get the NLP solver\npyomo_nlp_solver = get_solver(\n    solver_name=\"ipopt\",\n    solver_options={},\n    solver_attrs={},\n)\n\n# With this solver, we can now solve the optimization :D\n# (here, in verbose style)\npyomo_nlp_solver.solve(nlp, tee=True)\n\n# We then retrieve the solution as a dictionary in the form of dict[str, float]\nnlp_result_dict = get_pyomo_solution_as_dict(nlp)\n\n# Finally, print the (unspecatular) result\nprint_dict(nlp_result_dict)\n</code></pre>"},{"location":"evolutionary.html","title":"Evolutionary optimization","text":"Quickstart code <pre><code>from cobrak.example_models import toy_model\nfrom cobrak.evolution import perform_nlp_evolutionary_optimization\nfrom cobrak.printing import print_dict, print_optimization_result\n\n# Run the evolutionary optimization, get a sorted dictionary of the form\n#  {\n#   $FOUND_OBJECTIVE_VALUE: [ALL_NLP_RESULTS_WITH_THIS_OBJECTIVE_VALUE],\n#   (...)\n#  }\n# i.e., it contains all found objective values in descending order as keys\n# and all NLP solutions (with all variable values) with this objective\n# value as values.\ncomplete_result = perform_nlp_evolutionary_optimization(\n    cobrak_model=toy_model,\n    objective_target=\"ATP_Consumption\",\n    objective_sense=+1,\n    variability_dict={}, # No variability dict given -&gt; An ecTFVA is automatically run for us\n)\nprint_dict(complete_result)\nbest_result = complete_result[list(complete_result.keys())[0]][0] # 0-&gt;The first element is the best\nprint_optimization_result(toy_model, best_result)\n\n# %% Postprocesing\nfrom cobrak.evolution import postprocess\n\npostprocess_results, best_postprocess_result = postprocess(\n    cobrak_model=toy_model,\n    opt_dict=best_result,\n    objective_target=\"ATP_Consumption\",\n    objective_sense=+1,\n    variability_data={}, # No variability dict given -&gt; An ecTFVA is automatically run for us\n)\n\nprint(\"All postprocessing tries\")\nprint_dict(postprocess_results)\nprint(\"Best postprocess result (i.e., with best objective value :-)\")\nprint_optimization_result(toy_model, best_postprocess_result)\n</code></pre>"},{"location":"evolutionary.html#introduction","title":"Introduction","text":"<p>Note</p> <p>Also check out another toy model evolution example in COBRA-k's repository which you may find under <code>examples/toymodel/run_toymodel_calculations.py</code>.</p> <p>As mentioned in the previous chapter, both the global MINLP and the local NLP have major disadvantages:</p> <ul> <li>The MINLP quickly becomes way too slow with increasing model size</li> <li>The NLP is quick, but only works for one selected set of thermodynamically feasible reactions (i.e. reactions with \\(f_i&gt;0\\))</li> </ul> <p>To overcome these disadvantages, COBRA-k provides an efficient and often quite quick evolutionary algorithm [Wikipedia]. This evolutionary algorithm allows one to quite quickly optmize a COBRA-k Model with a full integration of non-linear thermodynamic and kinetic constraints.</p> <p>Global solutions</p> <p>The evolutionary algorithm cannot guarantee that the found solution is global. Hence, it is advisable to let it run until no improvement can be found over a set amount of rounds (see below). Nevertheless, any solution found by the evolutionary algorithm is valid and a solution to the given constraints, just maybe not one that is globally optimal.</p> <p>For a higher confidence in a found result, it is advisable to run multiple evolutionary optimizations with the same objective function. If the returned results are the same or at least nearly identical, the confidence in the result may rise.</p>"},{"location":"evolutionary.html#the-evolutionary-algorithm","title":"The evolutionary algorithm","text":""},{"location":"evolutionary.html#input","title":"Input","text":"<p>As obligatory input, COBRA-k's evolutionary algorithm takes:</p> <ul> <li>A COBRA-k Model, including all its kinetic and thermodynamic parameters</li> <li>An objective target, which can be - as for linear optmizations (see LP chapter) - either a single model variable ID (<code>str</code>) or a linear term of multiple model variables (<code>dict[str, float]</code>). As with all other optmizations, the objective target can be any kind of model variable, including fluxes, concentrations, \u03ba and \u03b3 values etc.</li> <li>An objective sense, i.e. either a minimization (-1) or maximization (+1) of a value.</li> <li>Furthermore, COBRA-k's evolutionary algorithm provides many further optional inputs. These include e.g. whether or not \u03ba and/or \u03b3 constraints shall be regarded and solver settings. For more, see this documentation's API reference for the submodule <code>evolution</code>.</li> </ul> <p>COBRA-k's evolutionary algorithm itself is composed of the following main steps:</p> <ol> <li>Preparatory Variability Analysis - to find variable bounds</li> <li>Initialization - to find some feasbile solutions as starting points</li> <li>Evolutionary Run - to find a (hopefully) optimal solution</li> </ol> <p>The next sub-paragraphs explain these steps in more detail.</p>"},{"location":"evolutionary.html#preparatory-variability-analysis","title":"Preparatory Variability Analysis","text":"<p>Again, as we use the NLP, we have to run the preparatory variability analysis as explained in the previous chapter. In COBRA-k, you do not have to call this variability analysis separately in your code as such a variablity analysis is automatically calculated if you do not provide already existing variability data.</p> <p>Note</p> <p>As for the NLP (see NLP chapter), this preparatory variability analysis is essential to avoid non-linear solver errors.</p>"},{"location":"evolutionary.html#initialization","title":"Initialization","text":"<p>Using the mentioned input values, the following routines are run for our initializing sampling:</p> <ol> <li>We have a given (e.g. randomly selected) set of enforced deactivated reactions (i.e. \\(v_i=0\\)).</li> <li>A first ecTFBA (see MILP chapter) is run with the COBRA-k Model and the given objective function. From this first ecTFBA, we store the objective value.</li> <li>Using the objective value from the previous step, we now maximize the number of thermodynamically active reactions, i.e. \\(max \\sum{z_i}\\) with an ecTFBA. We store the resulting flux pattern (i.e. all resulting active reactions).</li> <li>Using the flux pattern from the previous step, we create a reduced COBRA-k model where no inactive reactions (i.e. \\(v_i=0\\) in the flux pattern) occur.</li> <li>Using this reduced COBRA-k model, we now run our fast NLP with the general input objective function. We return the objective value.</li> <li>Exception step: If any of the previous optmizations results in infeasibility (i.e. no solution can be found with the given set of deavtivated reactions), we return an appropriate signal to let us know that.</li> </ol> <p>If enough feasible solutions are found in a given maximal number of initializing sampling rounds (all which can be set in COBRA-k's evolution method), we now have an initializing set of feasible flux distributions and associated objective values.</p>"},{"location":"evolutionary.html#evolutionary-run","title":"Evolutionary run","text":"<p>Now that we have variable bounds (from the preparatory variability analysis) and some feasible starting points (from the initialization), we can call the actual evolutionary run. The evolutionary run consists of an outer and an inner optimization, as well as a small preparatory calculations:</p>"},{"location":"evolutionary.html#identification-of-stoichiometric-couples","title":"Identification of stoichiometric couples","text":"<p>First, we identify all stoichiometric couples in our model's stoichiometric matrix. Such couples are reactions which always have to be active or inactive together. E.g. if we have a linear pathway such as -&gt;A-&gt;B-&gt;C-&gt;, then all reactions have to be active together in order to achieve a steady-state.</p>"},{"location":"evolutionary.html#outer-optimization","title":"Outer optimization","text":"<p>The outer optimization is affecting a binary (or \\(\\[0,1\\]\\)) vector which we'll call \\(\\mathbf{\u03b2}\\). This vector is as long as the number of the previously identified stoichiometric couples. If an element \\(i\\) of \\(\\mathbf{\u03b2}\\) is 0 (or close to 0), then the flux of all reactions in the respective \\(i\\)th stoichiometric couple is set to 0. Otherwise, the reactions are allowed to run.</p> <p>\\(\\mathbf{\u03b2}\\) is optmized through a genetic algorithm [Wikipedia]. This algorithm works in rounds and has a given population (or candidate) size:</p> <ol> <li>In each round, as many inner optimizations (see next subparagraph) as there are population members are run. Thus, we actually have as many \\(\\mathbf{\u03b2}\\) as there are population members.</li> <li>Then, the fitnesses (here, the final NLP optimization value from the inner optimizations) are collected for each population member.</li> <li>Using these fitness values, the \\(\\mathbf{\u03b2}\\) of the population members are mutated according to the genetic algorithm, with the intention and hope that better \\(\\mathbf{\u03b2}\\) are found. Then, we start again with step 1 unless the maximal number of rounds or the maximal number of rounds without an increase in the best optimal value is reached.</li> </ol>"},{"location":"evolutionary.html#inner-optimization","title":"Inner optimization","text":"<p>The inner optimization consists of two ecTFBAs (see MILP chapter) and a subsequent NLP (see NLP chapter):</p> <ol> <li>The first ecTFBA maximizies our objective.</li> <li>The second ecTFBA maximizied the number of thermodynamically feasible active reactions under our previously calculated objective value. This allows to find solutions which need more than a minimal or near-minimal set of active reactions.</li> <li>The NLP is then run on all active reactions of the last ecTFBA and returns a fitness value :-)</li> </ol> <p>If any of these three steps shows that there is an infeasiblity, an infeasibility signal is sent to the outer optimization.</p>"},{"location":"evolutionary.html#running-an-evolutionary-optimization-in-cobra-k","title":"Running an evolutionary optimization in COBRA-k","text":"<p>Now let's run an evolutionary optimization with our toy model, which is much simpler to do than to describe the many steps of the algorithm :-) COBRA-k has all its evolutionary algorithm functionality in the ``evolution```subpackage.</p> <pre><code>from cobrak.example_models import toy_model\nfrom cobrak.evolution import perform_nlp_evolutionary_optimization\nfrom cobrak.printing import print_dict, print_optimization_result\n\n# Run the evolutionary optimization, get a sorted dictionary of the form\n#  {\n#   $FOUND_OBJECTIVE_VALUE: [ALL_NLP_RESULTS_WITH_THIS_OBJECTIVE_VALUE],\n#   (...)\n#  }\n# i.e., it contains all found objective values in descending order as keys\n# and all NLP solutions (with all variable values) with this objective\n# value as values.\ncomplete_result = perform_nlp_evolutionary_optimization(\n    cobrak_model=toy_model,\n    objective_target=\"ATP_Consumption\",\n    objective_sense=+1,\n    variability_dict={}, # No variability dict given -&gt; An ecTFVA is automatically run for us\n)\nprint_dict(complete_result)\nbest_result = complete_result[list(complete_result.keys())[0]][0] # 0-&gt;The first element is the best\nprint_optimization_result(toy_model, best_result)\n</code></pre> <p>COBRA-k's <code>perform_nlp_evolutionary_optimization</code>function has many more possible parameters (see also the following info box), which you can look up in this documentation's API overview for the <code>evolution</code>module.</p> <p>Working with larger models</p> <p>The evolutionary algorithm can also work efficiently with much larger models. E.g. in COBRA-k's initial publication [Paper], the mid-scale model iCH360 [Paper] was succesfully used. iCH360 consists of hundreds of reactions and metabolites.</p> <p>If you have trouble finding a good objective value from the evolutionary algorithm for your model, consider trying out different population sizes (through the <code>perform_nlp_evolutionary_optimization</code> parameter <code>pop_size</code>, which defaults to your computer's number of CPU cores) and the <code>evolution_num_gens</code>total evolutionary rounds parameter. Usually, the more population members and the more rounds, the better the optimization should become, at the expense of more needed computational time.</p>"},{"location":"evolutionary.html#postprocessing","title":"Postprocessing","text":"<p>Oftentimes, the genetic algorithm may fail to identify better sets of active reactions that only slightly differ from the best found solution. To mitigate this problem, COBRA-k also provides a postprocessing routine, which simply looks for single (and a low number of) reaction inactivations and activations, trying to identify better solutions. Here's how to use its functionality in COBRA-k:</p> <pre><code># ...continuing from the previous code block\nfrom cobrak.evolution import postprocess\n\npostprocess_results, best_postprocess_result = postprocess(\n    cobrak_model=toy_model,\n    opt_dict=best_result,\n    objective_target=\"ATP_Consumption\",\n    objective_sense=+1,\n    variability_data={}, # No variability dict given -&gt; An ecTFVA is automatically run for us\n)\n\nprint(\"All postprocessing tries\")\nprint_dict(postprocess_results)\nprint(\"Best postprocess result (i.e., with best objective value :-)\")\nprint_optimization_result(toy_model, best_postprocess_result)\n</code></pre> <p>Note</p> <p>In our toy model, the postprocessing does not lead to a better solution as the genetic algorithm already found the optimal solution. However, in larger models, it is strongly advised to double-check your genetic algorithm results through running the postprocessing.</p>"},{"location":"installation.html","title":"Installation","text":"<p>COBRA-k is a Python package hosted on PyPI, compatible with Python version 3.10 or later. If you have already installed an appropriate Python version on your system, you can install COBRA-k with pip:</p> <p><pre><code>pip install cobrak\n</code></pre> Note: If you encounter any trouble due to a missing SCIP installation (which may happen on some systems), you have to install the free and open-source mixed-integer linear solver SCIP on your system. To do so, follow the SCIP download instructions here:</p> <p>https://scipopt.org/index.php#download</p> <p>or, if no matching download is provided for your system, the compilation instructions here:</p> <p>https://scipopt.org/doc/html/INSTALL.php</p> Optional alternative installation for conda or mamba users <p>If you're using conda or mamba and want to have a clean COBRA-k environment, create an empty environment with Python and pip, activate it and install COBRA-k afterwards. E.g., on a plain bash console, the steps are as follows (again, any Python\u22653.10 should work):</p> <p><pre><code>(base) conda create --name cobrak python=3.10 pip -c conda-forge\n(base) conda activate cobrak\n(cobrak) pip install cobrak\n</code></pre> If you use mamba, just switch \"conda\" to \"mamba\".</p> Alternative installation for COBRA-k developers <p>If you want to directly play with COBRA-k's code base, follow the developer instructions in COBRA-k's README</p>"},{"location":"installation.html#installation-of-third-party-solvers","title":"Installation of third-party solvers","text":"<p>COBRA-k always comes pre-packaged with the quite capable open source linear (mixed-integer) solver HiGHS and the linear and non-linear program solver IPOPT (and on some systems, also automatically the solver SCIP). With this solver, all optimizations without integer variables provided by COBRA-k can be run.</p> <p>Note</p> <p>IPOPT comes pre-packages with the free linear subsolver MA27. However, for larger models, the much faster linear subsolver MA57 or one of its alternatives are highly recommended. See here on how to obtain them (e.g. a free academic license is provided):</p> <p>https://licences.stfc.ac.uk/product/coin-hsl</p> <p>In the <code>cobrak.standard_solvers</code>subpackage (which is further explained in later chapters), you can find <code>IPOPT_MA57</code>, an example on how to configure a <code>Solver</code>instance for MA57. The standard solver <code>IPOPT</code>uses the slow MA27.</p> <p>Additionally, all solvers supported by pyomo can be used. These include the very fast commercial mixed-integer linear solvers CPLEX and Gurobi. However, as both of these solvers are not automatically bundled with COBRA-k, these solvers and their Python bindings have to be installed seperately. Thereby, the Python bindings have to be installed in your COBRA-k Python environment.</p> <p>For CPLEX, you can find installation instructions here:</p> <ul> <li> <p>CPLEX itself</p> </li> <li> <p>CPLEX Python bindings</p> </li> </ul> <p>For Gurobi, you can find installation instructions here:</p> <ul> <li> <p>Gurobi itself</p> </li> <li> <p>Gurobi Python bindings</p> </li> </ul>"},{"location":"lps.html","title":"Linear Programs","text":"Quickstart code <pre><code>#%\n# Print stoichiometric matrix\nfrom cobrak.example_models import toy_model\nfrom cobrak.utilities import get_stoichiometric_matrix\n\nprint(get_stoichiometric_matrix(toy_model))\n\n#%\n# Perform Flux Balance Analysis with simple objective\n# Load the general Linear Program optimization function of COBRA-k\n# which can be found in COBRA-k's submodule 'lps'\nfrom cobrak.lps import perform_lp_optimization\n# Load some pretty-print functions (can be found in submodule 'printing')\nfrom cobrak.printing import print_dict, print_optimization_result\n\n# Maximize the flux of Glycolysis using the CBM constraints\nfba_result = perform_lp_optimization(\n    toy_model,\n    \"Glycolysis\",\n    +1,\n) # fba_result is a dict[str, float]\n\n# Pretty print result as dictionary\nprint_dict(fba_result)\n\n# Pretty print the result as (nicer-looking :-) tables\nprint_optimization_result(toy_model, fba_result)\n\n#%\n# Load the name of the variable that holds the objective name\nfrom cobrak.constants import OBJECTIVE_VAR_NAME\n\nprint(fba_result[OBJECTIVE_VAR_NAME])\n\n#%\n# Perform FBA with more complex objective\nperform_lp_optimization(\n    toy_model,\n    {\"Glycolysis\": -1.5, \"Overflow\": 2.0}, # No str anymore\n    +1,\n)\n\n#%\n# Perform pFBA\nfrom cobrak.constants import FLUX_SUM_VAR_ID\n# We perform a pFBA on our Glycolysis optimization example\n# 1) We set the objective value as minimum\ntoy_model.reactions[\"Glycolysis\"].min_flux = fba_result[\"Glycolysis\"]\n\n# 2) Now, the flux sum minimization\npfba_result = perform_lp_optimization(\n    toy_model,\n    FLUX_SUM_VAR_ID,\n    -1,\n    with_flux_sum_var=True,\n) # Again, pfba_result is a dict[str, float]\n\n# Let's print our pFBA result\nprint_optimization_result(toy_model, pfba_result)\n\n# Reset model for the next calculations\ntoy_model.reactions[\"Glycolysis\"].min_flux = 0.0\n\n#%\n# Perform Flux Variability Analysis\nfrom cobrak.lps import perform_lp_variability_analysis\nfrom cobrak.printing import print_variability_result\n# Perform general FVA (we did not set the previous objective value as minimum)\nvar_result = perform_lp_variability_analysis(\n    toy_model,\n)\n\n# Pretty print result as tables\nprint_variability_result(toy_model, var_result)\n\n# Print a minimal value\nprint(var_result[\"Overflow\"][0])\n\n#%\n# Perform enzyme-constrained ecFBA\necfba_result = perform_lp_optimization(\n    toy_model,\n    {\"Glycolysis\": +1.0},  # No str anymore\n    +1,\n    with_enzyme_constraints=True,  # Activate linear enzyme constraints\n)\n\n# Pretty-print result, now also with actual enzyme usage :-)\nprint_optimization_result(toy_model, ecfba_result)\n\n#%\n# Perform general enzyme-constrained ecFVA\nvar_result = perform_lp_variability_analysis(\n    toy_model\n)\n\n# Pretty print result as tables - again, now with enzyme usages :-)\nprint_variability_result(toy_model, var_result)\n\n#%\nfrom cobrak.utilities import get_reaction_enzyme_var_id\n# Get an enzyme variable name\nenzyme_name_of_glycolysis = get_reaction_enzyme_var_id(\"Glycolysis\", toy_model.reactions[\"Glycolysis\"])\nprint(enzyme_name_of_glycolysis)\n\n#%\n# Create XLSX spreadsheet with variability and optimization results\nfrom cobrak.spreadsheet_functionality import (\n    OptimizationDataset, # Here, we set the optimization result and its wished shown data\n    VariabilityDataset, # Here, we set the variability result and its wished shown data\n    create_cobrak_spreadsheet, # The function to generate the XLSX\n)\n\n# We're going to create an XLSX with the following three results:\n# 1. General FVA\nvar_result = perform_lp_variability_analysis(\n    toy_model\n)\n# 2. ATP optimization\nmax_atp_result = perform_lp_optimization(\n    toy_model,\n    \"ATP_Consumption\",\n    +1,\n)\n# 2. Overflow optimization\nmax_overflow_result = perform_lp_optimization(\n    toy_model,\n    \"Overflow\",\n    +1,\n)\n\n# Now let's wrap the variability result into a\n# create_cobrak_spreadsheet()-compatible format \ud83c\udf81\n# The keys are the dataset titles in the spreadsheet\nvariability_datasets: dict[str, VariabilityDataset] = {\n    \"FVA result\": VariabilityDataset(\n        data=var_result, # Obligatory argument\n        with_df=False, # Optional, default False; Do we show driving forces (see MILP chapter)?\n    )\n} # This is a list as we could add multiple variability results\n\n# Now let's wrap the optimization results into a\n# create_cobrak_spreadsheet()-compatible format \ud83c\udf81\n# The keys are the dataset titles in the spreadsheet\noptimization_datasets: dict[str, OptimizationDataset] = {\n    \"Max ATP\": OptimizationDataset(\n        data=max_atp_result, # Obligatory argument\n        with_df=False, # Optional, default False; Do we show driving forces (see MILP chapter)?\n        with_vplus=False, # Optional, default False; Do we show V+ (see enzyme constraints)?\n        with_kappa=False, # Optional, default False; Do we show kappa values (see NLP chapter)?\n        with_gamma=False, # Optional, default False; Do we show gamma values (see NLP chapter)?\n        with_kinetic_differences=False, # Optional, default False; Do we show NLP approximation differences (see corrections chapter)?\n        with_error_corrections=False,  # Optional, default False; Do we show corrections (see corrections chapter)?\n    ),\n    \"Max Overflow\": OptimizationDataset(\n        data=max_overflow_result,\n    ),\n}\n\n# Create XLSX spreadsheet (for this example, to not pollute your\n# file system, as temporary file)\nimport tempfile\nfrom cobrak.io import json_write\nwith tempfile.NamedTemporaryFile(suffix='.xlsx', delete=False) as temp:\n    json_write(temp.name, fba_result)\n    create_cobrak_spreadsheet(\n        temp.name,\n        toy_model,\n        variability_datasets,\n        optimization_datasets,\n    )\nprint(f\"Spreadsheet created! You can now load it in your favorite spreadsheet viewer at {temp.name}\")\n\n\n#%\n# Store optimization result as JSON (you can do the same for variability results)\nfrom cobrak.io import json_load, json_write\n\n# Perform FBA\nfba_result = perform_lp_optimization(\n    toy_model,\n    {\"Glycolysis\": +1.0},  # No str anymore\n    +1,\n)\n\n# Store ecFBA result as JSON (for this example, to not pollute your\n# file system, as temporary file)\nimport tempfile\nwith tempfile.NamedTemporaryFile(suffix='.json') as temp:\n    json_write(temp.name, fba_result)\n\n    # Load the ecFBA result again\n    loaded_fba_result = json_load(temp.name)\n\n    # Print one flux value of the ecFBA result\n    print(loaded_fba_result[\"Glycolysis\"])\n\n#%\n# Export optimization result as CNApy scenario file\nfrom cobrak.utilities import create_cnapy_scenario_out_of_optimization_dict\n\n# Perform FBA\nfba_result = perform_lp_optimization(\n    toy_model,\n    {\"Glycolysis\": +1.0},  # No str anymore\n    +1,\n)\n\n# Store ecFBA result as CNApy scenario (for this example, to not pollute your\n# file system, as temporary file)\nimport tempfile\nwith tempfile.NamedTemporaryFile(suffix=\".scen\", delete=False) as temp:\n    create_cnapy_scenario_out_of_optimization_dict(\n        path=temp.name,\n        cobrak_model=toy_model,\n        optimization_dict=fba_result,\n    )\n\n    # Print one flux value of the ecFBA result\n    print(\"The .scen file is in:\", temp.name, \"and can now be loaded in CNApy\")\n    print(\"Use the CNApy default model 'cobrak_toymodel.cna' for a succesful visualization of the result\")\n\n#%\n# Run optimization with different solver\nfrom cobrak.dataclasses import Solver\n\nipopt = Solver(\n    name=\"ipopt\", # This must be the same name as given in pyomo\n    solver_options={ # Options for the called solver itself\n        \"max_iter\": 100_000,\n        # Note that these options are solver-specific, i.e. they\n        # typically won't work for other solvers\n    },\n    solver_attrs={\n        # These would be attributes to the pyomo solver object itself\n        # e.g., for the solver SCIP, we may set\n        # \"_version_timeout\": 180 to prevent a fast timeout of pyomo's\n        # SCIP call\n    },\n    solve_extra_options={\n        # These would be extra argument's to pyomo's solve function\n        # Consult pyomo's documentation on the possible arguments\n    },\n)\n\nprint(\"Now we solve with the solver IPOPT :D\")\nperform_lp_optimization(\n    toy_model,\n    \"ATP_Consumption\",\n    +1,\n    solver=ipopt,\n    verbose=True, # Show explicitly the IPOPT output\n)\n</code></pre> <p>Warning</p> <p>As explained in the Installation chapter, you might have to install the quite capable mixed-integer (non-)linear open-source solver SCIP on your system to run the examples of this documentation. That's because, although the COBRA-k package installs the SCIP Python package, SCIP itself might be missing on some systems.</p> <p>If SCIP is not available on your system, you may try to use the pre-installed HiGHS solver by (i) adding <code>from cobrak.dataclasses import HIGHS</code> as first line in all your scripts and then, in all optimization functions (such as <code>perform_lp_optimization</code>), using the argument <code>solver=HIGHS</code>.</p> <p>If HiGHS also does not work, try installing and using the free and open-source solver GLPK by (i) adding <code>from cobrak.dataclasses import Solver</code> as first line in all your scripts and then, in all optimization functions (such as <code>perform_lp_optimization</code>), using the argument <code>solver=Solver(name=\"glpk\")</code>.</p>"},{"location":"lps.html#introduction","title":"Introduction","text":"<p>COBRA-k's analyses are all based on the framework of \"Constraint-Based Reconstruction and Analysis\" [Review], enriched with kinetics  - in short COBRA-k. We performed the Constraint-Based Reconstruction by creating our small toy model. Some constraints that we set were minimal and maximal fluxes and concentrations. And now, we perform some Constraint-Based Analysis :D</p> <p>In this chapter, we concentrate on Constraint-Based Analyses based on Linear Programming or LP [Paper][Wikipedia], also called Linear Optimization.</p> Excursion: Linear Programming (LP) <p>While we often want to find one solution for a single or a system of linear equations, in LP, we want to find an optimal solution. E.g. instead of finding one possible value for a variable \\(x\\), we would want to find the maximal or minimal possible value of \\(x\\) given the linear equations/constraints.</p> <p>A general form of a maximizing Linear Program can be written as follows:</p> \\[ \\operatorname*{\\mathbf{maximize}}_{\\mathbf{x}} \\ \\mathbf{g}\u1d40  \\\\ subject \\ to \\ the \\ constraints \\\\ \\mathbf{A} \u22c5 \\mathbf{x} \u2264 \\mathbf{b} \\\\ x^{min}_i &lt; x_i &lt; x^{max}_i \\] <p>\\(\\mathbf{x}\\) of length \\(n\\) is our vector of variables that we may change in our LP (as indicated by being shown below the operation \\(maximize\\)). \\(\\mathbf{g}\\) also of length \\(n\\) is our linear objective function that we want to maximize. For each element \\(x_i\\) of \\(\\mathbf{x}\\), it assigns a numeric weight. The first set of constraints restricts \\(\\mathbf{x}\\) to linear constraints given by the matrix \\(\\mathbf{A}\\) of size \\(n\u00d7m\\), where \\(m\\) is the number of single constraints. Note that, e.g. by using negative weights, we may also formulate strict equations (\\(=\\)) and greater-equal (\u2265) constraints. The second set of constraints restricts \\(\\mathbf{x}\\) to given minimal and maximal values.</p> <p>Such a linear program can now be solved using efficient algorithms such as Simplex [Paper][Wikipedia].</p>"},{"location":"lps.html#the-stoichiometric-matrix-mathbfn","title":"The stoichiometric matrix \\(\\mathbf{N}\\)","text":"<p>To use COBRA-k's optimization methods with our metabolic model, we have to convert the model and  to a mathematic form. One central form to do so it the stoichiometric matrix which we call \\(\\mathbf{N}\\):</p> <ul> <li>\\(\\mathbf{N}\\) has as many columns as metabolites in the model, and as many rows as reactions in the model. Calling the metabolite number \\(m\\) and the reaction number \\(n\\), \\(\\mathbf{N}\\) can be said of being of size \\(m \ud835\udc31 n\\).</li> <li>Each single element \\(N_{i,j}\\), i.e. any single number in the matrix in a given column \\(i\\) and row \\(j\\), represents the stoichiometry of the \\(i\\)-th metabolite in the \\(j\\)-th reaction.</li> <li>Any metabolite that is consumed in a reaction (any substrate) has a negative stoichiometry. Any metabolite that is produced in a reaction (any product) has a positive stoichiometry.</li> </ul> <p>Let's visualize this for our toy model!</p> <p></p> <p>As a table, its stoichiometries would look as follows: $$ $$</p> \\[  \\begin{array}{c|ccc} &amp; A &amp; B &amp; C &amp; D &amp; ATP \\\\ \\hline EX_A &amp; +1 &amp; 0 &amp; 0 &amp; 0 &amp; 0  \\\\ EX_C &amp; 0 &amp; 0 &amp; -1 &amp; 0 &amp; 0 \\\\ EX_D &amp; 0 &amp; 0 &amp; 0 &amp; -1 &amp; 0 \\\\ EX_{ATP} &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; -1 \\\\ Glycolysis &amp; -1 &amp; +1 &amp; 0 &amp; 0 &amp; 0 \\\\ Respiration &amp; 0 &amp; -1 &amp; +1 &amp; 0 &amp; 0 \\\\ Overflow &amp; 0 &amp; 0 &amp; -1 &amp; +1 &amp; 0 \\end{array} \\] <p>The stoichiometric matrix \\(\\mathbf{N}\\) of our toy model is therefore (just remove the column and row headings in your mind):</p> \\[ \\mathbf{N} = \\left[ \\begin{array}{ccc} +1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; -1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; -1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; -1 \\\\ -1 &amp; +1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; -1 &amp; +1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; -1 &amp; +1 &amp; 0 \\\\ \\end{array} \\right] \\] <p>You can also show a model's stoichiometric matrix using COBRA-k:</p> <pre><code>from cobrak.example_models import toy_model\nfrom cobrak.utilities import get_stoichiometric_matrix\n\nprint(get_stoichiometric_matrix(toy_model))\n</code></pre>"},{"location":"lps.html#constrained-based-modeling-cbm","title":"Constrained-based modeling (CBM)","text":"<p>Now that we have the stoichiometric matrix \\(\\mathbf{N}\\), we can construct the three major constraints of Constraint-based modeling (CBM):</p>"},{"location":"lps.html#the-steady-state-constraint","title":"The steady state constraint","text":"<p>$ \\mathbf{N} \u22c5 \\mathbf{v} = 0 $</p> <p>This very important constraint is the major assumption of all COBRA(-k) methods: That as much of any metabolite is consumed as it is produced - i.e. all metabolite concentrations remain constant.</p> <p>\\(\\mathbf{v}\\) is the reaction flux vector - it consists of variables \\(v_i\\) and has as many variables as there are reactions. In other words, it represents the flux of each reaction - and in LP methods, this is the only non-constant vector that we can modify in the optimization process.</p>"},{"location":"lps.html#minimal-and-maximal-reaction-fluxes","title":"Minimal and maximal reaction fluxes","text":"<p>$ lb_i \u2264 v_i \u2264 ub_i $</p> <p>These constraints allow us to restrict the fluxes in our flux vector \\(\\mathbf{v}\\). These bounds correspond to the <code>min_flux</code> and <code>max_flux</code> member variables of COBRA-k's dataclass <code>Reaction</code>. If \\(lb_i&gt;=0\\), then the reaction is irreversible and can only run</p> <p>Warning</p> <p>All analyses with enzymatic and/or thermodynamic constraint require all reactions to be irreversible. If you happen to have a reaction that is reversible (<code>min_flux &lt; 0</code>), you can simply split it into two irreversible reactions (a forward and a backward reaction).</p>"},{"location":"lps.html#extra-linear-flux-constraints","title":"Extra linear flux constraints","text":"<p>Optionally, you can also introduce extra linear constraints (corresponding to the <code>ExtraLinearConstraint</code> dataclass, used in <code>Model</code>) that set constrained relationships between variables, such as single fluxes:</p> \\[ \\mathbf{A} \u22c5 \\mathbf{v} \u2264 \\mathbf{b} \\] <p>\\(\\mathbf{A}\\) is a matrix that has as many columns as extra constraints and as many rows as reactions. Every element \\(A_{i,j}\\) of \\(\\mathbf{A}\\) represents a weight - a value that is multiplied with a flux - in the \\(i\\)-th extra constraint for the \\(j\\)-th reaction.</p> <p>A common example for a flux extra constraint is making the flux of two reactions identical, or setting a minimal yield for a substrate-to-product ratio.</p> <p>Note</p> <p>While, in CBM, only extra constraints between fluxes are possible, they can also be set for and between concentrations, driving fluxes and so on.</p>"},{"location":"lps.html#extra-linear-watches","title":"Extra linear watches","text":"<p>Optionally, you can also introduce extra linear watch variables (corresponding to the <code>ExtraLinearWatch</code> dataclass, used in <code>Model</code>) that add a variable with a fixed relationships to single fluxes. E.g., if you want a variable that represents the sum of the exchange reactions EX_A, EX_C and EX_P in our toy model, you could set a linear watch. Just like linear flux constraints (explained above), linear watches represent a weighted sum of other variable values Here's an example where we set a watch to the  doubled of the flux of EX_S:</p> <pre><code>from cobrak.dataclasses import ExtraLinearWatch\n\n# Let's define v_EX_P &lt;= 2 * exp(x_C)\ntoy_model.extra_linear_watches = {\n    \"two_times_EX_S\": ExtraLinearWatch(\n        stoichiometries={\n            \"EX_S\": 2.0,\n        },\n    )\n}\n</code></pre> <p>...now, we have a variable <code>two_times_EX_S</code> that is also added to results after LP (or NLP) optimizations.</p> <p>Info</p> <p>Watches are added to the model in the order given through the directory. I.e., if you would define a watch after <code>two_times_EX_S</code> in this example, this watch could use <code>two_times_EX_S</code> as a variable, too :-) Also, constraints can be defined on watches.</p>"},{"location":"lps.html#flux-balance-analysis-fba-and-pretty-printing-results-in-console","title":"Flux Balance Analysis (FBA) and pretty-printing results in console","text":"<p>An FBA [Paper][Review] - without enzymatic or thermodynamic constraints - is a linear program with the CBM constraints (from the paragraph above) and an objective where reaction flux(es) are optimized. In a general form, it looks as follows:</p> \\[ \\operatorname*{\\mathbf{max}}_{\\mathbf{v}} \\mathbf{g^\\top} \\\\ s.t. \\space CBM \\space constraints \\] <p>\\(\\mathbf{g}\\) is the objective function vector of length \\(n\\), i.e. it has as many entries as there are reactions. An entry \\(g_i\\) stands for the weight (a number) of reaction \\(i\\) in our objective function. E.g., if we want to maximize the flux of reaction \"Glycolysis\" in our toy model, we would set \\(g_{Glycolysis}\\) to \\(1\\) and all other entries in \\(\\mathbf{g}\\) to \\(0\\).</p> <p>In COBRA-k, we don't have the hassle of finding the index \\(i\\) of a reaction. E.g., a Flux Balance Analysis where we maximize the Flux of reaction Glycolysis looks as follows in code:</p> <pre><code># Load our toy model from the previous chapter, conveniently, it is shipped with COBRA-k :-)\nfrom cobrak.example_models import toy_model\n# Load the general Linear Program optimization function of COBRA-k\n# which can be found in COBRA-k's submodule 'lps'\nfrom cobrak.lps import perform_lp_optimization\n# Load some pretty-print functions (can be found in submodule 'printing')\nfrom cobrak.printing import print_dict, print_optimization_result\n\n# Maximize the flux of Glycolysis using the CBM constraints\nfba_result = perform_lp_optimization(\n    toy_model,\n    \"Glycolysis\",\n    +1,\n) # fba_result is a dict[str, float]\n\n# Pretty print result as dictionary\nprint_dict(fba_result)\n\n# Pretty print the result as (nicer-looking :-) tables\nprint_optimization_result(toy_model, fba_result)\n</code></pre> <p>First, we perform the Linear Program (or Linear Optimization) with <code>perform_lp_optimization</code> and reaction Glycolysis as objective target (for more complex objectives, see below). The <code>+1</code> stands for the third mandatory argument, the <code>objective_sense</code>, which in COBRA-k's logic is \\(&gt;0\\) if a maximization is aimed, and \\(&lt;0\\) if a minimization is aimed. Also, the objective result (in form of an objective variable, see below) is multiplied with this sense.</p> <p>Now, we got the <code>fba_result</code>, which is a <code>dict[str, float]</code>, where the keys (strings) stand for the variable names, e.g. the reaction IDs or fluxes, and the values stand for the numeric value of this variable.</p> <p>To showcase the result's nature as dictionary, we print it using <code>print_dict</code>. But, as shown in the code, there's also a nicer way to present a result as pretty colored tables using <code>print_optimization_result</code> :-)</p> <p>Finding out more about COBRA-k functions</p> <p>In our examples, we do not use all options provided by COBRA-k's functions. For example, the <code>print_optimization_result</code> function has many extra arguments for a fine-grained control of the output. To find out more about any COBRA-k function, search it using this site's search bar or in the \"API\" chapter of this documentation.</p> <p>As mentioned, there is also a special objective variable which represent's the objective's value (e.g. if <code>objective_sense=+2</code>, it would be 2 times the sum of the maximized flux of Glycolysis). You can access this objective variable's value as follows:</p> <pre><code># ...using the code from the previous snippet...\n# Load the name of the variable that holds the objective name\nfrom cobrak.constants import OBJECTIVE_VAR_NAME\n\nprint(fba_result[OBJECTIVE_VAR_NAME])\n</code></pre> <p>The most common FBA misunderstanding</p> <p>While objective values for a given FBA problem are unique, the solutions are not unique. I.e. it is possible that there are multiple or even infinite many solutions which can lead to a found objective value. To find out more about the solution space in which solutions with a given objective can lie, you may e.g. utilize Flux Variability Analyses (see next subchapter).</p> <p>If you want to set a more complex objective, say:</p> \\[ maximize \\space -1.5 \u22c5 v_{Glycolysis} + 2 \u22c5 v_{Overflow} \\] <p>i.e. -1.5 times Glycolysis's flux plus 2 time Overflow's flux, you can do this by setting the objective target as dictionary with the given weights as follows:</p> <pre><code>from cobrak.example_models import toy_model\nfrom cobrak.lps import perform_lp_optimization\nfrom cobrak.printing import print_optimization_result\n\n# Perform FBA with more complex objective\ncomplex_fba_result = perform_lp_optimization(\n    toy_model,\n    {\"Glycolysis\": -1.5, \"Overflow\": 2.0}, # No str anymore\n    +1,\n)\n\n# Pretty print more complex FBA result\nprint_optimization_result(toy_model, complex_fba_result)\n</code></pre> <p>In fact, you can freely set the objective dictionary to any combination of flux and any other kind of variables that occur in extended COBRA-k optimization problems. These variables are gradually introduced at the end of this chapter and the next chapters.</p> <p>Solvers</p> <p>By default, COBRA-k uses the open-source and pre-bundled Linear Programming solver SCIP. To use other solvers or change the SCIP settings, you can set the <code>solver</code> (and, if wished) argument of <code>perform_lp_optimization</code>. This parameter requires an instance of the COBRA-k dataclass <code>Solver</code> and is explained at the end of this chapter :-), together with a list of preconfigured solvers provided by COBRA-k.</p>"},{"location":"lps.html#parsimonious-flux-balance-analysis-pfba","title":"Parsimonious Flux Balance Analysis (pFBA)","text":"<p>As mentioned, FBA solutions do not have to be unique. One way to find a virtually unique solution is to perform a pFBA [Paper], basically a second optimization after an FBA, where we set the FBA's objective value as minimum and then perform</p> \\[ \\operatorname*{\\mathbf{min}}_{\\mathbf{v}} \\space \u2211_i v_i \\\\ s.t. \\space CBM \\space constraints \\] <p>i.e. a minimization of the flux sum. This subsequent minimization may stand for a crude proxy e.g. of enzyme costs, where we assume that the lower the flux sum of a solution is, the lower the amount of needed enzymes are (for a more realistic approximation of enzyme costs, see this chapter's last subchapter).</p> <p>In COBRA-k, we can do this using the toggle <code>with_flux_sum_var</code> in <code>perform_lp_optimization</code>, which adds a variable called <code>autocobra.constants.FLUX_SUM_VAR_ID</code> (by default, \"FLUX_SUM_VAR\") to our optimization problem. This variable represents \\(\u2211_i v_i\\) and can be used as follows following our FBA:</p> <pre><code>from cobrak.example_models import toy_model\nfrom cobrak.lps import perform_lp_optimization\nfrom cobrak.printing import print_optimization_result\nfrom autocobra.constants import FLUX_SUM_VAR_ID\n\n# We perform a pFBA on our Glycolysis optimization example\n# 1) We set the objective value as minimum\ntoy_model.reactions[\"Glycolysis\"].min_flux = fba_result[\"Glycolysis\"]\n\n# 2) Now, the flux sum minimization\npfba_result = perform_lp_optimization(\n    toy_model,\n    FLUX_SUM_VAR_ID,\n    -1,\n    with_flux_sum_var=True,\n) # Again, pfba_result is a dict[str, float]\n\n# Let's print our pFBA result\nprint_optimization_result(toy_model, pfba_result)\n\n# Reset model for the next calculations\ntoy_model.reactions[\"Glycolysis\"].min_flux = 0.0\n</code></pre>"},{"location":"lps.html#flux-variability-analysis-fva","title":"Flux Variability Analysis (FVA)","text":"<p>To find out the minimally and maximally possible fluxes of reactions, we can perform an FVA [Paper]. For any reaction \\(i\\), it performs the following optimization:</p> \\[ \\operatorname*{\\mathbf{min}}_{\\mathbf{v}} \\space v_i \\\\ s.t. \\space CBM \\space constraints \\] <p>and $$ \\operatorname*{\\mathbf{max}}_{\\mathbf{v}} \\space v_i \\ s.t. \\space CBM \\space constraints $$</p> <p>so that we get the wished minimal and maximal flux of a reaction.</p> <p>Warning</p> <p>This does not mean that every combination between minimal and maximal fluxes of multiple reactions are possible. We just know the minimal and maximal flux for any single reaction.</p> <p>In COBRA-k, we can perform an FVA for our toy model as follows:</p> <pre><code>from cobrak.example_models import toy_model\nfrom cobrak.lps import perform_lp_variability_analysis\nfrom cobrak.printing import print_variability_result\n\n# Perform general FVA (we did not set the previous objective value as minimum)\nvar_result = perform_lp_variability_analysis(\n    toy_model\n)\n\n# Pretty print result as tables\nprint_variability_result(toy_model, var_result)\n</code></pre> <p>In COBRA-k, the type of variability results is <code>dict[str, tuple[float, float]]</code>. I.e. the variable names are the keys, and the values are tuples whose first entry is the minimal and the second entry is the maximal entry. E.g. if we want to print the minimal value of reaction Overflow, we ran</p> <pre><code># ...using the code snippet from above...\nprint(var_result[\"Overflow\"][0])\n</code></pre> <p>Parallelization</p> <p>COBRA-k uses joblib [GitHub] to parallelize any variability analysis. This means that as many CPU cores are used as there are on your computer, greatly speeding up the process.</p>"},{"location":"lps.html#analyses-with-enzyme-constraints-ecfba-ecfva","title":"Analyses with Enzyme Constraints: ecFBA &amp; ecFVA","text":"<p>Up to now, we only used stoichiometric constraints. I.e. we looked for solutions which fulfilled the CBM constraints such as the steady-state, all which depend on reaction fluxes (\\(\\mathbf{v}\\)) and the stoichiometries of metabolites in reactions (\\(\\mathbf{N}\\)).</p> <p>Now, we introduce \"classic\" linear enzyme constraints as already described by methods such as MOMENT [Paper], GECKO [Paper] or sMOMENT [Paper]. They are all based on the observation that the fraction of metabolically active enzymes on a cell's biomass is restricted. I.e. only a maximal percentage of a cell's biomass can be metabolically active enzymes, as the rest is occupied by non-metabolic enzymes, lipids, DNA, RNA etc..</p> <p>We call the maximal metabolic enzyme fraction enzyme pool \\(\u03a9\\) with the unit g\u22c5gDW\u207b\u00b9, i.e. grams per gram dry weight. E.g. if \\(\u03a9=0.5\\) g\u22c5gDW\u207b\u00b9, then a maximum of 0.5 grams of a gram dry weight can be used by metabolic enzymes.</p> <p>Furthermore, from Michaelis-Menten kinetics, we know that the maximal possible flux of a reaction is its $ k_{cat}^+$ times its enzyme concentration \\(E_i\\).</p> <p>Thus, we may formulate linear enzyme constraints as follows:</p> <ul> <li>We introduce enzyme concentration variables \\(E_i\\) and optional constraints for minimal and maximal enzyme concentrations (also, \\(E^{min}_i\u22650\\)):</li> </ul> \\[ E^{min}_i \u2264 E_i \u2264 E^{max}_i \\] <ul> <li>We  add the maximal flux constraint:</li> </ul> \\[ v_i \u2264 E_i \u22c5 k_{cat}^+ \\] <ul> <li>We add the enzyme pool constraint:</li> </ul> \\[ \u2211_i W_i \u22c5 E_i \u2264 \u03a9 \\] <p>Note</p> <p>A alternative formulation is also available which introduces new pseudo-metabolites and pseudo-reactions, as done in GECKO and sMOMENT. This formulation can optionally be used when exporting a COBRA-k model as annotated SBML and setting the <code>add_enzyme_constraints</code> parameter of <code>save_cobrak_model_as_annotated_sbml_model</code> to <code>True</code>.</p> <p>Look again in chapter \"Create Model from Scratch\" to see where we defined the \\(k_{cat}\\), \\(W\\) and \\(\u03a9\\) values in our toy model. When we do not want a <code>Reaction</code> instance to be affected by enzyme constraints, we simply set its <code>enzyme_reaction_data</code> value to <code>None</code>.</p> <p>Info</p> <p>In COBRA-k, we make the simplifying assumption that there is a single enzyme (complex) for each single reaction. I.e. even if an enzyme catalyzes multiple reactions (isozyme), this enzyme is copied for each single reaction. To introduce concentration constraints for such isozymes, you may utilize <code>ExtraLinearConstraint</code> instances in the model's <code>extra_linear_constraint</code>.</p> <p>Now, to perform an enzyme-constrained FBA - an ecFBA - i.e.</p> \\[ \\operatorname*{\\mathbf{max}}_{\\mathbf{v}, \\mathbf{E}} \\mathbf{g^\\top} \\\\ s.t. \\space CBM \\space and \\space enzyme \\space constraints \\] <p>we simply set the associated argument <code>with_enzyme_constraints</code> in <code>perform_lp_optimization</code> to <code>True</code>, e.g.</p> <pre><code>from cobrak.example_models import toy_model\nfrom cobrak.lps import perform_lp_optimization\nfrom cobrak.printing import print_optimization_result\n\n# Perform ecFBA\necfba_result = perform_lp_optimization(\n    toy_model,\n    {\"Glycolysis\": +1.0}, # No str anymore\n    +1,\n    with_enzyme_constraints=True, # Activate linear enzyme constraints\n)\n\n# Pretty-print result, now also with actual enzyme usage :-)\nprint_optimization_result(toy_model, ecfba_result)\n</code></pre> <p>Similarly, we can run an ecFVA - i.e.</p> \\[ \\operatorname*{\\mathbf{min}}_{\\mathbf{v,E}} \\space v_i \\\\ s.t. \\space CBM \\space and \\space enzyme \\space constraints \\] <p>and $$ \\operatorname*{\\mathbf{max}}_{\\mathbf{v,E}} \\space v_i \\ s.t. \\space CBM \\space and \\space enzyme \\space  constraints $$</p> <p>as follows:</p> <pre><code># Perform general ecFVA\nvar_result = perform_lp_variability_analysis(\n    toy_model\n)\n\n# Pretty print result as tables - again, now with enzyme usages :-)\nprint_variability_result(toy_model, var_result)\n</code></pre> <p>Enzyme constraint variables</p> <p>In any COBRA-k results, you can identify enzyme concentration variables as follows:</p> <p>They start with <code>autocobra.constants.ENZYME_VAR_PREFIX</code> (default is <code>\"enzyme_\"</code>), followed by the enzyme's ID, followed by <code>autocobra.constants.ENZYME_VAR_INFIX</code> (default is <code>\"_of__\"</code>), followed by the reaction's ID (remember that we give each reaction its own enzyme in COBRA-k). E.g., if a reaction \"R1\" has the enzyme \"E1\", its concentration variable would be called by default <code>\"enzyme_E1_of_R1\"</code>.</p> <p>To find out a reaction's enzyme concentration name, you can also use the following utility function, e.g.:</p> <pre><code>from cobrak.example_models import toy_model\nfrom cobrak.utilities import get_reaction_enzyme_var_id\n\nenzyme_name_of_glycolysis = get_reaction_enzyme_var_id(\"Glycolysis\", toy_model.reactions[\"Glycolysis\"])\nprint(enzyme_name_of_glycolysis)\n</code></pre>"},{"location":"lps.html#pretty-printing-optimization-andor-variability-results-as-an-xlsx-spreadsheet","title":"Pretty-printing optimization and/or variability results as an XLSX spreadsheet","text":"<p>Up to now, we just pretty-printed optimization (e.g. (ec)FBA) and variability (e.g. (ec)FVA) results in the console. But you can also export these results as a pretty-printed XLSX spreadsheet :-) This spreadsheet has different sheets for e.g. reaction data (e.g. their IDs and fluxes), metabolite data (useful with thermodynamic constraints, see MILP chapter), enzyme data (including complexes, i.e. the enzymes associated with a single reactions and the single enzymes with their given concentration ranges) and more. Results are colored and sorted alphabetically.</p> <p>Each spreadsheet can contain multiple optimization and/or variability results. To create such an XLSX , we can use the associated methods in COBRA-k's module <code>spreadsheet_functionality</code> and its associated dataclasses <code>OptimizationData</code> and <code>VariabilityData</code> as follows:</p> <pre><code>from cobrak.example_models import toy_model\nfrom cobrak.lps import perform_lp_optimization, perform_lp_variability_analysis\nfrom cobrak.spreadsheet_functionality import (\n    OptimizationDataset, # Here, we set the optimization result and its wished shown data\n    VariabilityDataset, # Here, we set the variability result and its wished shown data\n    create_cobrak_spreadsheet, # The function to generate the XLSX\n)\n\n# We're going to create an XLSX with the following three results:\n# 1. General FVA\nvar_result = perform_lp_variability_analysis(\n    toy_model\n)\n# 2. ATP optimization\nmax_atp_result = perform_lp_optimization(\n    toy_model,\n    \"ATP_Consumption\",\n    +1,\n)\n# 2. Overflow optimization\nmax_overflow_result = perform_lp_optimization(\n    toy_model,\n    \"Overflow\",\n    +1,\n)\n\n# Now let's wrap the variability result into a\n# create_cobrak_spreadsheet()-compatible format \ud83c\udf81\n# The keys are the dataset titles in the spreadsheet\nvariability_datasets: dict[str, VariabilityDataset] = {\n    \"FVA result\": VariabilityDataset(\n        data=var_result, # Obligatory argument\n        with_df=False, # Optional, default False; Do we show driving forces (see MILP chapter)?\n    )\n } # This is a list as we could add multiple variability results\n\n# Now let's wrap the optimization results into a\n# create_cobrak_spreadsheet()-compatible format \ud83c\udf81\n# The keys are the dataset titles in the spreadsheet\noptimization_datasets: dict[str, OptimizationDataset] = {\n    \"Max ATP\": OptimizationDataset(\n        data=max_atp_result, # Obligatory argument\n        with_df=False, # Optional, default False; Do we show driving forces (see MILP chapter)?\n        with_vplus=False, # Optional, default False; Do we show V+ (see enzyme constraints)?\n        with_kappa=False, # Optional, default False; Do we show kappa values (see NLP chapter)?\n        with_gamma=False, # Optional, default False; Do we show gamma values (see NLP chapter)?\n        with_kinetic_differences=False, # Optional, default False; Do we show NLP approximation differences (see corrections chapter)?\n        with_error_corrections=False,  # Optional, default False; Do we show corrections (see corrections chapter)?\n    ),\n    \"Max Overflow\": OptimizationDataset(\n        data=max_overflow_result,\n    ),\n}\n\n# Create XLSX spreadsheet (for this example, to not pollute your\n# file system, as temporary file)\nimport tempfile\nfrom cobrak.io import json_write\nwith tempfile.NamedTemporaryFile(suffix='.xlsx', delete=False) as temp:\n    json_write(temp.name, fba_result)\n    create_cobrak_spreadsheet(\n        temp.name,\n        toy_model,\n        variability_datasets,\n        optimization_datasets,\n    )\n    print(f\"Spreadsheet created! You can now load it in your favorite spreadsheet viewer at {temp.name}\")\n</code></pre>"},{"location":"lps.html#exportimport-optimization-or-variability-result-as-json-file","title":"Export/Import optimization or variability result as JSON file","text":"<p>Instead of the shown pretty-printing options, you can also save and load COBRA-k optimization and variability results in the form of a human- and machine-readable JSON [Wikipedia] file. The respective functionality can be found in COBRA-k's <code>io</code> submodule, whereby all associated functions start with <code>json</code>. Let's run an ecFBA and store its result as JSON (here, in a temporary file) and then load it again:</p> <pre><code>from cobrak.example_models import toy_model\nfrom cobrak.lps import perform_lp_optimization\nfrom cobrak.io import json_load, json_write\n\n# Perform FBA\nfba_result = perform_lp_optimization(\n    toy_model,\n    {\"Glycolysis\": +1.0},\n    +1,\n)\n\n# Store FBA result as JSON (for this example, to not pollute your\n# file system, as temporary file)\nimport tempfile\nfrom cobrak.io import json_write\nwith tempfile.NamedTemporaryFile(suffix='.json') as temp:\n    json_write(temp.name, fba_result)\n\n    # Load the FBA result again\n    loaded_fba_result = json_load(temp.name)\n\n    # Print one flux value of the FBA result\n    print(loaded_fba_result[\"Glycolysis\"])\n</code></pre> <p>Pydantic dataclass validation</p> <p>COBRA-k also offers pydantic [Site][GitHub] dataclass validations that throw a <code>ValidationError</code> whenever a dataclass member variable is missing or of the wrong type (e.g. a <code>str</code> instead of a <code>float</code>) or of the wrong range (e.g. a negative number instead of a non-negative number).</p> <p>This validation occurs in the following two cases:</p> <ol> <li>You create a new instance of the dataclass</li> <li>You use the optional <code>dataclass_type</code> argument of <code>json_load</code> and provide the dataclass that you expect to be loaded from the given path. E.g., in our example above, we would load the result <code>loaded_ecfba_result</code> of the type <code>dict[str, float]</code>, or in our code snippet above:</li> </ol> <pre><code># For the validation of variability results, use the type dict[str, tuple[float, float]]\nloaded_fba_result = json_load(temp.name, dataclass_type=dict[str, float])\n</code></pre> <p>COBRA-k also provides type aliases for results, whereby OptimizationResult=dict[str, float] and VariabilityResult=dict[str, tuple[float, float]].</p>"},{"location":"lps.html#export-optimization-or-variability-result-as-cnapy-scenario","title":"Export optimization or variability result as CNApy scenario","text":"<p>In addition to storing an optimization optimization (e.g. FBA) or variability (e.g. FVA) result as an XLSX spreadsheet or JSON file, you can also export a result as a CNApy [GitHub][Paper] scenario file. Such files can be loaded by CNApy and directly displayed in an interactive CNApy map. To export an optimization or variability result, we can use the respective functions in the <code>utilities</code> package:</p> <pre><code>from cobrak.example_models import toy_model\nfrom cobrak.lps import perform_lp_optimization\nfrom cobrak.utilities import create_cnapy_scenario_out_of_optimization_dict\n\n# Perform FBA\nfba_result = perform_lp_optimization(\n    toy_model,\n    {\"Glycolysis\": +1.0},\n    +1,\n)\n\n# Store ecFBA result as CNApy scenario (for this example, to not pollute your\n# file system, as temporary file)\nimport tempfile\nwith tempfile.NamedTemporaryFile(suffix=\".scen\", delete=False) as temp:\n    create_cnapy_scenario_out_of_optimization_dict(\n        path=temp.name,\n        cobrak_model=toy_model,\n        optimization_dict=fba_result,\n    )\n\n    # Print one flux value of the ecFBA result\n    print(\"The .scen file is in:\", temp.name, \"and can now be loaded in CNApy\")\n    print(\"Use the CNApy default model 'cobrak_toymodel.cna' for a succesful visualization of the result\")\n</code></pre> <p>For variability results, we can use the function <code>create_cnapy_scenario_out_of_variability_dict</code> which just takes a different input but also exports a .scen file.</p> <p>CNApy map compatibility</p> <p>Usually, CNApy maps are made for models where the forward and reverse direction of a single reaction are not separated. Using the <code>fwd_suffix</code> and <code>rev_suffix</code> of the Model dataclass (see above), COBRA-k automatically converts its optimization (or variability) result back into a model where forward and reverse directions.</p> <p>If you do not wish the behaviour, set the optional \"desplit_reactions\" argument in <code>create_cnapy_scenario_out_of_optimization_dict</code> to <code>False</code>.</p>"},{"location":"lps.html#changing-and-setting-solvers-with-the-dataclass-solver","title":"Changing and setting solvers with the dataclass Solver","text":"<p>Up to now, we just used COBRA-k's default solver SCIP [Website]. However, you can set your own solver using the dataclass Solver. E.g., if we wanted to use the local (and also open-source) solver IPOPT and make it possible to run for a large amount of internal optimization steps, we would define a Solver instance as follows: olver. E.g., if we wanted to use the local (and also open-source) solver IPOPT an <pre><code>from cobrak.example_models import toy_model\nfrom cobrak.lps import perform_lp_optimization\nfrom cobrak.dataclasses import Solver\n\nipopt = Solver(\n    name=\"ipopt\", # This must be the same name as given in pyomo\n    solver_options={ # Options for the called solver itself\n        \"max_iter\": 100_000,\n        # Note that these options are solver-specific, i.e. they\n        # typically won't work for other solvers\n    },\n    solver_attrs={\n        # These would be attributes to the pyomo solver object itself\n        # e.g., for the solver SCIP, we may set\n        # \"_version_timeout\": 180 to prevent a fast timeout of pyomo's\n        # SCIP call\n    },\n    solve_extra_options={\n        # These would be extra argument's to pyomo's solve function\n        # Consult pyomo's documentation on the possible arguments\n    },\n)\n\nprint(\"Now we solve with the solver IPOPT :D\")\nperform_lp_optimization(\n    toy_model,\n    \"ATP_Consumption\",\n    +1,\n    solver=ipopt,\n    verbose=True, # Show explicitly the IPOPT output :-)\n)\n</code></pre></p> <p>All solvers supported by the optimziation framework pyomo [GitHub] are supported by COBRA-k, too. Please refer to pyomo's documentation for possible solver object and solve function attributes, as well as the list of supported solvers and their names in pyomo code. For the solver-specific options, please consult the solver's own documentation.</p>"},{"location":"milps.html","title":"Mixed-integer linear programs","text":"Quickstart code <pre><code>#% Thermodynamic Flux Balance Analysis\nfrom cobrak.example_models import toy_model\nfrom cobrak.lps import perform_lp_optimization\nfrom cobrak.printing import print_dict, print_optimization_result\n\n# Perform TFBA\ntfba_result = perform_lp_optimization(\n    cobrak_model=toy_model,\n    objective_target=\"ATP_Consumption\",\n    objective_sense=+1,\n    with_thermodynamic_constraints=True,\n)\n\n# Pretty print result as dictionary\nprint_dict(tfba_result)\n\n# Pretty print result as tables\nprint_optimization_result(toy_model, tfba_result)\n\n\n#% OptMDFpathway\nfrom cobrak.constants import MDF_VAR_ID\n\n# Perform OptMDFpathway\noptmdfpathway_result = perform_lp_optimization(\n    cobrak_model=toy_model,\n    objective_target=MDF_VAR_ID,\n    objective_sense=+1,\n    with_thermodynamic_constraints=True,\n)\n\n# Print MDF only\nprint(optmdfpathway_result[MDF_VAR_ID])\n\n\n#% Thermodynamic Bottleneck Analysis\nfrom cobrak.lps import perform_lp_thermodynamic_bottleneck_analysis\n\n# Use model with extreme standard Gibbs free energy and enforced ATP production\nwith toy_model as tba_model:\n    tba_model.reactions[\"Glycolysis\"].dG0 = 100 # A bottleneck :O\n\n    # Perform TBA\n    list_of_bottleneck_reactions, _ = perform_lp_thermodynamic_bottleneck_analysis(\n        tba_model,\n    ) # The second returned value is the full solution (with fluxes, concentrations, ...) which we don't need here\n\n# Print list of thermodynamic bottlenecks\nprint(list_of_bottleneck_reactions)\n\n\n#% Thermodynamic Variability Analysis\nfrom cobrak.example_models import toy_model\nfrom cobrak.lps import perform_lp_variability_analysis\nfrom cobrak.printing import print_variability_result\n\n# Perform TFVA\nvariability_dict = perform_lp_variability_analysis(\n    toy_model,\n    with_thermodynamic_constraints=True,\n)\n\n# Pretty print result as tables\nprint_variability_result(toy_model, variability_dict)\n\n\n#% Perform enzyme-constrained TFBA\n# Run ecTFBA\nectfba_result = perform_lp_optimization(\n    cobrak_model=toy_model,\n    objective_target=\"ATP_Consumption\",\n    objective_sense=+1,\n    with_thermodynamic_constraints=True,\n    with_enzyme_constraints=True,\n)\n\n# Pretty print result as dictionary\nprint_dict(ectfba_result)\n\n# Pretty print result as tables,\n# now with enzyme concentrations *and* metabolite concentrations\nprint_optimization_result(toy_model, ectfba_result)\n</code></pre>"},{"location":"milps.html#introduction","title":"Introduction","text":""},{"location":"milps.html#milps","title":"MILPs","text":"<p>We used plain Linear Programming in the last chapter, where every variable is rational (which includes not only whole numbers (such as \\(2\\)) but also fractions (such as \\(7.31\\))). Now, we use concepts based on Mixed-Integer Linear Programming (MILP), where a user-selected set of binary variables which can be either 0 or 1, nothing in-between.</p> <p>MILPs are much more difficult to solve than LPs. While the latter may contain hundreds of thousands of parameters and still be quickly solved, MILPs are restricted, at very best, to a few thousand parameters. Fortunately, that's still good enough for large genome-scale metabolic models.</p> Excursion: MILPs <p>Based on our definitions from the previous chapter, a general form of a maximizing MILP is:</p> \\[ \\operatorname*{\\mathbf{maximize}}_{\\mathbf{x}} \\ \\mathbf{g}\u1d40  \\\\ subject \\ to \\ the \\ constraints \\\\ \\mathbf{A} \u22c5 \\mathbf{x} \u2264 \\mathbf{b} \\\\ x^{min}_i &lt; x_i &lt; x^{max}_i \\\\ x_j \u2208 \\{0,1 \\} \u2200 j\u22081...i^{max} \\] <p>where j stands for all indices (out of all variables indices indicated by i) whose variable is restricted to the value 0 and 1.</p> <p>Major algorithms for the solution of the selection of binary variables in MILPs are branch-and-bound [Paper][Wikipedia] and the cutting-plane method [Paper][Wikipadia] as well as their combination branch-and-cut [Paper][Wikipedia].</p>"},{"location":"milps.html#thermodynamic-measures","title":"Thermodynamic measures","text":"<p>Binary variables allow us to introduce thermodynamic constraints in our constraint-based model. Thermodynamic constraints make sure that our solution is thermodynamically feasible. This means that the concentration(s) of any active reaction's substrate are somehow high enough in comparison to the reaction's products. In exact form, whether this neccessary substrate(s)-to-product(s) concentration ratio is reached can be deduced with the driving force \\(f_i\\) (side note: this is the negative Gibbs energy \\(\u0394_r G^{\u00b4}\\) [Wikipedia]) with the unit kJ\u22c5mol\u207b\u00b9. \\(f_i\\) is for a reaction \\(i\\):</p> \\[ f_i = -\u0394_r G^{\u00b4\u00b0}_i + R \u22c5 T \u22c5 Q_i \\] <p>R stands for the Gas constant in kJ\u22c5K\u207b\u00b9\u22c5mol\u207b\u00b9 [Wikipedia] and T for the temperature in K; \\(Q_i\\) is explained further below.</p> <p>\\(\u0394_r G^{\u00b4\u00b0}_i\\) (with the \u00b0 at the end) is the physiologic standard Gibbs energy. Just like \\(f_i\\), it has the unit kJ\u22c5mol\u207b\u00b9 and stands for the amount of energy (in kJ) that is used when the reaction converts 1 mole of substrates into 1 mole of products, whereby all substrates and products have a concentration of 1 M=1 mol\u22c5l\u207b\u00b9. Furthermore, to account for physiological effects, the reaction compartment's pH, pMg and ionic strength are accounted for in the complicated calculations for the determination of a \\(\u0394_r G^{\u00b4\u00b0}_i\\). This becomes even more complicated for multi-compartmental reactions. For more details, look at this fantastic paper from the authors of the fantastic eQuilibrator-API [here] and the excellent eQuilibrator FAQ [here]. This (COBRA-k-unaffiliated) API is also used by COBRA-k's functionality to retrieve \\(\u0394_r G^{\u00b4\u00b0}_i\\) of reactions, as detailed in chapter 10.</p> <p>The main value of the standard Gibbs energy is its following meaning:</p> <ul> <li> <p>If \\(\u0394_r G^{\u00b4\u00b0}_i &lt; 0\\), it means that energy is released when all substrates and products have the standard concentration of 1 M. As every working reaction needs energy to be released, this means that under standard concentrations, the reaction would be thermodynamically feasible. In other works, it could run.</p> </li> <li> <p>If \\(\u0394_r G^{\u00b4\u00b0}_i \u2265 0\\), no energy is released at standard concentrations. This would mean that with the given standard concentrations, the reaction would be thermodynamically infeasible, it could not run.</p> </li> </ul> <p>Warning</p> <p>The driving force \\(f_i\\) uses the negated sign logic as it negates the Gibbs energy. Also, as explained below with the factor \\(Q_i\\), \\(f_i\\) can be used for any metabolite concentrations, not only 1 M.</p> <p>\\(f_i\\) means the following:</p> <ul> <li> <p>The higher the \\(f_i\\), the more energy is released by a reaction.</p> </li> <li> <p>The lower the \\(f_i\\), the less energy is released by a reaction.</p> </li> </ul> <p>\u21d2 if \\(f_i&gt;0\\), a reaction is thermodynamically feasible; if \\(f_i\u22640\\), a reaction is thermodynamically infeasible</p> <p>\\(Q_i\\) is the appropriately formulated thermodynamic logarithmic concentration ratio between substrates and products:</p> \\[ Q_i = \u2211_{j}( -N_{i,j} \u22c5 ln(c_j) )\\] <p>\\(ln\\) is the natural logarithm, \\(c_j\\) the concentration of metabolite \\(j\\) and \\(N_{i,j}\\) is its stoichiometry (negative for substrates, positive for products) in the stoichiometric matrix \\(\\mathbf{N}\\). The influence of substrate and product concentrations on \\(Q_i\\), and therefore \\(f_i\\), is as follows:</p> <ul> <li> <p>Through the stoichiometry-negating factor \\(-N_{i,j}\\), \\(Q_i\\) is defined such that is becomes lower the higher the substrate concentration(s) are. In other words, the driving force \\(f_i\\) of a reaction becomes \"better\" (it goes in the direction of thermodynamic feasibility, i.e. higher) the higher the the substrate concentration(s) are.</p> </li> <li> <p>In contrast, \\(Q_i\\) becomes higher the higher the product concentration(s) are, bringing the reactions more towards an infeasible state as the \\(f_i\\) also becomes lower.</p> </li> </ul> A toy reaction example <p>To illustrate the (often complicated looking) measures introduced in the previous paragraphs, let's look at a simple reaction called X:</p> <p>$ A \u2192 2 B $</p> <p>Lets say that this reaction's standard Gibbs energy \\(\u0394_r G^{\u00b4\u00b0}_{X}\\) is -1 kJ\u22c5mol\u207b\u00b9 A's concentration (\\(c_A\\)) is 0.2 M, and $c_B\u00a7 is 0.1 M.</p> <p>Then, the driving force \\(f\\) of reaction X is:</p> <p>$ f_{X} = \u0394_r G^{\u00b4\u00b0} + -N_{X,A} \u22c5 ln(c_A) + -N_{X,B} \u22c5 ln(c_B) $</p> <p>$ = -1 + -1 \u22c5 ln(0.2) + -(-2) \u22c5 ln(0.1) \u2248 -3.996 kJ\u22c5mol\u207b\u00b9 $</p> <p>\\(f_X&lt;0\\), this, the reaction is thermodynamically feasible, it can run!</p>"},{"location":"milps.html#thermodynamic-constraints","title":"Thermodynamic constraints","text":"<p>Aim: Using the thermodynamic measured introduced above, we can now integrate thermodynamic constraints into constraint-based modeling (CBM). More precisely, we want that the driving force \\(f_i\\) of any active reaction is positive. In other words, whenever the flux of a reaction is greater than zero (\\(v_i&gt;0\\)), \\(f_i&gt;0\\) holds. As a first step to do so, we add metabolite concentrations for any metabolite \\(j\\):</p> \\[ \\ln (c_j^{min} ) \u2264 x\u0303_j \u2264 \\ln ( c_j^{max} ) \\] <p>\\(c_j^{min}\\) is the minimal metabolite concentration in M, \\(c_j^{max}\\) the respective maximal concentration in M. \\(x\u0303_j\\), an element of the vector \\(\\mathbf{x\u0303}\\), stands for a variable that holds the logaritmic concentration of metabolite \\(j\\).</p> <p>How to set concentration ranges</p> <p>Typical standard minimal and maximal concentrations are 10\u207b\u2076 M up to 0.02 M for intracellular metabolites, with higher maximal concentrations for extracellular metabolites. The concentrations for water (\\(H_2 O\\)) and protons (\\(H^+\\)) are often set to 0 M (i.e. their logarithm is 1). This is because both water (with a fixed \"active\" concentration) and proton (as pH) concentrations are integrated in the calculation of the physiologic standard Gibbs energy \\(\u0394_r G^{\u00b4\u00b0}\\). For more details of how e.g. the fantastic eQuilibrator does this, read their FAQ here.</p> <p>Now, we can formulate the driving forces \\(f_i\\) - for any reaction \\(i\\) for which we want thermodynamic constraints - as follows:</p> \\[ f_i = -(\u0394_r G^{\u00b4\u00b0}_i + R \u22c5 T \u22c5 \\mathbf{N_{\u22c5,i}} \u22c5 \\mathbf{x\u0303}) \\] <p>Again, \\(\u0394_r G^{\u00b4\u00b0}_i\\) is the reaction's standard Gibbs energy, R the gas constant, T the temperature. The term \\(\\mathbf{N_{\u22c5,i}} \u22c5 \\mathbf{x\u0303}\\) is equivalent to the formulation of \\(Q_i\\) above and means the following: We take the stoichiometries of all (\u22c5) metabolites in reaction i through \\(\\mathbf{N_{\u22c5,i}}\\), i.e. we take the \\(i\\)-th row of the stoichiometric matrix \\(\\mathbf{N}\\). Then, we multiply these stoichiometries with the logarithmic concentration vector \\(\\mathbf{x\u0303}\\). This effectively gives us - as for \\(Q_i\\) - the sum of stoichiometries multiplied with the logarithmic concentrations.</p> <p>While we now have the driving force, we did not enforce it yet to be positive (i.e. to indicate feasiblity). For this, we also introduce a controlling binary variable vector \\(\\mathbf{z}\\) which holds a binary value for any reaction \\(i\\) with thermodynamic constraints:</p> \\[ z_i \u2208 \\{0,1 \\} \\] <p>Any \\(z_i\\) must be 1 if a reaction wants to run through the constraint:</p> \\[ v_i \u2264 ub_i \u22c5 z_i \\] <p>Also, any \\(z_i\\) must be 0 (thus making a reaction not run) if \\(f_i \u2264 0\\):</p> \\[ B \u2264 f_i + M \u22c5 ( 1-z_i ) \\] <p>Thereby, \\(B\\) is a variable that stands for a set minimal driving force that has to be reached by any active reaction:</p> \\[ B \u2265 f^{min} \\] <p>The constant \\(f^{min}&gt;0\\) is the lower bound for \\(B\\). \\(f^{min}&gt;0\\) must hold if we want to ensure thermodynamic feasibility.</p> <p>And that's it! Through the two constraints utilizing \\(z_i\\), we ensure that any thermodynamically infeasible reaction is inactive (its flux is 0), while any thermodynamically feasible reaction may be active.</p> <p>Note</p> <p>Through our formulation over all reactions, we ensure the network-wide thermodynamic feasiblity of any solution with thermodynamic constraints as long as we set \\(f^{min}&gt;0\\).</p>"},{"location":"milps.html#optional-concentration-sum-constraints","title":"Optional concentration sum constraints","text":"<p>COBRA-k also provides the possibility to introduce concentration sum constraints. They are only activated if a Model's <code>max_conc_sum</code> member variable is smaller than the default value <code>float(\"inf\")</code>. In exact form, the concentration constraint would be</p> \\[ \u03a6 \u2264 \\sum{e^(x\u0303_j)} \\] <p>whereby \\(\u03a6\\) stands for the maximal concentration sum we set, and \\(e^(x\u0303_j)\\) for a exponentiated logarithmic concentration. As \\(e^(x\u0303_j)\\) is non-linear, we cannot use them directly in our MILP. Hence, we need a linearized approximation (whereby we use most of the formulation from [this preprint]).</p> <p>This works as, luckily, the exponential function is monotonically rising :D This means that we can always draw a \"minimum\" linear constraint underneath the exponential function's curve without cutting this curve. Even more lucky, we have to set \\(x\u0303_j\\) concentration bounds anyway for thermodynamic constraints (see above), so that we know for which range of logarithmic concentrations we apply the exponential function. I.e. we know the possible minimal and maximal logarithmic concentration and only have to approximate the exponential function for these values.</p> <p>Now, mathematically, the exponential function's linear approximation is built as follows:</p> <ul> <li> <p>For each metabolite \\(j\\), we first look at its possible minimal and maximal logarithmic concentration. Then, we segment this interval into \\(\u03be\\) many values creating the value vector \\(\\mathbf{S}\\) (we will clarify how large \\(X\\) should be, i.e. how many segments are needed). I.e., we get X many equally distant values \\(\\mathbf{S}\\) from (and including) the minimal and maximal logarithmic concentration of \\(j\\).</p> </li> <li> <p>For each segment value, we approximate its delogarithmic concentration \\(C_j\\), i.e. \\(e^(x\u0303_j)\\) a linear constraint of the following form (for a visualization see [Fig. 5 in this preprint]):</p> </li> </ul> \\[C_j \u2265 a_{s,j} \u22c5 x\u0303_j + b_{s,j}\\] <p>\\(s\\) is the linear approximation segment index in \\([1,S]\\). \\(a_{s,j}\\) is the slope of the exponential function at the segment's value. \\(b_{s,j}\\) is the necessary correction such that \\(a_{s,j} \u22c5 x\u0303_j + b_{s,j} = e^(x\u0303_j)\\). It is defined as:</p> <p>\\(e^(x\u0303_j) - e^(x\u0303_j) * S_s\\)</p> <p>where \\(S_s\\) is the segment \\(s\\)'s value.</p> <ul> <li> <p>We still didn't clarify how many segments are needed, i.e. how large \\(\u03be\\) has to be. To determine \\(\u03be\\), we use the following algorithm:</p> </li> <li> <p>We start with just \\(\u03be=2\\), i.e. two segments</p> </li> <li>For the current number of \\(\u03be\\), and define its two linear approximations as described above.</li> <li>Then, for each segment value \\(S_s \\space \u2200 \\space s&lt;\u03be\\), we calculate the Y intersect of the linear approximation function at \\(S_s\\) and \\(S_{s+1}\\). I.e., this is the X value where this linear approximation and the linear approximation of the following segment have the same Y value. We do this because, due to the monotonically rising nature of the exponential function, this intersect is the point with the largest possible approximation error (again, for a visualization see [Fig. 5 in this preprint]).</li> <li> <p>We now calculate the relative difference between the exponential function and the linear approximation at this Y intersect. If this relative difference is larger than the set <code>conc_sum_max_rel_error</code> (default: <code>0.05</code>), we increase \\(\u03be\\) by 1 and start again with step 2 of this algorithm. Otherwise, we have a linear approximation within our set maximal relative error and can stop the algorithm :D</p> </li> <li> <p>Finally, we can constrain our sum of the approximation of delogarithmic concentrations as follows:</p> </li> </ul> \\[ \u03a6 \u2264 \\sum{C_j} \\] <p>Warning</p> <p>For numeric reasons, linear approximations at very low concentrations may cause numeric problems :-( To mitigate this, we can set <code>conc_sum_min_abs_error</code> (default: <code>1e-6</code>) in our Model instance, which sets a minimal value for \\(\u03a6\\) and removing all linear constraints for any logarithmic concentration where \\(e^(x\u0303_j)\\) is smaller than <code>conc_sum_min_abs_error</code>.</p>"},{"location":"milps.html#thermodynamic-flux-balance-analysis-tfba","title":"Thermodynamic Flux Balance Analysis (TFBA)","text":"<p>TFBA combines Flux Balance Analysis (FBA) with thermodynamic constraints to ensure that the predicted flux distribution is both stoichiometrically and thermodynamically feasible [Paper]. The resulting optimization problem is (also using the FBA definitions from the previous chapter):</p> \\[ \\operatorname*{\\mathbf{min}}_{\\mathbf{v}, \\mathbf{E}, \\mathbf{x\u0303}, \\mathbf{f}, B}  \\mathbf{g^\\top} \\\\ s.t. \\space CBM \\space \\&amp; \\space thermodynamic \\space constraints \\] <p>In COBRA-k, we can run a TFBA as follows utilizing the toggle <code>with_thermodynamic_constraints</code>:</p> <pre><code>from cobrak.example_models import toy_model\nfrom cobrak.lps import perform_lp_optimization\nfrom cobrak.printing import print_dict, print_optimization_result\n\n# Perform TFBA\ntfba_result = perform_lp_optimization(\n    cobrak_model=toy_model,\n    objective_target=\"ATP_Consumption\",\n    objective_sense=+1,\n    with_thermodynamic_constraints=True,\n)\n\n# Pretty print result as dictionary\nprint_dict(tfba_result)\n\n# Pretty print result as tables\nprint_optimization_result(toy_model, tfba_result)\n</code></pre> <p>Note that the printed results now also show reaction driving forces and metabolite concentrations in a solution.</p> <p>Info</p> <p>In COBRA-k result dictionaries, logarithmic metabolite concentration variables start with <code>cobrak.constant.LNCONC_PREFIX</code>, by default <code>x_</code>. E.g., the logarithmic metabolite concentration of metabolite <code>atp_c</code> (cytosolic ATP) would be called <code>x_atp_c</code>.</p> <p>Warning</p> <p>Just like in a non-thermodynamic FBA, there may be up to infinite many alternative solutions for the same optimal value. For an elucidation of the full solution space, you may use a TFVA (see below).</p> <p>Also, to make real use of thermodynamic constraints, your reactions need associated <code>dG0</code> values. For a way to automatically calculate them, see chapter 10.</p>"},{"location":"milps.html#optmdfpathway","title":"OptMDFpathway","text":"<p>Sometimes, it is interesting to find out the max-min driving force of a network, also called MDF. This MDF stands for the maximized minimal driving force of all active reactions. In other words, it stands for the highest possible minimal \\(f_i\\) in a network. We can easily formulate this optimization problem, known as OptMDFpathway [Paper], as:</p> \\[ \\operatorname*{\\mathbf{max}}_{\\mathbf{v}, \\mathbf{x\u0303}, \\mathbf{f}, B}  B \\\\ s.t. \\space CBM \\space  \\&amp; \\space thermodynamic \\space constraints \\] <p>In COBRA-k, the variable \\(B\\) has the constant name <code>cobrak.constants.MDF_VAR_ID</code>, by default <code>\"var_B\"</code>. With our toy model, we can perform OptMDFpathway as follows:</p> <pre><code>from cobrak.example_models import toy_model\nfrom cobrak.lps import perform_lp_optimization\nfrom cobrak.constants import MDF_VAR_ID\n\n# Perform OptMDFpathway\noptmdfpathway_result = perform_lp_optimization(\n    cobrak_model=toy_model,\n    objective_target=MDF_VAR_ID,\n    objective_sense=+1,\n    with_thermodynamic_constraints=True,\n)\n\n# Print MDF only\nprint(optmdfpathway_result[MDF_VAR_ID])\n</code></pre>"},{"location":"milps.html#thermodynamic-bottleneck-analysis-tba","title":"Thermodynamic Bottleneck Analysis (TBA)","text":"<p>Often, reactions such as growth are thermodynamically infeasible in our model with a given set of \\(\u0394_r G^{\u00b4\u00b0}_i\\) and concentration ranges. This is typically caused by thermodynamic bottleneck reactions, i.e. reactions whose \\(\u0394_r G^{\u00b4\u00b0}_i\\) is so high that the equation</p> \\[ f^{min} &gt; 0 \\] <p>cannot hold :-( To solve this problem, COBRA-k includes the thermodynamic bottleneck analysis (TBA) introduced [here]. It searches for one (not necessarily unique) minimal number of reactions whose \\(\u0394_r G^{\u00b4\u00b0}_i\\) has to be reduced to make a model state thermodynamically feasible. As a MILP, it introduces a new vector of binary variables \\(\\mathbf{z^b}\\) for each reaction \\(i\\) with thermodynamic constraints whereby</p> \\[ z^{B}_i \u2208 \\{0,1 \\} \\] <p>The \\(z^{B}_i\\) are now integrated in the reformulated constraint that controls whether a reaction is thermodynamically feasible or not (see above for the formulation without \\(z^{B}_i\\) ):</p> \\[ f_i + M \u22c5 \\left( 1-z_i \\right) + M \u22c5 z_i^B \u2265 B \\] <p>Essentially, if \\(z_i^B=1\\), then \\(z_i\\) can be zero even though the reaction is thermodynamically infeasible. We can now identify a minimal set of reactions whose \\(\u0394_r G^{\u00b4\u00b0}_i\\) has to be reduced through</p> \\[ \\operatorname*{\\mathbf{min}}_{\\mathbf{v}, \\mathbf{x\u0303}, \\mathbf{f}, B}  \u2211(z^{B}_i) \\\\ s.t. \\space CBM \\space  \\&amp; \\space thermodynamic \\space \\&amp; \\space TBA \\space constraints \\] <p>In COBRA-k, we can perform this analysis as follows:</p> <pre><code>from cobrak.example_models import toy_model\nfrom cobrak.lps import perform_lp_thermodynamic_bottleneck_analysis\n\n# Use model with extreme standard Gibbs free energy and enforced ATP production\nwith toy_model as tba_model:\n    tba_model.reactions[\"Glycolysis\"].dG0 = 100 # A bottleneck :O\n\n    # Perform TBA\n    list_of_bottleneck_reactions, _ = perform_lp_thermodynamic_bottleneck_analysis(\n        tba_model,\n    ) # The second returned value is the full solution (with fluxes, concentrations, ...) which we don't need here\n\n# Print list of thermodynamic bottlenecks\nprint(list_of_bottleneck_reactions)\n</code></pre> <p>Using with statement</p> <p>In our code snippet, we used Python's <code>with</code> with a <code>Model</code> instance. This is a handy way to automatically create a deep copy of our model, which does not affect the original model.</p>"},{"location":"milps.html#thermodynamic-variability-analysis-tva-including-concentration-variability-analysis-cva","title":"Thermodynamic Variability Analysis (TVA), including Concentration Variability Analysis (CVA)","text":"<p>Analogously to the Flux Variability Analysis shown in the previous chapter, we can now perform a general Thermodynamic Variability Analysis (TVA). Now, we may not only minimize and maximize fluxes, but also logarithmic concentrations:</p> \\[ \\operatorname*{\\mathbf{min}}_{\\mathbf{v},\\mathbf{x\u0303}, \\mathbf{f}, B}  \u03b2_i, \u03b2_i\u2208\\mathbf{v}\u222a\\mathbf{x} \\\\ s.t. \\space CBM \\space \\&amp; \\space thermodynamic \\space constraints \\] \\[ \\operatorname*{\\mathbf{max}}_{\\mathbf{v}, \\mathbf{x\u0303}, \\mathbf{f}, B}  \u03b2_i, \u03b2_i\u2208\\mathbf{v}\u222a\\mathbf{x} \\\\ s.t. \\space CBM \\space \\&amp; \\space thermodynamic \\space constraints \\] <p>We can recover the actual minimal and maximal concentrations through exponentiation:</p> \\[ c_i^{min}=e^{x\u0303_i^{min}} \\] \\[ c_i^{max}=e^{x\u0303_i^{max}} \\] <p>In COBRA-k, a TVA looks as follows:</p> <pre><code>from cobrak.example_models import toy_model\nfrom cobrak.lps import perform_lp_variability_analysis\nfrom cobrak.printing import print_variability_result\n\n# Perform TFVA\nvariability_dict = perform_lp_variability_analysis(\n    toy_model,\n    with_thermodynamic_constraints=True,\n)\n\n# Pretty print result as tables\nprint_variability_result(toy_model, variability_dict)\n</code></pre>"},{"location":"milps.html#combining-enzyme-and-thermodynamic-constraints","title":"Combining enzyme and thermodynamic constraints","text":"<p>Of course, you can combine thermodynamic constraints with enzyme constraints (shown in the last chapter), which e.g. makes a TFBA an ecTFBA. Just set the <code>with_thermodynamic_constraints</code> and <code>with_enzyme_constraints</code> to <code>True</code>:</p> <pre><code>from cobrak.example_models import toy_model\nfrom cobrak.lps import perform_lp_optimization\nfrom cobrak.printing import print_dict, print_optimization_result\n\n# Perform ecTFBA\nectfba_result = perform_lp_optimization(\n    cobrak_model=toy_model,\n    objective_target=\"ATP_Consumption\",\n    objective_sense=+1,\n    with_thermodynamic_constraints=True,\n    with_enzyme_constraints=True,\n)\n\n# Pretty print result as dictionary\nprint_dict(ectfba_result)\n\n# Pretty print result as tables,\n# now with enzyme concentrations *and* metabolite concentrations\nprint_optimization_result(toy_model, ectfba_result)\n</code></pre>"},{"location":"model_from_scratch.html","title":"Building metabolic models from scratch","text":"Quickstart code <pre><code># IMPORT SECTION\nfrom math import log\n\nfrom .constants import STANDARD_R, STANDARD_T\nfrom .dataclasses import (\n    Enzyme,\n    EnzymeReactionData,\n    ExtraLinearConstraint,\n    Metabolite,\n    Model,\n    Reaction,\n)\n\n# EXAMPLE MODEL DEFINITION SECTION\ntoy_model = Model(\n    reactions={\n        # Metabolic reactions\n        \"Glycolysis\": Reaction(\n            # Stoichiometrically relevant member variables\n            stoichiometries={\n                \"S\": -1,  # Negative stoichiometry \u2192 S is consumed by Glycolysis\n                \"ADP\": -2,\n                \"M\": +1,  # Positive stoichiometry \u2192 M is produced by Glycolysis\n                \"ATP\": +2,  # Two ATP molecules are produced by Glycolysis\n            },\n            min_flux=0.0,  # Minimal flux in mmol\u22c5gDW\u207b\u00b9\u22c5h\u207b\u00b9; should be \u22650 for most analyses\n            max_flux=1_000.0,  # Maximal flux in mmol\u22c5gDW\u207b\u00b9\u22c5h\u207b\u00b9\n            # Thermodynamically relevant member variables\n            # (only neccessary if thermodynamic constraints are used)\n            dG0=-10.0,  # Standard Gibb's free energy \u0394G'\u00b0 in kJ\u22c5mol\u207b\u00b9; Default is None (no \u0394G'\u00b0)\n            dG0_uncertainty=None,  # \u0394G'\u00b0 uncertainty in kJ\u22c5mol\u207b\u00b9; Default is None (no uncertainty)\n            # Let's set the variable for enzyme-kinetic parameters\n            # of the dataclass EnzymeReactionData\n            # (Default is None, i.e. no enzyme parameters given)\n            enzyme_reaction_data=EnzymeReactionData(\n                identifiers=[\n                    \"E_glyc\"\n                ],  # Subunit(s) which constitute the reaction's catalyst\n                k_cat=140_000.0,  # Turnover number in h\u207b\u00b9\n                k_ms={  # Michaelis-Menten constants in M=mol\u22c5l\u207b\u00b9; Default is {}\n                    \"S\": 0.0001,  # e.g., K_m of reaction Glycolysis regarding metabolite A\n                    \"ADP\": 0.0001,\n                    \"M\": 0.0001,\n                    \"ATP\": 0.0001,\n                },\n                special_stoichiometries={},  # No special stoichiometry, all subunits occur once\n            ),\n            # Extra information member variables\n            annotation={\"description\": \"This is reaction Glycolysis\"},  # Default is {}\n            name=\"Reaction Glycolysis\",  # Default is \"\"\n        ),\n        \"Respiration\": Reaction(\n            stoichiometries={\n                \"M\": -1,\n                \"ADP\": -4,\n                \"C\": +1,\n                \"ATP\": +4,\n            },\n            min_flux=0.0,\n            max_flux=1_000.0,\n            dG0=-10.0,\n            enzyme_reaction_data=EnzymeReactionData(\n                identifiers=[\"E_resp\"],\n                k_cat=140_000.0,\n                k_ms={\n                    \"ADP\": 0.00027,\n                    \"M\": 0.00027,\n                    \"C\": 0.0001,\n                    \"ATP\": 0.0001,\n                },\n            ),\n        ),\n        \"Overflow\": Reaction(\n            stoichiometries={\n                \"M\": -1,\n                \"P\": +1,\n            },\n            min_flux=0.0,\n            max_flux=1_000.0,\n            dG0=-10.0,\n            enzyme_reaction_data=EnzymeReactionData(\n                identifiers=[\"E_over\"],\n                k_cat=140_000.0,\n                k_ms={\n                    \"M\": 0.001,\n                    \"P\": 0.0001,\n                },\n            ),\n        ),\n        # Exchange reactions\n        \"EX_S\": Reaction(\n            stoichiometries={\n                \"S\": +1,\n            },\n            min_flux=0.0,\n            max_flux=1_000.0,\n        ),\n        \"EX_C\": Reaction(\n            stoichiometries={\n                \"C\": -1.0,\n            },\n            min_flux=0.0,\n            max_flux=1_000.0,\n        ),\n        \"EX_P\": Reaction(\n            stoichiometries={\n                \"P\": -1,\n            },\n            min_flux=0.0,\n            max_flux=1_000.0,\n        ),\n        \"ATP_Consumption\": Reaction(\n            stoichiometries={\n                \"ATP\": -1,\n                \"ADP\": +1,\n            },\n            min_flux=0.0,\n            max_flux=1_000.0,\n        ),\n    },\n    metabolites={\n        \"S\": Metabolite(\n            log_min_conc=log(\n                1e-6\n            ),  # optional, minimal ln(concentration); Default is ln(1e-6 M)\n            log_max_conc=log(\n                0.02\n            ),  # optional, maximal ln(concentration); Default is ln(0.02 M)\n            annotation={\n                \"description\": \"This is metabolite S\"\n            },  # optional, default is \"\"\n            name=\"Metabolite S\",  # optional, default is \"\"\n            formula=\"X\",  # optional, default is \"\"\n            charge=0,  # optional, default is 0\n        ),\n        \"M\": Metabolite(),\n        \"C\": Metabolite(),\n        \"P\": Metabolite(),\n        \"ATP\": Metabolite(),\n        \"ADP\": Metabolite(),\n    },\n    enzymes={\n        \"E_glyc\": Enzyme(\n            molecular_weight=1_000.0,  # Molecular weight in kDa\n            min_conc=None,  # Optional concentration in mmol\u22c5gDW\u207b\u00b9; Default is None (minimum is 0)\n            max_conc=None,  # Optional maximal concentration in mmol\u22c5gDW\u207b\u00b9; Default is None (only protein pool restricts)\n            annotation={\"description\": \"Enzyme of Glycolysis\"},  # Default is {}\n            name=\"Glycolysis enzyme\",  # Default is \"\"\n        ),\n        \"E_resp\": Enzyme(molecular_weight=2_500.0),\n        \"E_over\": Enzyme(molecular_weight=500.0),\n    },\n    max_prot_pool=0.4,  # In g\u22c5gDW\u207b\u00b9; This value is used for our analyses with enzyme constraints\n    # We set the following two constraints:\n    # 1.0 * EX_A - 1.0 * Glycolysis \u2264 0.0\n    # and\n    # 1.0 * EX_A + 1.0 * Glycolysis \u2265 0.0\n    # in other words, effectively,\n    # 1.0 * EX_A = 1.0 * Glycolysis\n    extra_linear_constraints=[\n        ExtraLinearConstraint(\n            stoichiometries={\n                \"EX_S\": -1.0,\n                \"Glycolysis\": 1.0,\n            },\n            lower_value=0.0,\n            upper_value=0.0,\n        )\n    ],  # Keep in mind that this is a list as multiple extra flux constraints are possible\n    kinetic_ignored_metabolites=[],\n    R=STANDARD_R,\n    T=STANDARD_T,\n    max_conc_sum=float(\"inf\"),\n    annotation={\"description\": \"COBRA-k toy model\"},\n)\n</code></pre> <p>To encode a metabolic network in COBRA-k, you can:</p> <ol> <li>Create a model from scratch - explained in this chapter :-)</li> <li>Load an already existing metabolic model - all such options, including JSON &amp; SBML import/export, are explained in the next chapters :D</li> </ol> <p>Here, we recreate the toymodel from COBRA-k's publication . It looks as follows:</p> <p></p> <p>Arrows stand for toy reactions with the name given in italic letters. Bold letters for toy metabolites. The numbers at the begin and end of arrows stand for the stoichiometry of each metabolite. E.g. the toy reaction \"Respiration\" looks as follows: <pre><code>1 M \u21d2 1 C + 6 ATP\n</code></pre></p> <p>By convention, reactions starting with \"EX_\" are substrate or product exchange reactions. They produce/consume their metabolite out of/into nothing, simulating an exchange with the outside. Such \"EX\" reactions are neccessary to make constraint-based model calculations work (see next chapters).</p> <p>The reactions \"Glycolysis\", \"Respiration\" and \"Overflow\" are toy metabolic reactions with a full set of kinetic and thermodynamic parameters.</p> <p>Note</p> <p>The usage of stoichiometric, kinetic and thermodynamic parameters will be explained in the following chapters. Here, we concentrate on recreating the model first and simply set the parameters as neccessary.</p>"},{"location":"model_from_scratch.html#model","title":"Model","text":"<p>Programmatically, a metabolic model in COBRA-k is an instance of the dataclass Model.</p> <p>About dataclasses and pydantic validation</p> <p>Dataclasses hold multiple objects together as one dataclass object. In many programming languages, they are known as <code>struct</code>. The objects held by a dataclass are called member variables.</p> <p>To automatically validate that your data is in the right numeric ranges (e.g., we only want positive values for molecular weights of enzymes), COBRA-k also integrated pydantic [GitHub] validation for its dataclasses. That's why you can find pydantic types such as <code>PositiveFloat</code>in COBRA-k's dataclass definitions. But you can still use normal types (e.g. <code>float</code>instead of <code>PositiveFloat</code>) for any dataclass member variable.</p> <p>As a first step, we'll create a Model dataclass instance with an empty set of metabolites, reactions and enzymes (we'll fill these sets later on) and where we explicitly set every member variable for didactic purposes:</p> <pre><code># All COBRA-k dataclasses can be found in the \"dataclasses\" submodule\nfrom cobrak.dataclasses import Model\n# In the \"constants\" subpackage, we can find values and identifiers\n# that are used throughout COBRA-k\nfrom cobrak.constants import STANDARD_R, STANDARD_T\n\n# Instantiate empty Model\ntoy_model = Model(\n    metabolites={}, # will become a dict[str, Metabolite] (see below)\n    reactions={}, # will become a dict[str, Reaction] (see below)\n    enzymes={}, # optional, default is {}, will become a dict[str, Enzyme] (see below)\n    max_prot_pool=0.4, # optional, default is 1e9\n    extra_linear_constraints=[], # optional, defaults to []\n    kinetic_ignored_metabolites=[], # optional, defaults to []\n    R=STANDARD_R, # optional, defaults to STANDARD_R = 8.314e-3 kJ\u22c5K\u207b\u00b9\u22c5mol\u207b\u00b9\n    T=STANDARD_T, # optional, defaults to STANDARD_T = 298.15 K = 25 \u00b0C = 77 \u00b0F\n    max_conc_sum=float(\"inf\"), # optional, defaults to float(\"inf\")\n    annotation={\"description\": \"COBRA-k toy model\"}, # optional, defaults to {}\n    # For additional Model member variables not relevant here, see below :-)\n)\n</code></pre> <p>Only <code>metabolites</code> and <code>reactions</code> are neccessary and we'll fill them in the following paragraphs :-) All other member variables are only neccessary if you want to use COBRA-k's kinetic and/or thermodynamic analysis features, which are explained in the next chapters.</p> <p>The Model member variables have the following meaning (variables in italic are optional):</p> <ul> <li>metabolites: dict[str, Metabolite] ~ This dictionary contains the metabolite names as keys, and metabolite data instances as values. Further explained below.</li> <li>reactions: dict[str, Reaction] ~ This dictionary contains the reaction names as keys, and reaction data instances as values. Further explained below.</li> <li>max_prot_pool: float ~ Only relevant if enzymatic constraints are used (see the \"Linear Programs\" chapter). It represents the fraction of the modeled enzymes on the total biomass. The unit is g/gDW.</li> <li>extra_linear_constraints: list[ExtraLinearConstraint] ~ Stands for linear set relationships between model variables. Further explained below.</li> <li>kinetic_ignored_metabolites: list[str] ~ Only relevant if enzyme kinetic constraints are used (see \"Non-linear Programs\" chapter). Contains the metabolite identifiers (see next paragraph) of metabolites which do not need a \\(K_M\\) value (see chapter about NLPs for more).</li> <li>R: float ~ Only relevant if thermodynamic constraints are used (see the \"Mixed-Integer Linear Programs\" chapter). Stands for the gas constant in kJ/(K\u22c5mol).</li> <li>T: float ~ Only relevant if thermodynamic constraints are used (see the \"Mixed-Integer Linear Programs\" chapter). Stands for the temperature in K.</li> <li>T: float ~ Only relevant if thermodynamic constraints are used (see the \"Mixed-Integer Linear Programs\" chapter). Stands for the temperature in K.</li> <li>max_conc_sum: float ~ Only relevant if thermodynamic constraints are used (see \"Mixed-Integer Linear Programs\" chapter). Stands for the maximally allowed sum of concentrations in a solutions. If it is set to <code>float(\"inf\")</code> (which is also the default value), no such constraint is introduced. Note that in mixed-integer linear programs, an approximation is used (as explained in the \"Mixed-Integer Linear Programs\" chapter) which can be further controlled by the <code>conc_sum_...</code> member variables explained below. Also note the member variable <code>conc_sum_include_suffixes</code> as only metabolites with the given suffixes in their IDs are included in the concentration sum.</li> </ul> Further optional Model member variables <p>There are also further optional Model member variables that may be used (but are not relevant for our toy model):</p> <ul> <li>fwd_suffix: str ~ Only relevant if statistics of forward and reverse reaction directions are regarded, or such reactions shall be merged in an SBML export (see 'Load/Save Models' chapter). This is a suffix (i.e. something attached to the end) for all of the Model's forward reaction IDs. E.g. if we would have a reversible reaction A\u2192B, its forward direction would be indicated by this suffix. Note that you have to add this suffix manually to all of your forward direction reactions! Default is <code>'_FWD'</code>.</li> <li>rev_suffix: str ~ Only relevant if statistics of forward and reverse reaction directions are regarded, or such reactions shall be merged in an SBML export (see 'Load/Save Models' chapter). This is a suffix for all of the Model's reverse reaction IDs. E.g. if we would have a reversible reaction A\u2192B, its reverse direction B\u2192A would be indicated by this suffix. Note that you have to add this suffix manually to all of your reverse direction reactions! Default is <code>'_REV'</code>.</li> <li>conc_sum_ignore_prefixes: list[str] ~ Only relevant if <code>max_conc_sum != float(\"inf\")</code> (see above) and mixed-integer linear programs with thermodynamic constraints are used (see \"Mixed-Integer Linear Programs\" chapter). Metabolites with the given prefixes are not included in the concentration sum constraint (see next member variable). Default is <code>[]</code>.</li> <li>conc_sum_include_suffixes: list[str] ~ Only relevant if <code>max_conc_sum != float(\"inf\")</code> (see above) and mixed-integer linear programs with thermodynamic constraints are used (see \"Mixed-Integer Linear Programs\" chapter). Only metabolites with the given suffixes are included in the concentration sum constraint. Default is <code>[]</code>.</li> <li>conc_sum_max_rel_error: float ~ Only relevant if <code>max_conc_sum != float(\"inf\")</code> (see above) and mixed-integer linear programs with thermodynamic constraints are used (see \"Mixed-Integer Linear Programs\" chapter). Stands for the maximal allowed relative concentration sum approximation error. Default is <code>0.05</code>, i.e. 5 %.</li> <li>conc_sum_min_abs_error: float ~ Only relevant if <code>max_conc_sum != float(\"inf\")</code> (see above) and mixed-integer linear programs with thermodynamic constraints are used (see \"Mixed-Integer Linear Programs\" chapter). Stands for the minimal absolute value of an approximated concentration sum. Default is <code>1e-6</code>.</li> </ul>"},{"location":"model_from_scratch.html#metabolite","title":"Metabolite","text":"<p>Now, let's create the metabolites \\(S\\), \\(M\\), \\(C\\), \\(P\\) and \\(ATP\\) for our toy model. For this, we use COBRA-k's Metabolite dataclass, and use it in our Model instance:</p> <pre><code># Import COBRA-k's Metabolite dataclass\nfrom cobrak.dataclasses import Metabolite\n# Let's import the standard Python natural logarithm function\nfrom math import log\n\ntoy_model.metabolites = {\n    \"S\": Metabolite(\n        log_min_conc=log(1e-6), # optional, minimal ln(conc); Default is ln(1e-6 M)\n        log_max_conc=log(0.02), # optional, maximal ln(conc); Default is ln(0.02 M)\n        annotation={\"description\": \"This is metabolite A\"}, # optional, default is \"\"\n        name=\"Metabolite A\", # optional, default is \"\"\n        formula=\"X\", # optional, default is \"\"\n        charge=0, # optional, default is 0\n    ),\n    \"M\": Metabolite(),\n    \"C\": Metabolite(),\n    \"P\": Metabolite(),\n    \"ATP\": Metabolite(),\n    \"ADP\": Metabolite(),\n}\n</code></pre> <p>Note</p> <p>A metabolite's ID (the name with which it can be accessed) is set as the key of the <code>metabolites</code> member variable dictionary.</p> <p>Also, you don't have to set Metabolite instances all at once. E.g. alternative ways to set ATP in our model are:</p> <pre><code># Alternative 1\ntoy_model.metabolites[\"ATP\"] = Metabolite()\n\n# Alternative 2\natp = Metabolite()\ntoy_model.metabolites[\"ATP\"] = atp\n\n# Alternative 3\natp_id = \"ATP\"\natp_met = Metabolite()\ntoy_model.metabolites[atp_id] = atp_met\n</code></pre> <p>These alternatives also apply for Reaction and Enzyme instances (see below).</p> <p>The (optional) Metabolite member variables are:</p> <ul> <li>log_min_conc: float &amp; log_max_conc: float ~ only relevant if thermodynamic constraints are used (see chapter \"Linear Programs\"). They stand for the logarithmized minimal and maximal allowed concentration of the metabolite. The concentration's unit is M=mol/l.</li> <li>annotation: dict[str, str] ~ Optional extra data in the form of a dictionary.</li> <li>name: str ~ Optional colloquial name of metabolite.</li> <li>charge: int ~ Optional electron charge of metabolite. Is not used in analyses right now, but may help the user as additional information.</li> </ul>"},{"location":"model_from_scratch.html#reaction","title":"Reaction","text":"<p>Now, we create the toy model's reactions together (if given) with their parameters:</p> <ol> <li>Glycolysis: S + 2 ADP \u21d2 M + 2 ATP</li> <li>Respiration: M + 4 ADP \u21d2 C + 4 ATP</li> <li>Overflow: M \u21d2 P</li> <li>EX_S: \u21d2 S</li> <li>EX_C: C \u21d2</li> <li>EX_P: P \u21d2</li> <li>ATP_Consumption: ATP \u21d2 ADP</li> </ol> <p>This can be done using COBRA-k's Reaction and EnzymeReactionData dataclasses and setting our toy model Model instance's <code>reaction</code> member variable:</p> <pre><code># Let's import the relevant COBRA-k dataclasses\nfrom cobrak.dataclasses import Reaction, EnzymeReactionData\n\ntoy_model.reactions = {\n    # Metabolic reactions\n    \"Glycolysis\": Reaction(\n        # Stoichiometrically relevant member variables\n        stoichiometries={\n            \"S\": -1,  # Negative stoichiometry \u2192 S is consumed by Glycolysis\n            \"ADP\": -2,\n            \"M\": +1,  # Positive stoichiometry \u2192 M is produced by Glycolysis\n            \"ATP\": +2,  # Two ATP molecules are produced by Glycolysis\n        },\n        min_flux=0.0,  # Minimal flux in mmol\u22c5gDW\u207b\u00b9\u22c5h\u207b\u00b9; should be \u22650 for most analyses\n        max_flux=1_000.0,  # Maximal flux in mmol\u22c5gDW\u207b\u00b9\u22c5h\u207b\u00b9\n        # Thermodynamically relevant member variables\n        # (only neccessary if thermodynamic constraints are used)\n        dG0=-10.0,  # Standard Gibb's free energy \u0394G'\u00b0 in kJ\u22c5mol\u207b\u00b9; Default is None (no \u0394G'\u00b0)\n        dG0_uncertainty=None,  # \u0394G'\u00b0 uncertainty in kJ\u22c5mol\u207b\u00b9; Default is None (no uncertainty)\n        # Let's set the variable for enzyme-kinetic parameters\n        # of the dataclass EnzymeReactionData\n        # (Default is None, i.e. no enzyme parameters given)\n        enzyme_reaction_data=EnzymeReactionData(\n            identifiers=[\n                \"E_glyc\"\n            ],  # Subunit(s) which constitute the reaction's catalyst\n            k_cat=140_000.0,  # Turnover number in h\u207b\u00b9\n            k_ms={  # Michaelis-Menten constants in M=mol\u22c5l\u207b\u00b9; Default is {}\n                \"S\": 0.0001,  # e.g., K_m of reaction Glycolysis regarding metabolite A\n                \"ADP\": 0.0001,\n                \"M\": 0.0001,\n                \"ATP\": 0.0001,\n            },\n            special_stoichiometries={},  # No special stoichiometry, all subunits occur once\n        ),\n        # Extra information member variables\n        annotation={\"description\": \"This is reaction Glycolysis\"},  # Default is {}\n        name=\"Reaction Glycolysis\",  # Default is \"\"\n    ),\n    \"Respiration\": Reaction(\n        stoichiometries={\n            \"M\": -1,\n            \"ADP\": -4,\n            \"C\": +1,\n            \"ATP\": +4,\n        },\n        min_flux=0.0,\n        max_flux=1_000.0,\n        dG0=-10.0,\n        enzyme_reaction_data=EnzymeReactionData(\n            identifiers=[\"E_resp\"],\n            k_cat=140_000.0,\n            k_ms={\n                \"ADP\": 0.00027,\n                \"M\": 0.00027,\n                \"C\": 0.0001,\n                \"ATP\": 0.0001,\n            },\n        ),\n    ),\n    \"Overflow\": Reaction(\n        stoichiometries={\n            \"M\": -1,\n            \"P\": +1,\n        },\n        min_flux=0.0,\n        max_flux=1_000.0,\n        dG0=-10.0,\n        enzyme_reaction_data=EnzymeReactionData(\n            identifiers=[\"E_over\"],\n            k_cat=140_000.0,\n            k_ms={\n                \"M\": 0.001,\n                \"P\": 0.0001,\n            },\n        ),\n    ),\n    # Exchange reactions\n    \"EX_S\": Reaction(\n        stoichiometries={\n            \"S\": +1,\n        },\n        min_flux=0.0,\n        max_flux=1_000.0,\n    ),\n    \"EX_C\": Reaction(\n        stoichiometries={\n            \"C\": -1.0,\n        },\n        min_flux=0.0,\n        max_flux=1_000.0,\n    ),\n    \"EX_P\": Reaction(\n        stoichiometries={\n            \"P\": -1,\n        },\n        min_flux=0.0,\n        max_flux=1_000.0,\n    ),\n    # ATP \"maintenance\" reaction\n    \"ATP_Consumption\": Reaction(\n        stoichiometries={\n            \"ATP\": -1,\n            \"ADP\": +1,\n        },\n        min_flux=0.0,\n        max_flux=1_000.0,\n    ),\n}\n</code></pre> <p>Reaction's member variables are as follows (optional variables are italic):</p> <ul> <li>stoichiometries: dict[str, float] ~ A dictionary that describes the stoichiometry of the reaction. Metabolite IDs are keys, stoichiometries values.</li> <li>min_flux: float ~ Minimal flux in mmol/(gDW\u22c5h); For most analyses, it must be \u22650, i.e. the reaction must be irreversible (no backwards flux possible).</li> <li>max_flux: float ~ Maximal flux in mmol/(gDW\u22c5h)</li> <li>dG0: float ~ Only neccessary if thermodynamic constraints are used; Standard Gibbs free energy (\u0394rG'\u00b0) of the reaction. For more about it, see the great explanation from the eQuilibrator FAQ.</li> <li>dG0_uncertainty: float: Only neccessary if thermodynamic constraints are used; The standard Gibb free energy's uncertainty, as returned, e.g., by the eQuilibrator API.</li> <li>enzyme_reaction_data: None | EnzymeReactionData ~ See subparagraph below.</li> <li>annotation: dict[str, str] ~ Any additional information regarding this reaction.</li> <li>name: str ~ Optional colloquial name of reaction.</li> </ul> <p>Info</p> <p>Reaction and Metabolite are the only obligatory dataclasses for a Model. All following presented dataclasses are only neccessary if you want to use enzymatic, kinetic and/or thermodynamic constraints. For these, see chapters \"Linear Programs\" and \"Non-Linear Programs\", which also explain what you can do with a Model as built here ;-)</p>"},{"location":"model_from_scratch.html#enzymereactiondata","title":"EnzymeReactionData","text":"<p>The defining feature of COBRA-k is that it can include the full reversible Michaelis-Menten kinetics. For this, COBRA-k needs associated enzymatic and kinetic data if it is known for a reaction (in this example, we just set some arbitrary values). If such data exists, we can set a Reaction's <code>enzyme_reaction_data</code> member variable to an EnzymeReactionData instance. If such data does not exist, enzyme_reaction_data is just <code>None</code>, which is also its default value.</p> <p>In our toy model, we could set the <code>enzyme_reaction_data</code> of the three toy metabolic reactions. Thereby, the member variables <code>identifiers</code> and <code>k_cat</code> are the only obligatory member variables for an EnzymeReactionData instance and all that's needed for \"classic\" linear enzyme-constrained modeling (see chapter \"Linear Programs\"). The other member variables are neccessary for the new COBRA-k non-linear modeling methologies (see chapter \"Non-Linear Programs\"). The member variables are:</p> <ul> <li>identifiers: list[str] ~ List of Enzyme IDs (see next subparagraph)</li> <li>k_cat: float ~ Turnover number in h</li> <li>k_ms: dict[str, float] ~ Michaelis-Menten constants for metabolites; the metabolites IDs are the string keys, and the \\(K_M\\) values the float values. Defaults to {}.</li> <li>special_stoichiometries: dict[str, float] ~ If any of the reaction's enzyme subunits (given in <code>identifiers</code>) has a stoichiometry that differs from 1, it can be given here. E.g. if an enzyme \\(E\\) would occur twice to form the reaction's enzyme complex, special_stoichiometries would be <code>{\"E\": 2}</code>.</li> </ul> <p>Note</p> <p>In COBRA-k, we assume that there is only one enzyme (complex) that catalyzes a single reaction. If multiple enzymes can catalyze the stoichiometrically identical reaction, multiple reactions have to be created in a Model. Nevertheless, this single enzyme that catalyzes a reaction can be made out of multiple subunits, all which are referenced in the <code>identifiers</code> member variable of EnzymeReactionData.</p> Adding references for \\(k_cat\\) and \\(k_M\\) data in EnzymeReactionData <p>EnzymeReactionData also provides the following two optional member variables:</p> <ul> <li>k_cat_references: list[ParameterReference] and</li> <li>k_m_references: list[ParameterReference]</li> </ul> <p>Both use <code>cobrak.dataclasses.ParameterReference</code>, which you can look up in this documentation's API overview. Using parameter references, you can e.g. include from which database(s) or paper(s) you got your information regarding the \\(k_{cat}\\) or \\(k_M\\).</p>"},{"location":"model_from_scratch.html#enzyme","title":"Enzyme","text":"<p>Any enzyme (or enzyme subunit) that is referenced in the identifiers of a reaction's EnzymeReactionData instance must be included as its own Enzyme instance, as part of the Model's enzyme variable. In our toy_model, we may add the enzymes as follows:</p> <pre><code>from cobrak.dataclasses import Enzyme\n\ntoy_model.enzymes={\n    \"E_glyc\": Enzyme(\n        molecular_weight=1_000.0, # Molecular weight in kDa\n        min_conc=None, # Optional concentration in mmol\u22c5gDW\u207b\u00b9; Default is None (minimum is 0)\n        max_conc=None, # Optional maximal concentration in mmol\u22c5gDW\u207b\u00b9; Default is None (only protein pool restricts)\n        annotation={\"description\": \"Enzyme of Glycolysis\"}, # Default is {}\n        name=\"Glycolysis enzyme\", # Default is \"\"\n    ),\n    \"E_resp\": Enzyme(molecular_weight=2_500.0),\n    \"E_over\": Enzyme(molecular_weight=500.0),\n},\n</code></pre> <p>The full molecular weight of a reaction's enzyme is the sum of all its subunit molecular weights. In this example, A_to_B's enzyme E has the weight 100.0 kDa + 110.0 kDa=210.0 kDa.</p> <p>Only the molecular weight is mandatory to be set, all other member variables are optional. If <code>min_conc</code> and/or <code>max_conc</code> are <code>None</code>, their respective concentration bounds are ignored. I.e., if <code>min_conc</code> is its default value <code>None</code>, the enzyme's minimal concentration is just 0; if <code>max_conc</code> is <code>None</code>, the enzyme's maximal concentration is as high as possible (<code>max_prot_pool / molecular_weight</code>).</p> <p><code>max_prot_pool</code> (\\(\u03a9\\) in our formulas) stands for the biomass fraction of all modeled metabolic enzymes. Its unit is g\u22c5gDW\u207b\u00b9 and it is an essential upper limit for the usage of enzymes in our analyses with enzyme constraints (see next chapters). In our toy model, we set it to 0.5 g\u22c5gDW\u207b\u00b9:</p> <pre><code>toy_model.max_prot_pool = 0.5\n</code></pre>"},{"location":"model_from_scratch.html#extralinearconstraint","title":"ExtraLinearConstraint","text":"<p>Optional extra linear constraints (further explained in the chapter \"Linear Programs\") can be included. E.g., if we want to set the (admittedly unnecessary as the model structure already enforces it in steady-state) reaction \\(EX_S\\) to have the same flux as reaction Glycolysis, we would set</p> <pre><code>from cobrak.dataclasses import ExtraLinearConstraint\n\n# We set the following two constraints:\n# 1.0 * EX_S - 1.0 * Glycolysis \u2264 0.0\n# and\n# 1.0 * EX_S + 1.0 * Glycolysis \u2265 0.0\n# in other words, effectively,\n# 1.0 * EX_S = 1.0 * Glycolysis\ntoy_model.extra_linear_constraints=[ExtraLinearConstraint(\n    stoichiometries={\n        \"EX_S\": -1.0,\n        \"Glycolysis\": 1.0,\n    },\n    lower_value=0.0,\n    upper_value=0.0,\n)] # Keep in mind that this is a list as multiple extra flux constraints are possible\n</code></pre> <p>Note</p> <p>Extra linear constraints do not only work with reaction fluxes, but also with all other variables introduced in the analyses provided by COBRA-k (see next chapters). E.g. you could also use logarithmic metabolite concentrations, saturation values etc. inside an extra linear constraint, and even mix these types of variables.</p>"},{"location":"model_from_scratch.html#loading-a-completed-toy_model","title":"Loading a completed toy_model","text":"<p>We are going to use the toy model that we created in the next chapters. You don't have to add the code of this chapter manually to provide the model as it is already provided as a COBRA-k example model:</p> <pre><code>from cobrak.example_models import toy_model\n\n# Now, we can do what we want with this chapter's toy_model :-)\n</code></pre>"},{"location":"model_io.html","title":"Load/Save Models","text":"<p>All functionality regarding loading and saving a Model instance or parts of it can be found in the <code>cobrak.io</code> submodule. For specific information on its functions, you can also see the <code>io</code> section in this documentation's \"API reference\" chapter.</p> <p>Pydantic validation</p> <p>As mentioned in the previous chapter, COBRA-k uses pydantic's [GitHub] validation features for its dataclasses, including <code>Model</code>. If your model file (in whatever format) contains an invalid value (e.g., a negative turnover number \\(k_cat\\) for a Reaction's enzyme reaction data), you'll get a <code>ValidationError</code>from pydantic. The error message shows more details about why the validation failed.</p> <p>If this happens, going through pydantic's validation error messages helps you to find these strange values in your model. Once fixed, you can then load the model into COBRA-k with more confidence in the integritiy of its data :-)</p> <p>There are two formats, JSON and SBML, in which you can interchangeably load and save a COBRA-k model, both of which store it in an human readable way:</p>"},{"location":"model_io.html#1-json","title":"1. JSON","text":"<p>Any of COBRA-k's dataclasses (see previous chapter), including Model instances, can be stored and loaded as JSON [Wikipedia] files. JSONs can be quickly saved and loaded tend to be easier to read and have a smaller file size than SBMLs. However, they are not interoperable with other program packages.</p> <p>Note</p> <p>While some other constraint-based modeling packages also provide JSON as input and output format, COBRA-k's JSON definition is incompatible with their definitions. To use an interoperable format that works with virtually all packages, use the SBML format (see below).</p>"},{"location":"model_io.html#save-model-as-json","title":"Save Model as JSON","text":"<p>Use <code>json_write</code>:</p> <pre><code>from cobrak.io import json_write\n\n# Assuming that we already have a cobrak_model variable :-)\njson_write(\n    path=\"/wished/save/path/filename.json\",\n    cobrak_model=cobrak_model,\n)\n</code></pre>"},{"location":"model_io.html#load-model-as-json","title":"Load Model as JSON","text":"<p>Use <code>json_load</code> using <code>Model</code>as type argument:</p> <pre><code>from cobrak.io import json_load\nfrom cobrak.dataclasses import Model\n\n# The \": Model\" addition and import of the Model dataclass\n# are not neccessary, however, they help if you utilize\n# Python's typing functionality, which provides e.g.\n# automatic completion for model instances.\ncobrak_model: Model = json_load(\n    path=\"/path/to/json/model/filename.json\",\n    Model,\n)\n</code></pre> <p>The type argument of <code>json_load</code>is optional to load a JSON. Using this type, COBRA-k utilizes pydantic to automatically verify the correctness of the given JSON (i.e. that it matches the given type or dataclass). If you're unsure about your JSON's type (e.g. if it is not a COBRA-k dataclass), you can also just use the <code>Any</code>type from Python's <code>typing</code> package.</p>"},{"location":"model_io.html#2-annotated-sbml","title":"2. (Annotated) SBML","text":"<p>The Systems Biology Markup Language [Paper] is a widely used format for storing metabolic models. COBRA-k can directly load such models and convert them to Model instances. However, as typical SBML files lack thermodynamic and kinetic extra information, this information has to be added later, as detailed in the next chapter about thermokinetic data retrieval.</p> <p>To overcome the limitation of lacking thermodynamic and kinetic data in SBML, COBRA-k stores this relevant information in extra annotation fields of the reactions, metabolites and genes (enzymes are interpreted as genes), making it an annotated SBML. COBRA-k can then load such an annotated SBML to create a Model with full thermodynamic and kinetic data again. Other program packages such as COBRApy [Paper] can load the annotated SBML. However, they typically cannot directly use most of the extra thermodynamic and kinetic information. This means that only basic analyses (as the ones described in the \"Linear Programs\" chapter) can be conducted with the other program packages.</p>"},{"location":"model_io.html#save-as-annotated-sbml","title":"Save as annotated SBML","text":"<p>To save a Model instance as annotated SBML, use <code>save_cobrak_model_as_annotated_sbml_model</code>:</p> <pre><code>from cobrak.io import save_cobrak_model_as_annotated_sbml_model\n\n# Assuming that we already have a cobrak_model variable :-)\nsave_cobrak_model_as_annotated_sbml_model(\n    cobrak_model,\n    filepath=\"/wished/path/filename.xml\",\n    combine_base_reactions=False, # Default is False\n    add_enzyme_constraints=False, # Default is False\n)\n</code></pre> <p>The <code>combine_base_reactions</code> argument controls whether split forward and reverse as well as split enzyme (for reactions which are catalyzed by multiple enzymes) reactions are to be merged in the SBML as a single reaction or not. This merging is then automatically reversed when loading an annotated SBML again (see following subchapter).</p> <p>The <code>add_enzyme_constraints</code> parameter controls whether or not the exported metabolic model shall include an expansion of the stoichiometric matrix (see chapter about Linear Programs) with enzyme constraints akin to the method GECKO (Paper). If True, pseudo-metabolites representing enzymes (if given, with their respective enzyme concentration bounds) and pseudo-reactions representing the protein pool and the delivery of these enzymes are added to the model, and enzymatically catalyzed reactions must consume the new pseudo-metabolites. For more information, read GECKO's paper. This expansion allows other program packages, including COBRApy, to directly use the enzyme constraints defined by the Model instance.</p> <p>When loading such an annotated XML again with COBRA-k, the enzyme constraints are automatically detected and the \"normal\" COBRA-k form of enzyme constraints is used again (as detailed in the chapter about Linear Programs).</p>"},{"location":"model_io.html#load-annotated-sbml","title":"Load (annotated) SBML","text":"<p>Loading an (annotated) SBML as a Model is simple:</p> <pre><code>from cobrak.io import load_annotated_sbml_model_as_cobrak_model\n\ncobrak_model = load_annotated_sbml_model_as_cobrak_model(\n    \"/path/to/sbml/filename.xml\"\n)\n</code></pre> <p>Keep in mind that only with COBRA-k annotations, COBRA-k can successfully directly read the thermodynamic and kinetic data of the model. Otherwise, t has to be included later to the Model instance. Options to do so are detailed in the next chapter. Without COBRA-k annotations in the SBML, a standard metabolite concentration range of \\(10^{-6}\\) up to 0.02 M is assumed. Also, the protein pool is set to 1_000 g\u22c5gDW\u207b\u00b9, essentially deactivating any possible enzyme constraints.</p>"},{"location":"nlps.html","title":"Nonlinear COBRA-k programs","text":"Quickstart code <pre><code>from cobrak.example_models import toy_model\nfrom cobrak.lps import perform_lp_variability_analysis\nfrom cobrak.printing import print_optimization_result, print_variability_result\n# Import MINLP functionality in our *NLP* package\n# The \"reversible\" means that driving forces can become negative, but\n# reactions still have to be split as irreversible ones (v_i&gt;=0)\nfrom cobrak.nlps import perform_nlp_reversible_optimization\n# Import NLP functionality in our NLP package\n# The \"irreversible\" means that driving forces can*not* become negative\nfrom cobrak.nlps import perform_nlp_irreversible_optimization_with_active_reacs_only\n\n#%\n# Run preparatory variability analysis\nvariability_dict = perform_lp_variability_analysis(\n    toy_model,\n    with_enzyme_constraints=True,\n    with_thermodynamic_constraints=True,\n)\n# Pretty-print variability result\nprint_variability_result(toy_model, variability_dict)\n\n#%\n# Run MINLP (by default, with the SCIP solver)\nminlp_result = perform_nlp_reversible_optimization(\n    cobrak_model=toy_model,\n    objective_target=\"ATP_Consumption\", # Let's maximize ATP production\n    objective_sense=+1,\n    # Set the variable bounds from our preparatory variability analysis\n    variability_dict=variability_dict,\n    # We use the saturation term constraint (otherwise, \u03ba is set to 1 for all reactions);\n    # default is True anyway\n    with_kappa=True,\n    # We use the thermodynamic term constraint (otherwise, \u03b3 is set to 1 for all reactions);\n    # default is True anyway\n    with_gamma=True,\n)\n# Pretty-print MINLP result\nprint_optimization_result(toy_model, minlp_result)\n\n#%\n# Run (local and fast) NLP (by default, with the IPOPT solver)\nnlp_result = perform_nlp_irreversible_optimization_with_active_reacs_only(\n    toy_model,\n    objective_target=\"ATP_Consumption\",\n    objective_sense=+1,\n    # Set the suitable set of thermodynamically active reactions\n    optimization_dict=minlp_result,\n    # Set the variable bounds from our preparatory variability analysis\n    variability_dict=variability_dict,\n    # We use the saturation term constraint (otherwise, \u03ba is set to 1 for all reactions);\n    # default is True anyway\n    with_kappa=True,\n    # We use the thermodynamic term constraint (otherwise, \u03b3 is set to 1 for all reactions);\n    # default is True anyway\n    with_gamma=True,\n)\n\nprint_optimization_result(toy_model, nlp_result)\n</code></pre>"},{"location":"nlps.html#introduction","title":"Introduction","text":""},{"location":"nlps.html#reversible-michaelis-menten-kinetics","title":"Reversible Michaelis-Menten kinetics","text":"<p>In the last chapters, we looked at Linear and Mixed-Integer Linear Optimization problems. As explained, these optimization problems are able to include stoichiometric, enzyme-pool and thermodynamic constraints. But they are not able to capture full reaction kinetics. One form of reaction kinetics is the reversible Michaelis-Menten kinetics, which is [Paper]:</p> \\[ v_i = V^{+}_i \u22c5 \u03ba_i \u22c5 \u03b3_i \\] <p>\\(v_i\\) is, again, the reaction \\(i\\)'s flux. $V^{+}_i stands for the enzyme-dependent maximal flux that we already know from the basic enzyme constraints:</p> \\[ V^{+}_i = E_i \u22c5 k_{cat} \\] <p>\\(\u03ba_i\\) is the saturation term - a unitless value that lies in \\([0,1]\\) - which is dependent on the enzyme's Michaelis-Menten constants (\\(K_M\\)) and is:</p> \\[ \u03ba_i = {{\\bar{s}_i} \\over {1 + \\bar{s}_i + \\bar{p}_i}} \\] <p>\\({\\bar{s}_i}\\) a \\(K_M\\)-dependent product of the concentrations of the reaction's substrates:</p> \\[ {\\bar{s}_i} = \\prod_{j \\in \ud835\uddb2_i} (c_j \u22c5 K_{M,j,i}) ^ {|N_{i,j}|}\\] <p>\\(K_{M,j,i}\\) is the Michaelis-Menten constant of this substrate for this reaction, and \\(\ud835\uddb2_i\\) is the set of all indices of reaction \\(i\\)'s substrates. \\(c_s\\) is the concentration of substrate \\(j\\) and \\(|N_{i,j}|\\) the absolute stoichiometry of the metabolite.</p> <p>Analogously, \\({\\bar{p}_i}\\) a value affected by the reaction's products:</p> \\[ {\\bar{p}_j} = \\prod_{k \\in \ud835\uddaf_i} (c_k \u22c5 K_{M,k,i}) ^ {N_{i,k}}\\] <p>where \\(k\\) is the index of the product, taken from the set of reaction product indices \\(\ud835\uddaf_i\\).</p> <p>The last part of the reversible Michaelis-Menten kinetics, \\(\u03b3_i\\), is the thermodynamic term. It is also a unitless value in \\((-\u221e,1]\\):</p> \\[ \u03b3_i = ( 1 - e^{-f_i / (R \u22c5 T)} ) \\] <p>As explained in the previous chapter, R is the Gas constant, T the temperature and \\(f_i\\) the reaction's driving force.</p> <p>In conclusion, \\(V^{+}_i\\) determines the maximally possible reaction flux. Both \\(\u03ba_i\\) and \\(\u03b3_i\\) can only restrict this maximally possible flux. This is because \\(\u03ba_i\\) and \\(\u03b3_i\\) can only lie in \\([0,1]\\) and \\((-\u221e,1]\\), respectively. Thereby, if we only allow positive driving forces (\\(f_i&gt;0\\)), \\(\u03b3_i\\) is even restricted to \\((0,1]\\). Also, both \\(\u03ba_i\\) and \\(\u03b3_i\\) follow the general idea of reaction kinetics: The higher the product concentrations, the lower the reaction's flux. Conversely, the higher the substrate concentrations, the higher the flux.</p>"},{"location":"nlps.html#mixed-integer-nonlinear-programming","title":"(Mixed-integer) Nonlinear Programming","text":"<p>Minlp</p>"},{"location":"nlps.html#nonlinear-kinetic-constraints","title":"Nonlinear kinetic constraints","text":"<p>Now that we know the formulas of the Michaelis-Menten kinetics, we want to efficiently integrate them in our framework of constriant-based modeling. From CBM, we are at least still using:</p> <ul> <li>the steady-state constraints (see LP chapter)</li> <li>extra linear constraints (see LP chapter)</li> <li>the logarithmic concentrations and their bounds (see MILP chapter)</li> <li>the reaction driving forces \\(f_i\\) (see MILP chapter)</li> </ul> <p>For our further CBM integration, \"efficently integrating the kinetic formulas\" means that we relax the kinetic formulas as much as possible. This means that we do not treat them as equality but as inequality:</p> \\[ v_i \u2264 V^{+}_i \u22c5 \u03ba_i \u22c5 \u03b3_i \\] <p>Now, \\(v_i\\) is allowed to become lower than what would be expected from the kinetics. However, we are also still using the central protein pool constrained introduced in the LP chapter:</p> \\[ \u2211_i W_i \u22c5 E_i \u2264 \u03a9 \\] <p>This means that, in a typical optimziation, the enzymes are still going to be used as efficiently as possible. I.e., typically, the lowest needed amount of enzymes is found, such that our inequality often becomes an equality :-) Conversely, in cases where this does not hold, the enzyme usage is not the major constraint for our optimization anyway.</p> <p>Following our relaxation scheme, we also relax the maximally possible flux \\(V^{+}_i\\) as inequality:</p> \\[ V^{+}_i \u2264 E_i \u22c5 k_{cat} \\] <p>$ \u03ba_i $ is also now an inequality and made dependent on our logarithmic concentrations as follows:</p> \\[ \u03ba_i &lt;= {e^{\\tilde{s}_i} \\over {( 1+e^{\\tilde{s}_i}+e^{\\tilde{p}_i} )}} \\] <p>where \\(\\tilde{s}_i\\) and \\(\\tilde{p}_i\\) are the logarithmic variants of \\(\\bar{s}_i\\) and \\(\\bar{p}_i\\) (see above) and are using our logarithmic concentration vector \\(\\mathbf{\\tilde{x}}\\) (see previous chapter):</p> \\[ \\tilde{s}_i = \\ln ( \\bar{s} ) = \\sum_{j \u2208 \ud835\uddb2_i} ( |N_{j,i}| \u22c5 x\u0303_j ) - \\sum_{j \u2208 \ud835\uddb2_i} ( |N_{j,i}| \u22c5  \\ln K_{M,j,i} ) \\] \\[ \\tilde{p}_i \u2265 \\ln ( \\bar{p} ) = \\sum_{k \u2208 \ud835\uddaf_i} ( N_{k,i} \u22c5 x\u0303 ) - \\sum_{k \u2208 \ud835\uddaf_i} ( N_{k,i} \u22c5  \\ln K_{M,k,i} ) \\] <p>Note that \\(\\tilde{p}\\) is even further relaxed, as lower \\(\\tilde{p}\\) could only restrict a reaction flux even further (see formula for \\(\u03ba_i\\)).</p> \\[ \u03b3_i \u2264 (1-e^{f_i / (R \u22c5 T)})\\] <p>whereby we also relax \\(f_i\\), again in a direction which could only lower the flux, as (using the definitions from the previous chapter)</p> \\[ f_i \u2264 -(\u0394_r G^{\u00b4\u00b0}_i + R \u22c5 T \u22c5 \\mathbf{N_{\u22c5,i}} \u22c5 \\mathbf{x\u0303}) \\] <p>And that's it :D With these additional constraints, on top of our mentioned constrained-based constrained that we introduced in earlier chapters, we could now run constraint-based analyses with full reaction kinetics :-)</p>"},{"location":"nlps.html#optional-concentration-sum-constraints","title":"Optional concentration sum constraints","text":"<p>COBRA-k also provides the possibility to introduce concentration sum constraints. They are only activated if a Model's <code>max_conc_sum</code> member variable is smaller than the default value <code>float(\"inf\")</code>. The concentration sum constraint is simply</p> \\[ \u03a6 \u2264 \\sum{e^(x\u0303_j)} \\] <p>Note</p> <p>We don't need any of the linear approximation tricks used for MILPs (see last chapter) here :-)</p> <p>Warning</p> <p>Adding concentration sum constraints can cause a heavy load on a non-linear solver. Hence, if you are expereiencing very slow solving times, they might be caused by this constraint if you have set <code>max_conc_sum</code> to a value lower than its default <code>float(\"inf\")</code>.</p>"},{"location":"nlps.html#preparatory-variability-analysis","title":"Preparatory Variability Analysis","text":"<p>One major problem with our non-linear constraints is that certain values may become very large or very small. In particular, \\(e^{\\tilde{s}_i}\\), \\(e^{\\tilde{p}_i}\\) may become way too large and \\(\u03b3_i\\) way too small if \\(f_i\\) is too negative. This would lead to solver errors, making optimization impossible.</p> <p>Luckily, we still use our pre-set logarithmic concentration bounds (see previous chapter) which typically restrict all our values to solver-friendly sizes. Hence, running a MILP-based ecTFVA (see previous chapter) for all linear values in our problem, namely the...</p> <ul> <li>reaction fluxes \\(\\mathbf{v}\\)</li> <li>enzyme concentrations \\(\\mathbf{E}\\)</li> <li>logarithmic concentrations \\(\\mathbf{\\tilde{x}}\\)</li> <li>driving forces \\(\\mathbf{f}\\)</li> <li>logarithmic saturation values \\(\\mathbf{\\tilde{s}}\\) and \\(\\mathbf{\\tilde{p}}\\)</li> </ul> <p>...solves our problem with too high and too low values. Mathematically, the ecTFVA-based preparatory variability analysis can be written as</p> \\[ \\operatorname*{\\mathbf{min}}_{\\mathbf{v, E, x\u0303, f, z, \\tilde{p}, \\tilde{s}, \u03ba, \u03b3}, B}  \\mathbf{\u03b2_i, \u03b2 \u2208 \\{ \\mathbf{v}, \\mathbf{E}, \\mathbf{\\tilde{x}}, \\mathbf{f}, \\mathbf{\\tilde{s}}, \\mathbf{\\tilde{p}} \\}} \\\\ s.t. \\space CBM \\space \\&amp; \\space thermodynamic \\space \\&amp; \\space saturation \\space term \\space  constraints \\] <p>and</p> \\[ \\operatorname*{\\mathbf{max}}_{\\mathbf{v, E, x\u0303, f, z, \\tilde{p}, \\tilde{s}, \u03ba, \u03b3}, B}  \\mathbf{\u03b2_i, \u03b2 \u2208 \\{ \\mathbf{v}, \\mathbf{E}, \\mathbf{\\tilde{x}}, \\mathbf{f}, \\mathbf{\\tilde{s}}, \\mathbf{\\tilde{p}} \\}} \\\\ s.t. \\space CBM \\space \\&amp; \\space thermodynamic \\space \\&amp; \\space saturation \\space term \\space  constraints \\] <p>In COBRA-k, we can run (and let us pretty-print) such a preparatory variability analysis analogously as how we did it in the previous chapter:</p> <pre><code># Import our known toy model (see LP chapter) and methods\nfrom cobrak.example_models import toy_model\nfrom cobrak.lps import perform_lp_variability_analysis\nfrom cobrak.printing import print_variability_result\n\n# Run preparatory variability analysis\nvariability_dict = perform_lp_variability_analysis(\n    toy_model,\n    with_enzyme_constraints=True,\n    with_thermodynamic_constraints=True,\n)\n# Pretty-print variability result\nprint_variability_result(toy_model, variability_dict)\n</code></pre>"},{"location":"nlps.html#global-minlp-generally-slow","title":"Global MINLP (generally slow)","text":"<p>Warning</p> <p>While this MINLP can lead to great global result, it is typically way too slow and not suitable even for mid-scale metabolic models with more than a dozen reactions, even with the relaxations introduced above. For alternatives, see the next subchapter as well as the evolutionary optimization in the next chapter.</p> <p>Also, due to the non-linearity of our new constraints, only solvers which are capable of handling such constraints in pyomo can be used. E.g., CPLEX and Gurobi (at least older Gurobi versions) cannot be used with non-linear optimizations.</p> <p>To globally optimize on a full metabolic model using our non-linear constraint, we can use COBRA-k's MINLP functionality. It is defined as</p> \\[ \\operatorname*{\\mathbf{min}}_{\\mathbf{v, E, x\u0303, f, z, \\tilde{p}, \\tilde{s}, \u03ba, \u03b3}, B}  \\mathbf{g^\\top} \\\\ s.t. \\space CBM \\space \\&amp; \\space thermodynamic \\space \\&amp; \\space nonlinear \\space  constraints \\] <p>and lets us globally optimize any value introduced in our linear, mixed-integer and non-linear constraints.</p> <p>In COBRA-k, we can run a MINLP on toy model (which is small enough for it to run) as follows, whereby COBRA-k's <code>nlps</code> subpackage is used:</p> <pre><code># Import toy model and pretty-print function and (ecT)FVA function\nfrom cobrak.example_models import toy_model\nfrom cobrak.printing import print_optimization_result\nfrom cobrak.lps import perform_lp_variability_analysis\n# Import MINLP functionality in our *NLP* package\n# The \"reversible\" means that driving forces can become negative, but\n# reactions still have to be split as irreversible ones (v_i&gt;=0)\nfrom cobrak.nlps import perform_nlp_reversible_optimization\n\n# Run preparatory variability analysis\nvariability_dict = perform_lp_variability_analysis(\n    toy_model,\n    with_enzyme_constraints=True,\n    with_thermodynamic_constraints=True,\n)\n\n# Run MINLP (by default, with the SCIP solver)\nminlp_result = perform_nlp_reversible_optimization(\n    cobrak_model=toy_model,\n    objective_target=\"ATP_Consumption\", # Let's maximize ATP production\n    objective_sense=+1,\n    # Set the variable bounds from our preparatory variability analysis\n    variability_dict=variability_dict,\n    # We use the saturation term constraint (otherwise, \u03ba is set to 1 for all reactions);\n    # default is True anyway\n    with_kappa=True,\n    # We use the thermodynamic term constraint (otherwise, \u03b3 is set to 1 for all reactions);\n    # default is True anyway\n    with_gamma=True,\n)\n# Pretty-print MINLP result\nprint_optimization_result(toy_model, minlp_result)\n</code></pre> <p>Info</p> <p>Just like all other optimization functions, <code>perform_nlp_reversible_optimization</code> has many other optional arguments, including the possibility to use other solvers, solver and pyomo solve funtion options. For more information, see this documentation's \"API reference\".</p>"},{"location":"nlps.html#local-nlp-fast-but-restricted","title":"Local NLP (fast, but restricted)","text":"<p>Warning</p> <p>The NLP shown here is fast, but only suitable if you are working with a selected metabolic set of reactions that can be thermodynamically feasible at the same time (not a full model). But this NLP is the basis of the evolutionary algorithm, which is shown in the next chapter and lets you quasi-globally optimize a full metabolic model with non-linear constraints.</p> <p>As the MINLP can be very slow, COBRA-k also provides a fast NLP that works on a single set of reactions that can be thermodynamically feasible at the same time. I.e., the following constraint holds:</p> \\[ f_i \u2265 f^{min} \\] <p>whereby \\(f^{min}\\) has to be positive. This means that no full model can be used, as it typically includes (e.g. reverse direction) reactions with a negative driving force. But once you have a suitable set of reactions, you can quickly solve the following NLP (now without any binary variables, in contrast to the MINLP):</p> \\[ \\operatorname*{\\mathbf{min}}_{\\mathbf{v, E, x\u0303, f, \\tilde{p}, \\tilde{s}, \u03ba, \u03b3}, B}  \\mathbf{g^\\top} \\\\ s.t. \\space CBM \\space \\&amp; \\space nonlinear \\space constraints \\] <p>In COBRA-k, you can find a suitable set of thermodynamically feasible reactions with an ecTFBA first, and then calculate the NLP:</p> <pre><code># Import toy model and pretty-print function and pathway-using ecTFBA\nfrom cobrak.example_models import toy_model\nfrom cobrak.printing import print_optimization_result\nfrom cobrak.lps import perform_lp_optimization, perform_lp_variability_analysis\n# Import NLP functionality in our NLP package\n# The \"irreversible\" means that driving forces can*not* become negative\nfrom cobrak.nlps import perform_nlp_irreversible_optimization_with_active_reacs_only\n\n# Run preparatory variability analysis for our NLP\nvariability_dict = perform_lp_variability_analysis(\n    toy_model,\n    with_enzyme_constraints=True,\n    with_thermodynamic_constraints=True,\n)\n\n# Find suitable set of thermodynamically active reactions\nectfba_result = perform_lp_optimization(\n    cobrak_model=toy_model,\n    objective_target=\"ATP_Consumption\",\n    objective_sense=+1,\n    # Set enzyme constraints as they are also used in the NLP\n    with_enzyme_constraints=True,\n    # This following setting is important to find thermodynamically active reactions\n    with_thermodynamic_constraints=True,\n)\n\n# Run (local and fast) NLP (by default, with the IPOPT solver)\nnlp_result = perform_nlp_irreversible_optimization_with_active_reacs_only(\n    toy_model,\n    objective_target=\"ATP_Consumption\",\n    objective_sense=+1,\n    # Set the suitable set of thermodynamically active reactions\n    optimization_dict=ectfba_result,\n    # Set the variable bounds from our preparatory variability analysis\n    variability_dict=variability_dict,\n    # We use the saturation term constraint (otherwise, \u03ba is set to 1 for all reactions);\n    # default is True anyway\n    with_kappa=True,\n    # We use the thermodynamic term constraint (otherwise, \u03b3 is set to 1 for all reactions);\n    # default is True anyway\n    with_gamma=True,\n)\n\nprint_optimization_result(toy_model, nlp_result)\n</code></pre> <p>Again, <code>perform_nlp_reversible_optimization</code> has many further optional arguments that you can find in this documentation's \"API reference\" chapter. By default, COBRA-k uses the non-linear solver IPOPT for NLPs.</p>"},{"location":"nlps.html#extra-non-linear-flux-constraints","title":"Extra non-linear flux constraints","text":"<p>Optionally, you can also introduce extra non-linear constraints (corresponding to the <code>ExtraNonlinearConstraint</code> dataclass, used in <code>Model</code>) that set constrained relationships between variables. Currently, the non-linear functions \"powerX\" (i.e. take the X-th power of a value), \"log\" and \"exp\" are usable. \"same\" is the option if you do not want a function application (i.e. it's a multiplication with 1). See COBRA-k's API documentation for more. As an example, let's set a (nonsense) non-linear constraint that restricts the flux of reaction EX_P to the doubled exponential value of the concentration of C:</p> <pre><code># ...using the code imports from above\nfrom cobrak.constants import LNCONC_VAR_PREFIX\nfrom cobrak.dataclasses import ExtraNonlinearConstraint\n\n# Let's define v_EX_P &lt;= 2 * exp(x_C)\ntoy_model.extra_nonlinear_constraints = [\n    ExtraNonlinearConstraint(\n        stoichiometries={\n            \"EX_P\": (1.0, \"same\"),  # first the stoichiometry, second the function application\n            f\"{LNCONC_VAR_PREFIX}C\": (-2.0, \"exp\"),\n        },\n        upper_value=0.0,\n    )\n]\n</code></pre>"},{"location":"nlps.html#extra-linear-watches","title":"Extra linear watches","text":"<p>Optionally, you can also introduce extra linear watch variables (corresponding to the <code>ExtraNonlinearWatch</code> dataclass, used in <code>Model</code>) that add a variable with a fixed non-linear relationships to single fluxes. See COBRA-k's API documentation for more. Currently, the non-linear functions \"powerX\" (i.e. take the X-th power of a value), \"log\" and \"exp\" are usable. See COBRA-k's API documentation for more. Here's an example where we set a watch to the logarithm of the flux of EX_S:</p> <pre><code># ...using the code imports from above\nfrom cobrak.dataclasses import ExtraNonlinearWatch\n\n# Let's define v_EX_P &lt;= 2 * exp(x_C)\ntoy_model.extra_nonlinear_watches = {\n    \"log_EX_S\": ExtraNonlinearWatch(\n        stoichiometries={\n            \"EX_S\": (1.0, \"log\"),\n        },\n    )\n}\n</code></pre> <p>...now, we have a variable <code>log_EX_S</code> that is also added to result dictionaries after LP or NLP optimizations.</p>"},{"location":"paper_reproduction.html","title":"Reproduce publication results","text":"<p>Solver usage</p> <p>The iCH360 scripts mentioned herein usually use CPLEX as LP solver. Please refer to this documentation's installation chapter for instructions on how to install it for COBRA-k. Alternatively, simply switch all instances where \"CPLEX\" is called to another server (e.g. the pre-installed SCIP) or add a <code>solver=YOUR_SOLVER</code>option to any case where an optimization is called.</p> <p>Also, for the iCH360 calculations, the IPOPT sub-solver MA57 is used, such that the <code>IPOPT_MA57</code>solver with personal HSLLIB path settings from the publication's authors is loaded from <code>cobrak.standard_solvers</code>. To use MA57, obtain it through HSLLIB from here (free for academics):</p> <p>https://licences.stfc.ac.uk/product/coin-hsl</p> <p>...and change the <code>\"hsllib\"</code> <code>solver_option</code>in <code>IPOPT_MA57</code> to your HSLLIB path.</p> <p>Re-run of existing calculation</p> <p>Many iCH360 calculations will not run because existing calculation results are found (this prevents unneccessary double calculations). To mitigate this problem, simply detele all folders in the ``\u00ecCH360<code>subfolder except of the</code>external_resources``` folder.</p> <p>To reproduce COBRA-k's initial publication (Bekiaris &amp; Klamt, in submission) results, head over to the <code>examples</code> subfolder in COBRA-k's main folder. There, you can already find the first important Python scripts that pre-processed some data:</p> <ul> <li>FIRST_A_read_out_sabio_rk.py: Reads out SABIO-RK and creates a cache into the <code>common_needed_external_resources</code>folder</li> <li>FIRST_B_get_ec_number_transfers.py: Reads out EXPASy obsoleted EC number data and creates a cache into the <code>common_needed_external_resources</code>folder</li> <li>FIRST_C_read_out_met_concs_file.py: Reads out BiGG metabolites file obsoleted EC number data and puts a more machine-readable version into the <code>common_needed_external_resources</code>folder</li> <li>FIRST_D_read_out_enzyme_abundance_file.py: (Specific for the publication) Reads out the in vivo enzyme data</li> </ul> <p>So far, all these steps were just some caching steps to make our subsequent model creation steps reproducibly faster.</p> <p>For the toy model calculations, simply run <code>examples/toymodel/run_toymodel_calculations.py</code>.</p> <p>Let's continue with <code>\u00ecCH360</code> (regarding the iCH360 COBRA-k variant described in COBRA-k's publication) in the appropriate subfolder. There, simply follow the alphabetically sorted scripts and run them with <code>uv run</code>. The only more complex script for usage is <code>H_run_calculations.py</code>. As input, it takes JSON with a reproducible run configuration (with model settings and so on). To generate the run setting JSONs of COBRA-k's publication on you local machine, run <code>main_paper_calculations.py local</code> in COBRA-k's main folder. Note the <code>local</code> option, which creates the JSONs in a <code>main_paper_calculations_jsons</code> subfolder. Without the <code>local</code> option, you can use to run all the main paper calculations on a SLURM computer cluster as it creates a SLURM file and <code>sbatch</code>es it for each JSON run config.</p> <p>If you just want to play around with iCH360_cobrak, you can simply import it through <code>from cobrak.toy_models import iCH360_cobrak</code>. iCH360_cobrak is now a <code>Model</code>variable with the full model.</p>"},{"location":"parameter_corrections.html","title":"Parameter corrections","text":"Quickstart code <pre><code># Import relevant classes and functions\nfrom cobrak.lps import perform_lp_optimization\nfrom cobrak.example_models import toy_model\nfrom cobrak.dataclasses import CorrectionConfig\nfrom cobrak.constants import LNCONC_VAR_PREFIX, ERROR_SUM_VAR_ID\nfrom cobrak.printing import print_dict\nfrom math import log\n\n#\nflux_and_concentration_error_scenario = {\n    \"Overflow\": (1.0, 1.4),  # Overflow reaction flux between 1 and 1.4\n    f\"{LNCONC_VAR_PREFIX}M\": (log(0.2), log(0.2)),  # M concentration fixed at .2 molar\n    f\"{LNCONC_VAR_PREFIX}D\": (log(0.23), log(0.25)),  # D concentration betwewen .23 and .25 molar\n}\n\n# With a CorrectionConfig as optional further argument,\n# all explained extra variables for parameter corrections\n# are added to our model automatically :D\n# Now, we can just minimize the sum of correction errors.\ncorrection_result_1 = perform_lp_optimization(\n    cobrak_model=toy_model,\n    objective_target=ERROR_SUM_VAR_ID,\n    objective_sense=-1,\n    with_thermodynamic_constraints=True,\n    correction_config=CorrectionConfig(\n        error_scenario=flux_and_concentration_error_scenario,\n        add_flux_error_term=True,\n        add_met_logconc_error_term=True,\n    ),\n)\n\nprint_dict(correction_result_1)\n\n#% k_cat*[E] correction\n# Import relevant classes and functions\nfrom cobrak.lps import perform_lp_optimization\nfrom cobrak.example_models import toy_model\nfrom cobrak.dataclasses import CorrectionConfig\nfrom cobrak.constants import LNCONC_VAR_PREFIX, ERROR_SUM_VAR_ID\nfrom cobrak.printing import print_dict\nfrom cobrak.utilities import apply_error_correction_on_model\n\n#\nflux_and_concentration_error_scenario = {\n    \"Glycolysis\": (40.0, 45.0),\n}\n\n# Again, minimize the correction error variable sum\ncorrection_result_2 = perform_lp_optimization(\n    cobrak_model=toy_model,\n    objective_target=ERROR_SUM_VAR_ID,\n    objective_sense=-1,\n    with_thermodynamic_constraints=True,\n    with_enzyme_constraints=True,\n    correction_config=CorrectionConfig(\n        error_scenario=flux_and_concentration_error_scenario,\n        add_kcat_times_e_error_term=True,\n        add_dG0_error_term=True,\n        add_km_error_term=True,\n    ),\n)\n\nprint_dict(correction_result_2)\n\n# Now, we apply the correction (i.e. set the corrected\n# parameter values to our model, overwriting the old parameter values)\ncorrected_cobrak_model = apply_error_correction_on_model(\n    cobrak_model=toy_model,\n    correction_result=correction_result_2,\n    min_abs_error_value=0.01,\n    min_rel_error_value=0.01,\n    verbose=True,\n)\n</code></pre>"},{"location":"parameter_corrections.html#introduction","title":"Introduction","text":"<p>Often, when you just created a COBRA-k model, you'll find out that known in vivo flux/concentration/etc. measurements do not work with your model. In other words, with your model, the given in vivo flux/concentration/etc. scenario is infeasible :-(</p> <p>This infeasibility can be caused by too restrictive parameters in your model. It is also possible that the measurements were perfomed with an error so that their resulting values need to be corrected. In other words, the following possibilities may have caused a scenario infeasibility:</p> <ol> <li>[If reaction fluxes caused the infeasibility] The measurement fluxes contain an error and need to be corrected</li> <li>[If metabolite concentrations caused it] The measurement concentrations contain an error and need to be corrected</li> <li>[If a measured flux cannot be reached] One or more \\(k_{cat}\\) values in your model is too low.</li> <li>[If a measured flux appears to be thermodynamically impossible] One or more \\(\u0394G'\u00b0\\) values in your model is too high, making thermodynamic term(s) \\(\u03b3\\) too low.</li> <li>[If a measured flux appears to be impossible with regards to its associated saturation terms] One or more \\(k_M\\) values in your model is either too low (for product-associated \\(k_M\\)) or too high (for substrate-associated \\(k_M\\)), making saturation term(s) \\(\u03ba\\) too low.</li> </ol> <p>COBRA-k contains a rational way to tackle these infeasibilities and provides functions to find out the lowest needed measurement and/or parameter corrections to make a scenario feasible :-)</p>"},{"location":"parameter_corrections.html#formulation-of-minimal-correction-calculation","title":"Formulation of minimal correction calculation","text":""},{"location":"parameter_corrections.html#general-sum-of-all-correction-types","title":"General sum of all correction types","text":"<p>Info</p> <p>The mentioned minimal correction calculation works with LPs (see LP chapter), MILPs (see MILP chapter), NLPs (see NLP chapter) and the evolutionary optimization (see evolution chapter). Therefore, we concentrate on the addition of variables to all these problems and the addition of the minimal correction objective.</p> <p>As mentioned, we want to minimize the needed correction(s) to make a scenario feasible with our model. So in general, we have the following objective:</p> \\[ \\operatorname*{\\mathbf{min}} \\ \\sum{corr^{fluxes} + corr^{concentrations} + corr^{k_{cat}\u22c5[E]}} + corr^{\u0394_r G^{\u00b4\u00b0}} + corr^{k_M}  \\\\ s.t. \\space LP, \\space MILP, \\space NLP \\space or \\space evolution \\space constraints \\] <p>where \\(corr^X\\) stands for a given correction error sum type. You can freely select whether you want every or just some of the correction types. If you ignore a correction type, its correction sum will be simply set to 0. Each of the correction types is explained in the following paragraphs:</p>"},{"location":"parameter_corrections.html#flux-scenario-correction","title":"Flux scenario correction","text":"<p>If we have given reaction flux measurements \\(\\mathbf{v^{measured,min}}\\) and \\(\\mathbf{v^{measured,max}}\\) (i.e. lower and higher measured values, as e.g. resulting from a standard deviation), we can formulate our correction \\(corr^{fluxes}\\) as follows for any reaction \\(i\\) that was measured and is included in \\(\\mathbf{v^{measured}}\\):</p> <p>$corr^{fluxes} = \\sum_i {corr^{fluxes,+}_i + corr^{fluxes,-}_i} $</p> <p>So, for each measured reaction \\(i\\), we have an adding correction variable corr^{fluxes,+}_i and a subtracting variable corr^{fluxes,-}_i. In our optimization problem, they are introduced with the following constraints:</p> <p>\\(v_i \u2265 v^{measured,min}_i - corr^{fluxes,-}_i\\) \\(v_i \u2264 v^{measured,max}_i + corr^{fluxes,+}_i\\)</p> <p>This way, \\(v_i\\) is now able to be corrected such that the measured flux range can be reached :-)</p>"},{"location":"parameter_corrections.html#logarithmic-concentration-scenario-correction","title":"Logarithmic concentration scenario correction","text":"<p>Note</p> <p>This correction is very similar to the one with fluxes (see above)</p> <p>If we have given logarithmic concentration measurements \\(\\mathbf{\\tilde{x}^{measured}}\\), we can formulate our correction \\(corr^{concentrations}\\) as follows for any metabolite \\(j\\) that was measured and is included in \\(\\mathbf{\\tilde{x}^{measured}}\\):</p> <p>$corr^{concentrations} = \\sum_i {corr^{concentrations,+}_i + corr^{concentrations,-}_i} $</p> <p>So, for each measured metabolite \\(j\\), we have an adding correction variable corr^{concentrations,+}_i and a subtracting variable corr^{concentrations,-}_i. In our optimization problem, they are introduced with the following constraints:</p> <p>\\(\\tilde{x}_j \u2264 \\tilde{x}^{measured,min}_i - corr^{concentrations,-}_i\\) \\(\\tilde{x}_j \u2265 \\tilde{x}^{measured,max}_i + corr^{concentrations,+}_i - corr^{concentrations,-}_i\\)</p> <p>This way, \\(\\tilde{x}_j\\) is now able to be corrected such that the measured concentrations can be reached :-)</p>"},{"location":"parameter_corrections.html#k_cate-correction","title":"\\(k_{cat}\u22c5[E]\\) correction","text":"<p>E.g. if we have a given scenario with reaction fluxes and we see that our model cannot reach these reaction fluxes (i.e. our model's reachable fluxes are too low), it might be a good idea to run a \\(V^+\\) (i.e. maximal possible flux) correction. In other words, we try to make \\(k_{cat}\u22c5[E]\\) so high that the fluxes can be reached. To do so, we modify our reaction flux terms as follows:</p> <ul> <li>In LPs with enzyme constraints (see LP chapter):</li> </ul> <p>$ v_i \u2264 E_i \u22c5 k_{cat,i} $</p> <p>becomes</p> <p>$ v_i \u2264 E_i \u22c5 k_{cat,i}^+ + corr^{k_{cat}\u22c5[E]}_i $</p> <ul> <li>In NLPs with enzyme constraints (see NLP chapter):</li> </ul> <p>$ v_i \u2264 V^{+}_i \u22c5 \u03ba_i \u22c5 \u03b3_i $</p> <p>becomes</p> <p>$ v_i \u2264 (V^{+}i + corr^{k{cat}\u22c5[E]}) \u22c5 \u03ba_i \u22c5 \u03b3_i $</p> <p>Hence, the full sum of \\(k_{cat}\u22c5[E]\\) corrections is:</p> <p>$corr^{k_{cat}\u22c5[E]} = \\sum_i {corr^{k_{cat}\u22c5[E]}_i} $</p> <p>Why do we correct \\(k_{cat}\u22c5[E]\\) and not just the \\(k_{cat}\\)?</p> <p>If we would correct the \\(k_{cat}\\) only, any \\(k_{cat,i}\\) would essentially become a variable. Thus, e.g., the LP term $v_i \u2264 E_i \u22c5 k_{cat}^+ $ would become \\(v_i \u2264 E_i \u22c5 k_{cat} \u22c5 corr^{maximal_flux}\\), which would be non-linear and computationally typically too expensive. Using \\(k_{cat}\u22c5[E]\\) omits this problem in LPs (see above).</p>"},{"location":"parameter_corrections.html#g-correction","title":"\\(\u0394G'\u00b0\\) correction","text":"<p>Another possibility why a scenario isn't reached by a model are too strict thermodynamic constraints. I.e. in MILPs (see MILP chapter) and NLPs, the \\(\u0394G'\u00b0\\) of a reaction might be too high making a scenario either thermodynamically infeasible (in MILPs and NLPs) or lowering the thermodynamic term \\(\u03b3_i\\) (in NLPs) too much. To be able to correct this, we modify our thermodynamic terms as follows:</p> <ul> <li>In MILPs and NLPs with thermodynamic constraints (see MILP and NLP chapter):</li> </ul> <p>$ f_i = -(\u0394_r G^{\u00b4\u00b0}i + R \u22c5 T \u22c5 \\mathbf{N{\u22c5,i}} \u22c5 \\mathbf{x\u0303}) $ becomes $ f_i = -(\u0394_r G^{\u00b4\u00b0}i + R \u22c5 T \u22c5 \\mathbf{N{\u22c5,i}} \u22c5 \\mathbf{x\u0303} - corr^{\u0394_r G^{\u00b4\u00b0}}_i) $</p> <p>Hence, the full sum of \\(\u0394_r G^{\u00b4\u00b0}\\) corrections is:</p> <p>$corr^{\u0394_r G^{\u00b4\u00b0}} = \\sum_i {corr^{\u0394_r G^{\u00b4\u00b0}}_i} $</p>"},{"location":"parameter_corrections.html#logarithmic-k_m-correction","title":"Logarithmic \\(k_M\\) correction","text":"<p>Furthermore, it is possible to correct the \\(k_M\\) (Michaelis-Menten constant) value of reactions to reach a scenario. This is only relevant if you have an NLP and saturation terms (\\(\u03ba_i\\)) are restricting your reactions. In these NLPs (see NLP chapter), the corrections are included as follows:</p> <ul> <li>If a metabolite is a substrate (i.e. if a lower \\(k_M\\) could raise \\(\u03ba_i\\)):</li> </ul> <p>$ \\tilde{s}i = \\ln ( \\bar{s} ) = \\sum{j \u2208 \ud835\uddb2_i} ( |N_{j,i}| \u22c5 x\u0303j ) - \\sum{j \u2208 \ud835\uddb2_i} ( |N_{j,i}| \u22c5  \\ln K_{M,j,i} ) $</p> <p>becomes</p> <p>$ \\tilde{s}i = \\ln ( \\bar{s} ) = \\sum{j \u2208 \ud835\uddb2_i} ( |N_{j,i}| \u22c5 x\u0303j ) - \\sum{j \u2208 \ud835\uddb2_i} ( |N_{j,i}| \u22c5  \\ln K_{M,j,i} - corr^{k_{M,j,i}} ) $</p> <ul> <li>If a metabolite is a product (i.e. where a higher \\(k_M\\) could raise \\(\u03ba_i\\)):</li> </ul> <p>$ \\tilde{p}i \u2265 \\ln ( \\bar{p} ) = \\sum{k \u2208 \ud835\uddaf_i} ( N_{k,i} \u22c5 x\u0303 ) - \\sum_{k \u2208 \ud835\uddaf_i} ( N_{k,i} \u22c5  \\ln K_{M,k,i} ) $</p> <p>becomes</p> <p>$ \\tilde{s}i = \\ln ( \\bar{s} ) = \\sum{j \u2208 \ud835\uddb2_i} ( |N_{j,i}| \u22c5 x\u0303j ) - \\sum{j \u2208 \ud835\uddb2_i} ( |N_{j,i}| \u22c5  \\ln K_{M,j,i} + corr^{k_{M,j,i}} ) $</p> <p>Warning</p> <p>All these \\(k_M\\) corrections work in the logarithmic space. To get the \"real\" correction, you have to apply the exponential function on the respective correction value.</p> <p>Hence, the full sum of \\(k_M\\) corrections is:</p> <p>$corr^{k_M} = \\sum_{j,i} {k_{M,j,i}} $</p>"},{"location":"parameter_corrections.html#optional-weights","title":"Optional Weights","text":"<p>Up to now in our formulations, all \\(corr\\) variables got the same weight, i.e. they are all multiplied with 1. But often, we want to use other weights, especially when mixing different types of corrections, with corrections that modify parameters in different orders of magnitude. Therefore, COBRA-k optionally allows one to set weights according to the following procedure, whereby \\(n\\) is a user-defined percentile:</p> <ul> <li>For reaction fluxes and logarithmic concentrations: The absolute value of the given lower scenario bound</li> <li>For \\(k_{cat}\u22c5[E]\\) corrections: The \\(n\\)th percentile of all possible maximal \\(k_{cat}\u22c5[E]\\) values in the model, i.e. of all \\(\u03a9/W_i\\) values.</li> <li>For \\(\u0394_r G^{\u00b4\u00b0}_i\\) corrections: The \\(n\\)th percentile of all absolute \u0394_r G^{\u00b4\u00b0}_i in the model</li> <li>For \\(k_M\\) corrections: The \\(n\\)th percentile of all \\(K_{m,i}\\) in the model</li> </ul>"},{"location":"parameter_corrections.html#optional-quadratic-sum","title":"Optional Quadratic Sum","text":"<p>As an alternative to the linear correction value sum (see above), one can also use a quadratic sum. Such a sum automatically penalizes larger absolute changes and prefers (potentially more) smaller changes. This changes our linear objective function into a quadratic one. E.g., the sum of flux corrections becomes:</p> <p>$corr^{fluxes} = \\sum_i {(corr^{fluxes,+}_i)^2 + (corr^{fluxes,-}_i)^2} $</p> <p>Warning</p> <p>Using a quadratic instead of a linear objective function makes the correction optmization much more computationally complex.</p>"},{"location":"parameter_corrections.html#the-correctionconfig-dataclass","title":"The CorrectionConfig dataclass","text":"<p>Now, in COBRA-k, we can define a corrections scenario and the corrections options using the <code>CorrectionConfig</code> dataclass. It is defined as follows in COBRA-k's <code>dataclass</code> module:</p> <pre><code>@dataclass\nclass CorrectionConfig:\n    \"\"\"Stores the configuration for corrections in a model (see parameter corrections chapter in documentation).\"\"\"\n\n    error_scenario: dict[str, tuple[float, float]] = Field(default_factory=list)\n    \"\"\"A dictionary where keys are error scenarios and values are tuples representing the lower and upper bounds of the error. Defaults to {}.\"\"\"\n    add_flux_error_term: bool = False\n    \"\"\"Indicates whether to add flux error terms. Defaults to False.\"\"\"\n    add_met_logconc_error_term: bool = False\n    \"\"\"Indicates whether to add metabolite log concentration error terms. Defaults to False.\"\"\"\n    add_enzyme_conc_error_term: bool = False\n    \"\"\"Indicates whether to add enzyme concentration error terms. Defaults to False.\"\"\"\n    add_kcat_times_e_error_term: bool = False\n    \"\"\"Indicates whether to add k_cat \u22c5 [E] error terms. Defaults to False.\"\"\"\n    kcat_times_e_error_cutoff: PositiveFloat = 1.0\n    \"\"\"The cutoff value for the k_cat \u22c5 [E] error term. Defaults to 1.0.\"\"\"\n    max_rel_kcat_times_e_correction: PositiveFloat = QUASI_INF\n    \"\"\"Maximal relative correction for the k_cat \u22c5 [E] error error term. Defaults to QUASI_INF.\"\"\"\n    add_dG0_error_term: bool = False\n    \"\"\"Indicates whether to add \u0394G'\u00b0 error terms. Defaults to False.\"\"\"\n    dG0_error_cutoff: PositiveFloat = 1.0\n    \"\"\"The cutoff value for the \u0394G'\u00b0 error terms. Defaults to 1.0.\"\"\"\n    max_abs_dG0_correction: PositiveFloat = QUASI_INF\n    \"\"\"Maximal absolute correction for the dG0 error term. Defaults to QUASI_INF.\"\"\"\n    add_km_error_term: bool = False\n    \"\"\"Indicates whether to add a km error term. Defaults to False.\"\"\"\n    km_error_cutoff: PositiveFloat = 1.0\n    \"\"\"Cutoff value for the \u03ba error term. Defaults to 1.0.\"\"\"\n    max_rel_km_correction: PositiveFloat = 0.999\n    \"\"\"Maximal relative correction for the \u03ba error term. Defaults to 0.999.\"\"\"\n    error_sum_as_qp: bool = False\n    \"\"\"Indicates whether to use a quadratic programming approach for the error sum. Defaults to False.\"\"\"\n    add_error_sum_term: bool = True\n    \"\"\"Whether to add an error sum term. Defaults to True.\"\"\"\n    use_weights: bool = False\n    \"\"\"Indicates whether to use weights for the corrections (otherwise, the weight is 1.0). Defaults to False.\"\"\"\n    weight_percentile: NonNegativeInt = 90\n    \"\"\"Percentile to use for weight calculation. Defaults to 90.\"\"\"\n    extra_weights: dict[str, float] = Field(default_factory=dict)\n    \"\"\"Dictionary to store extra weights for specific corrections. Defaults to {}.\"\"\"\n    var_lb_ub_application: Literal[\"\", \"exp\", \"log\"] = \"\"\n    \"\"\"The application method for variable lower and upper bounds. Either '' (x=x), 'exp' or 'log'. Defaults to ''.\"\"\"\n</code></pre> <p>While many of the member variables are self-explanatory in the context of the previous sub-chapters, some member variables still need to looked at in more detail:</p> <ul> <li><code>error_scenario: dict[str, tuple[float, float]]</code>: This member variable describes the scenario for which you run the correction. E.g., if you have a scenario where the flux of a reaction A is measured to be between 1 and 2, <code>error_scenario</code>would be set to <code>{\"A\": (1, 2)}</code>.</li> <li><code>max_rel_(...): float</code> and <code>max_abs_(...): float</code>variables: With these member variables, you can restrict the maximally possible relative (for \\(k_{cat}\u22c5[E]\\) and \\(k_M\\)) or  absolute (for \\(\u0394_r G^{\u00b4\u00b0}\\)) maximal correction for a parameter.</li> <li><code>var_lb_ub_application: Literal[\"\", \"exp\", \"log\"]</code>: Sometimes, you may have e.g. concentration data in non-logarithmic form. Then, if you set this member variable to <code>\"log\"</code>, we can directly use this data for a concentration <code>error_scenario</code>. Conversely, with<code>\"exp\"</code>, you could apply the exponential function on a measurement with logarithmic values. Keep in mind that this application is applied on all measurements, regardless of whether they represent concentrations or something else.</li> </ul>"},{"location":"parameter_corrections.html#usage-examples-in-code","title":"Usage examples in code","text":"<p>Now, after all this theory and the dataclass explanation, let's see some toy model parameter corrections in COBRA-k :-)</p> <p>Info</p> <p>The given examples are just two of many possible combinations (or non-combinations, if you just want a single type of corrections) of parameter corrections. Feel free to use the combination or single correction type that suits your problem best.</p>"},{"location":"parameter_corrections.html#a-flux-and-concentration-scenario-correction-in-a-milp","title":"A flux and concentration scenario correction in a MILP","text":"<p>Here, we try to find the minimal changes needed to the flux and concentration scenario so that it becomes feasible. I.e. no model parameters are changes.</p> <pre><code># Import relevant classes and functions\nfrom cobrak.lps import perform_lp_optimization\nfrom cobrak.example_models import toy_model\nfrom cobrak.dataclasses import CorrectionConfig\nfrom cobrak.constants import LNCONC_VAR_PREFIX, ERROR_SUM_VAR_ID\nfrom cobrak.printing import print_dict\nfrom math import log\n\n#\nflux_and_concentration_error_scenario = {\n    \"Overflow\": (1.0, 1.4),  # Overflow reaction flux between 1 and 1.4\n    f\"{LNCONC_VAR_PREFIX}M\": (log(0.2), log(0.2)),  # M concentration fixed at .2 molar\n    f\"{LNCONC_VAR_PREFIX}D\": (log(0.23), log(0.25)),  # D concentration betwewen .23 and .25 molar\n}\n\n# With a CorrectionConfig as optional further argument,\n# all explained extra variables for parameter corrections\n# are added to our model automatically :D\n# Now, we can just minimize the sum of correction errors.\ncorrection_result_1 = perform_lp_optimization(\n    cobrak_model=toy_model,\n    objective_target=ERROR_SUM_VAR_ID,\n    objective_sense=-1,\n    with_thermodynamic_constraints=True,\n    correction_config=CorrectionConfig(\n        error_scenario=flux_and_concentration_error_scenario,\n        add_flux_error_term=True,\n        add_met_logconc_error_term=True,\n    ),\n)\n\nprint_dict(correction_result_1)\n</code></pre>"},{"location":"parameter_corrections.html#a-k_cate-g-and-k_m-correction-in-an-nlp-and-application-of-correction-on-model","title":"A \\(k_{cat}\u22c5[E]\\), \\(\u0394G'\u00b0\\) and \\(k_M\\) correction in an NLP, and application of correction on model","text":"<p>Here, we try to find the minimal changes needed to the model's \\(k_{cat}\u22c5[E]\\), \\(\u0394G'\u00b0\\) and \\(k_M\\) such that the given scenario (a gigh Glycolysis flux) can be reached. We then apply (i.e. set the corrected parameters) using <code>apply_error_correction_on_model</code>from COBRA-k's <code>utilities</code> submodule.</p> <pre><code># Import relevant classes and functions\nfrom cobrak.lps import perform_lp_optimization\nfrom cobrak.example_models import toy_model\nfrom cobrak.dataclasses import CorrectionConfig\nfrom cobrak.constants import LNCONC_VAR_PREFIX, ERROR_SUM_VAR_ID\nfrom cobrak.printing import print_dict\nfrom cobrak.utilities import apply_error_correction_on_model\n\n#\nflux_and_concentration_error_scenario = {\n    \"Glycolysis\": (40.0, 45.0),\n}\n\n# Again, minimize the correction error variable sum\ncorrection_result_2 = perform_lp_optimization(\n    cobrak_model=toy_model,\n    objective_target=ERROR_SUM_VAR_ID,\n    objective_sense=-1,\n    with_thermodynamic_constraints=True,\n    with_enzyme_constraints=True,\n    correction_config=CorrectionConfig(\n        error_scenario=flux_and_concentration_error_scenario,\n        add_kcat_times_e_error_term=True,\n        add_dG0_error_term=True,\n        add_km_error_term=True,\n    ),\n)\n\nprint_dict(correction_result_2)\n\n# Now, we apply the correction (i.e. set the corrected\n# parameter values to our model, overwriting the old parameter values)\ncorrected_cobrak_model = apply_error_correction_on_model(\n    cobrak_model=toy_model,\n    correction_result=correction_result_2,\n    min_abs_error_value=0.01,\n    min_rel_error_value=0.01,\n    verbose=True,\n)\n</code></pre>"},{"location":"utilities.html","title":"More COBRA-k utilitites","text":"<p>COBRA-k provides numerous convenience and helper functions that were not highlighted in the last chapters. To get an overview about these functions, look at this domcumentation's API reference. General utility functions can be found in the <code>utilities</code> submodule, specialized utilities in the appropriately named other submodules.</p>"}]}